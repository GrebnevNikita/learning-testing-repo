//Итого
// Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект,
// но имеет возможность перехватывать их.
//
// Проксировать можно любой объект, включая классы и функции.
//
// Синтаксис:
// let proxy = new Proxy(target, {
//   /* ловушки */
// });
// …Затем обычно используют прокси везде вместо оригинального объекта target.
// Прокси не имеет собственных свойств или методов. Он просто перехватывает операцию, если имеется соответствующая ловушка, а иначе перенаправляет её сразу на объект target.
//
// Мы можем перехватывать:
//
// Чтение (get), запись (set), удаление (deleteProperty) свойства (даже несуществующего).
// Вызов функции (apply).
// Оператор new (ловушка construct).
// И многие другие операции (полный список приведён в начале статьи, а также в документации).
// Это позволяет нам создавать «виртуальные» свойства и методы, реализовывать значения по умолчанию, наблюдаемые объекты, функции-декораторы и многое другое.
//
// Мы также можем оборачивать один и тот же объект много раз в разные прокси, добавляя ему различные аспекты функциональности.
//
// Reflect API создано как дополнение к Proxy. Для любой ловушки из Proxy существует метод в Reflect с теми же аргументами.
// Нам следует использовать его, если нужно перенаправить вызов на оригинальный объект.
//
// Прокси имеют некоторые ограничения:
//
// Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать.
// Однако, ранее в этой главе был показан один способ, как обойти это ограничение.
// То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов.
// То есть вызовы проксированных методов должны иметь оригинальный объект в качестве this, чтобы получить к ним доступ.
// Проверка объектов на строгое равенство === не может быть перехвачена.
// Производительность: конкретные показатели зависят от интерпретатора,
// но в целом получение свойства с помощью простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение только для некоторых «особо нагруженных» объектов.



//Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать
// (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие.
// Далее мы будем называть такие объекты «прокси».







let proxy = new Proxy(target, handler);
// target – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
//     handler – конфигурация прокси: объект с «ловушками» («traps»): методами,
//     которые перехватывают разные операции, например,
//     ловушка get – для чтения свойства из target,
//     ловушка set – для записи свойства в target и так далее.



// В качестве начального примера создадим прокси без всяких ловушек:

let target = {};
let proxy = new Proxy(target, {}); // пустой handler

proxy.test = 5; // записываем в прокси (1)
alert(target.test); // 5, свойство появилось в target!

alert(proxy.test); // 5, мы также можем прочитать его из прокси (2)

for(let key in proxy) alert(key); // test, итерация работает (3)
// Так как нет ловушек, то все операции на proxy применяются к оригинальному объекту target.




//Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на target.


// Сейчас, если фразы в dictionary нет, при чтении возвращается undefined.
// Но на практике оставлять фразы непереведёнными лучше, чем использовать undefined. Поэтому давайте сделаем так, чтобы при отсутствии перевода возвращалась оригинальная фраза на английском вместо undefined.
// Чтобы достичь этого, обернём dictionary в прокси, перехватывающий операцию чтения:

    let dictionary = {
        'Hello': 'Hola',
        'Bye': 'Adiós'
    };

dictionary = new Proxy(dictionary, {
    get(target, phrase) { // перехватываем чтение свойства в dictionary
        if (phrase in target) { // если перевод для фразы есть в словаре
            return target[phrase]; // возвращаем его
        } else {
            // иначе возвращаем непереведённую фразу
            return phrase;
        }
    }
});

// Запросим перевод произвольного выражения в словаре!
// В худшем случае оно не будет переведено
alert( dictionary['Hello'] ); // Hola
alert( dictionary['Welcome to Proxy']); // Welcome to Proxy (нет перевода)















