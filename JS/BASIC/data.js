alert('Привет, мир!');
// <script src="/path/to/script.js"></script>
"use strict"; // этот код работает в современном режиме

[1, 2].forEach(alert);

// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
const COLOR_RED = "#F00";



alert(1 / 0); // Infinity
alert(Infinity); // Infinity
alert("не число" / 2); // NaN, такое деление является ошибкой
// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
// Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
let age;
alert(age); // выведет "undefined"
let age = 123;
age = undefined; // изменяем значение на undefined



let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!
// Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
let isBoss = confirm("Ты здесь главный?");
alert(isBoss); // true, если нажата OK



alert("6" / "2"); // 3, строки преобразуются в числа

alert(Number("   123   ")); // 123
alert(Number("123z"));      // NaN (ошибка чтения числа на месте символа "z")
alert(Number(true));        // 1
alert(Number(false));       // 0

alert(Boolean(1)); // true
alert(Boolean(0)); // false
alert(Boolean("Привет!")); // true
alert(Boolean("")); // false
alert(Boolean("0")); // true
// Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.

x = -x;// Унарным называется оператор, который применяется к одному операнду.
alert(y - x); // Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

let apples = "2";
let oranges = "3";
alert(+apples + +oranges); // 5 // оба операнда предварительно преобразованы в числа
alert( Number(apples) + Number(oranges) ); // 5 // более длинный вариант

if (1 && 0) { // вычисляется как true && false
}

// Оператор нулевого слияния (??)
let result = a ?? b // (a !== null && a !== undefined) ? a : b;


function sayHi() {   // (1) создаём
    alert("Привет");
}
let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)
let sayHi = function () {
};

ask("Вы согласны?", showOk, showCancel); // использование: функции showOk, showCancel передаются в качестве аргументов ask
function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
}
function showOk() {
}
function showCancel() {
}
// Мы можем переписать этот пример значительно короче, используя Function Expression:
ask(
    "Вы согласны?",
    function () {
        alert("Вы согласились.");
    },
    function () {
        alert("Вы отменили выполнение.");
    })


let age = 16; // возьмём для примера 16
if (age < 18) {
    welcome();               // \   (выполнится)
    function welcome() {     //  |
        alert("Привет!");      //  |  Function Declaration доступно
    }                        //  |  во всём блоке кода, в котором объявлено
    welcome();               // /   (выполнится)
} else {
    function welcome() {
        alert("Здравствуйте!");
    }
}
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.
welcome(); // Ошибка: welcome is not defined


// Стрелочные функции, основы
let sum = (a, b) => a + b;
// let sum = (a, b) => {
//     return a + b;
// };
// let sum = function(a, b) {
//   return a + b;
// };
alert(sum(1, 2)); // 3


// В JavaScript есть 8 основных типов данных.
//  Семь из них называют «примитивными» типами данных:
// typeof
let value = true; // boolean
value = String(value); // теперь value это строка "true" // string
typeof undefined // "undefined" //     undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
typeof 0 // "number" //     number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
typeof 10n // "bigint" //     bigint для целых чисел произвольной длины.
typeof true // "boolean" //     boolean для true/false.
typeof "foo" // "string" //     string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
typeof Symbol("id") // "symbol" //     symbol для уникальных идентификаторов.
typeof null // "object"  (2) //     null для неизвестных значений – отдельный тип, имеющий одно значение null.
typeof alert // "function"  (3)

//     И один не является «примитивным» и стоит особняком:
typeof Math // "object"  (1) //     object для более сложных структур данных.



let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
let user = {     // объект
    name: "John",  // под ключом "name" хранится значение "John"
    age: 30        // под ключом "age" хранится значение 30
};
// получаем свойства объекта:
alert(user.name); // John
alert(user.age); // 30
// Для удаления свойства мы можем использовать оператор delete:
delete user.age;

let user = {};
// присваивание значения свойству
user["likes birds"] = true;
// получение значения свойства
alert(user["likes birds"]); // true
// удаление свойства
delete user["likes birds"];

let fruit = 'apple';
let bag = {
    [fruit + 'Computers']: 5 // bag.appleComputers = 5
};

// Вместо name:name мы можем написать просто name:
function makeUser(name, age) {
    return {
        name, // то же самое, что и name: name
        age   // то же самое, что и age: age
        // ...
    };
}

// Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:
let user = {
    name,  // тоже самое, что и name:name
    age: 30
};


let user = {};
alert(user.noSuchProperty === undefined); // true означает "свойства нет"

// Это когда свойство существует, но содержит значение undefined:
let obj = {
    test: undefined
};

alert(obj.test); //  выведет undefined, значит свойство не существует?
alert("test" in obj); // true, свойство существует!

let user = {
    name: "John",
    age: 30,
    isAdmin: true
};

for (let key in user) {
    // ключи
    alert(key);  // name, age, isAdmin
    // значения ключей
    alert(user[key]); // John, 30, true
}


let codes = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США"
};

for (let code in codes) {
    alert(code); // 1, 41, 44, 49
}
// Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. Добавления знака "+" перед каждым кодом будет достаточно.
let codes = {
    "+49": "Германия",
    "+41": "Швейцария",
    "+44": "Великобритания",
    // ..,
    "+1": "США"
};

for (let code in codes) {
    alert(+code); // 49, 41, 44, 1
}


// Здесь мы помещаем копию message во phrase:

let message = "Привет!";
let phrase = message;
// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".

// Объекты ведут себя иначе.
let user = {name: "John"};
let admin = user; // копируется ссылка


// Сравнение по ссылке
// Два объекта равны только в том случае, если это один и тот же объект.

// Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:

let a = {};
let b = a; // копирование по ссылке

alert(a == b); // true, обе переменные ссылаются на один и тот же объект
alert(a === b); // true
// И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):

let a = {};
let b = {}; // два независимых объекта

alert(a == b); // false


// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
//     Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
//     Возвращает объект dest.
//     Например, мы можем использовать его для объединения нескольких объектов в один:

let user = {name: "John"};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }
// Если скопированное имя свойства уже существует, оно будет перезаписано:

let user1 = {canView: true}


let objects = [{'a': 1}, {'b': 2}];

// Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.
let deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false


let user = {
    name: "John",
    age: 30
};
user.sayHi = function (rrr) {
    alert("Привет!" + rrr);
};
user.sayHi(123); // Привет!
// Конечно, мы могли бы использовать заранее объявленную функцию в качестве метода, вот так:

let user = {
    // ...
};

// сначала, объявляем
function sayHi() {
    alert("Привет!");
}

// затем добавляем в качестве метода
user.sayHi = sayHi;

user.sayHi(); // Привет!


// Существует более короткий синтаксис для методов в литерале объекта:

// эти объекты делают одно и то же

user = {
    sayHi: function () {
        alert("Привет");
    }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
        alert("Привет");
    }
};
// Как было показано, мы можем пропустить ключевое слово "function" и просто написать sayHi().


let user = {
    name: "John",
    age: 30,

    sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
    }

};

user.sayHi(); // John


// Значение this вычисляется во время выполнения кода, в зависимости от контекста.

// Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:

let user = {name: "John"};
let admin = {name: "Admin"};

function sayHi() {
    alert(this.name);
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

// Значение this определяется во время исполнения кода.


// Функция-конструктор
// Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
//
//     Имя функции-конструктора должно начинаться с большой буквы.
//     Функция-конструктор должна выполняться только с помощью оператора "new".

// Другими словами, new User(...) делает что-то вроде:

function User(name) {
    // this = {};  (неявно)

    // добавляет свойства к this
    this.name = name;
    this.isAdmin = false;

    // return this;  (неявно)
}

// Таким образом, let user = new User("Jack") возвращает тот же результат, что и:

let user = {
    name: "Jack",
    isAdmin: false
};

// Если в нашем коде присутствует большое количество строк, создающих один сложный объект,
// то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:

// создаём функцию и сразу же вызываем её с помощью new
let user = new function () {
    this.name = "John";
    this.isAdmin = false;

    // ...другой код для создания пользователя
    // возможна любая сложная логика и инструкции
    // локальные переменные и так далее
};
// Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся
// и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.


// Возврат значения из конструктора, return
// Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
//
//     Но если return всё же есть, то применяется простое правило:
//
//     При вызове return с объектом, вместо this вернётся объект.
//     При вызове return с примитивным значением, оно проигнорируется.
//     Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.
//
//     К примеру, здесь return замещает this, возвращая объект:

function BigUser() {

    this.name = "John";

    return {name: "Godzilla"};  // <-- возвращает этот объект
}

alert(new BigUser().name);  // Godzilla, получили этот объект
// А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно):

function SmallUser() {

    this.name = "John";

    return; // <-- возвращает this
}

alert(new SmallUser().name);  // John

//
// Создание методов в конструкторе
// Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.
//
//     Конечно, мы можем добавить к this не только свойства, но и методы.
//
//     Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

function User(name) {
    this.name = name;

    this.sayHi = function () {
        alert("Меня зовут: " + this.name);
    };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
//


// Опциональная цепочка '?.'
// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил. !!!!!


// Очевидным решением было бы проверить значение с помощью if или условного оператора ?, прежде чем обращаться к его свойству, вот так:

let user = {};

alert(user.address ? user.address.street : undefined);


// Опциональная цепочка
// Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
//
//     Далее в этой статье, для краткости, мы будем говорить, что что-то «существует», если оно не является null и не undefined.
//
//     Другими словами, value?.prop:
//
// работает как value.prop, если значение value существует,
//     в противном случае (когда value равно undefined/null) он возвращает undefined.
//     Вот безопасный способ получить доступ к user.address.street, используя ?.:

let user = {}; // пользователь без адреса

alert(user?.address?.street); // undefined (без ошибки)


// Сокращённое вычисление
// Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть не существует.
//
//     Так что если после ?. есть какие-то вызовы функций или операции, то они не произойдут.
//
//     Например:

let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось


// Другие варианты применения: ?.(), ?.[]
// Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.
//
//     Например, ?.() используется для вызова функции, которая может не существовать.
//
//     В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:

let userAdmin = {
    admin() {
        alert("Я админ");
    }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)


// Тип данных Symbol


//
// Тип данных Symbol
// По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
//
//     До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.
//
//     Символы
// «Символ» представляет собой уникальный идентификатор.
//
//     Создаются новые символы с помощью функции Symbol():

// Создаём новый символ - id
let id = Symbol();
// При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
// Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

// Например, вот два символа с одинаковым описанием – но они не равны:

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false


// Символы в литеральном объекте
// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.

// Вот так:

let id = Symbol("id");

let user = {
    name: "Вася",
    [id]: 123 // просто "id: 123" не сработает
};
// Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
//
// Символы игнорируются циклом for…in

// Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут
// работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.

// Глобальные символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert(id === idAgain); // true


// получаем имя по символу
alert(Symbol.keyFor(sym)); // name
alert(Symbol.keyFor(sym2)); // id


// Хинты
// Как JavaScript решает, какое преобразование применить?
//

"string"
// Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;


// "number"
// Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

// Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
//
//     Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
//     Иначе, если хинт равен "string"
// попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
//     Иначе, если хинт равен "number" или "default"
// попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

// Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
//
//     Например, здесь объект user реализует его:

let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
        alert(`hint: ${hint}`);
        return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

// Для примера, используем их в реализации всё того же объекта user. Но уже используя комбинацию toString и valueOf вместо Symbol.toPrimitive:

let user = {
    name: "John",
    money: 1000,

    // для хинта равного "string"
    toString() {
        return `{name: "${this.name}"}`;
    },

    // для хинта равного "number" или "default"
    valueOf() {
        return this.money;
    }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500


// Примитив как объект
//
//  Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.


let str = "Привет";
alert(str.toUpperCase()); // ПРИВЕТ

// null/undefined не имеют методов
let billion = 1000000000;

let billion = 1_000_000_000
// Символ нижнего подчёркивания _ – это «синтаксический сахар», он делает число более читабельным.

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

// toString(base)
let num = 255;
alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111


// Внимание! Две точки в 123456..toString(36) это не опечатка.
// Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.


// Округление
// Одна из часто используемых операций при работе с числами – это округление.
//
//     В JavaScript есть несколько встроенных функций для работы с округлением:
//
//     Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
// Math.trunc (не поддерживается в Internet Explorer)
// Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.


// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// alert( 0.1 + 0.2 == 0.3 ); // false
// Да-да, сумма 0.1 и 0.2 не равна 0.3.
//
//     Странно! Что тогда, если не 0.3?
//
//     alert( 0.1 + 0.2 ); // 0.30000000000000004

let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30


('b' + 'a' + +'a' + 'a').toLowerCase()
// banana


// Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:

alert(NaN === NaN); // false


// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num));

// parseInt и parseFloat
// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

alert(+"100px"); // NaN

alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке

Math.random()


let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк


alert(`The backslash: \\`); // The backslash: \


let str = `Hello`;

// получаем первый символ
alert(str[0]); // H
alert(str.at(0)); // H

// получаем последний символ
alert(str[str.length - 1]); // o
alert(str.at(-1)); // o


// Также можно перебрать строку посимвольно, используя for..of:
for (let char of "Hello") {
    alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}


//
// Строки неизменяемы
// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.
//
//
//     let str = 'Hi';
//
// str[0] = 'h'; // ошибка
// alert( str[0] ); // не работает
alert('Interface'.toUpperCase()); // INTERFACE
alert('Interface'.toLowerCase()); // interface


let str = 'Widget with id';

alert(str.indexOf('Widget')); // 0, потому что подстрока 'Widget' найдена в начале
alert(str.indexOf('widget')); // -1, совпадений нет, поиск чувствителен к регистру

alert(str.indexOf("id")); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

// Необязательный второй аргумент позволяет начать поиск с определённой позиции.
alert(str.indexOf('id', 2)) // 12

// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
    let foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;

    alert(`Найдено тут: ${foundPos}`);
    pos = foundPos + 1; // продолжаем со следующей позиции
}


str.lastIndexOf(substr, position)
// Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
// Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.


let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}


alert("Widget with id".includes("Widget")); // true

alert("Hello".includes("Bye")); // false
// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert("Midget".includes("id")); // true
alert("Midget".includes("id", 3)); // false, поиск начат с позиции 3
// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert("Widget".startsWith("Wid")); // true, "Wid" — начало "Widget"
alert("Widget".endsWith("get")); // true, "get" — окончание "Widget"


let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert(str.slice(0, 5));
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert(str.slice(0, 1));
// Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert(str.slice(2)); // ringify, с позиции 2 и до конца
// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert(str.slice(-4, -1)); // gif

let str = "stringify";

// для substring эти два примера — одинаковы
alert(str.substring(2, 6)); // "ring"
alert(str.substring(6, 2)); // "ring"

// …но не для slice:
alert(str.slice(2, 6)); // "ring" (то же самое)
alert(str.slice(6, 2)); // "" (пустая строка)


// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert(str.substr(2, 4));
// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert(str.substr(-4, 2));


// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его.

// будет иметь разные коды
alert("z".codePointAt(0)); // 122
alert("Z".codePointAt(0)); // 90
alert(String.fromCodePoint(90)); // Z


// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
    str += String.fromCodePoint(i);
}
alert(str);
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ


let arr = new Array();
let arr = [];

let fruits = ["Яблоко", "Апельсин", "Слива"];

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert(fruits[0]); // Яблоко
alert(fruits[1]); // Апельсин
alert(fruits[2]); // Слива


fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]


alert(fruits.length); // 3


// В массиве могут храниться элементы любого типа.
// разные типы значений
let arr = ['Яблоко', {name: 'Джон'}, true, function () {
    alert('привет');
}];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert(arr[1].name); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет


// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

let fruits = [
    "Яблоко",
    "Апельсин",
    "Слива",
];
// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.


let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[fruits.length - 1]); // Plum
alert(fruits.at(-1)); // Plum !!! НОВИНКА МОЖЕТ НЕ ВЕЗДЕ РАБОТАТЬ


// Очередь
// first in, first out

// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
// push добавляет элемент в конец.

// стек
// push добавляет элемент в конец.
// pop удаляет последний элемент.


// Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.pop()); // удаляем "Груша" и выводим его
alert(fruits); // Яблоко, Апельсин


// Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert(fruits); // Яблоко, Апельсин, Груша

// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....


// Методы, работающие с началом массива:

// shift
// Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert(fruits.shift()); // удаляем Яблоко и выводим его

alert(fruits); // Апельсин, Груша
// unshift
// Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert(fruits); // Яблоко, Апельсин, Груша
// Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert(fruits);


let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert(arr === fruits); // true

arr.push("Груша"); // массив меняется по ссылке

alert(fruits); // Банан, Груша - теперь два элемента


// Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
// Операция shift должна выполнить 3 действия:

// Удалить элемент с индексом 0.
// Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
//     Обновить свойство length .
// То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.
//


// Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
    alert(arr[i]);
}
// Но для массивов возможен и другой вариант цикла, for..of:

let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
    alert(fruit);
}


// Технически, так как массив является объектом, можно использовать и вариант for..in:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
    alert(arr[key]); // Яблоко, Апельсин, Груша
}
// Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

// В общем, не следует использовать цикл for..in для массивов.


// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fruits = [];
fruits[123] = "Яблоко";

alert(fruits.length); // 124
// Обратите внимание, что обычно мы не используем массивы таким образом.
//
//     Ещё один интересный факт о свойстве length – его можно перезаписать.
//
//     Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:

let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert(arr); // [1, 2]

arr.length = 5; // возвращаем length как было
alert(arr[3]); // undefined: значения не восстановились
// Таким образом, самый простой способ очистить массив – это arr.length = 0;.


// Многомерные массивы
// Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

alert(matrix[1][1]); // 5, центральный элемент


//
// toString
// Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.


let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true


// В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи оператора ==.


// Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
// Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив, как описано в главе Преобразование объектов в примитивы.
// …За исключением null и undefined, которые равны == друг другу и ничему больше.


// Как удалить элемент из массива?

// Так как массивы – это объекты, то можно попробовать delete:

let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert(arr[1]); // undefined

// теперь arr = ["I",  , "home"];
alert(arr.length); // 3


let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert(arr); // осталось ["Я", "JavaScript"]


let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert(arr) // теперь ["Давай", "танцевать", "прямо", "сейчас"]


// Здесь видно, что splice возвращает массив из удалённых элементов:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert(removed); // "Я", "изучаю" <-- массив из удалённых элементов


// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"


let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert(arr); // 1,2,3,4,5


// slice
// Метод arr.slice намного проще, чем похожий на него arr.splice.

arr.slice([start], [end])
// Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

let arr = ["t", "e", "s", "t"];

alert(arr.slice(1, 3)); // e,s (копирует с 1 до 3)

alert(arr.slice(-2)); // s,t (копирует с -2 до конца)
// Можно вызвать slice без аргументов: arr.slice() создаёт копию arr.
// Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.


// concat
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.


let arr = [1, 2];

// создать массив из: arr и [3,4]
alert(arr.concat([3, 4])); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6


// Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:

let arr = [1, 2];

let arrayLike = {
    0: "что-то",
    length: 1
};

alert(arr.concat(arrayLike)); // 1,2,[object Object]
// …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:
let arr = [1, 2];
let arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
};

alert(arr.concat(arrayLike)); // 1,2,что-то,ещё


// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

arr.forEach(function (item, index, array) {
    // ... делать что-то с item
});
// Например, этот код выведет на экран каждый элемент массива:

// Вызов alert для каждого элемента
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
// А этот вдобавок расскажет и о позиции элемента в целевом массиве:

["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
    alert(`У ${item} индекс ${index} в ${array}`);
});


let arr = [1, 0, false];

alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2
alert(arr.indexOf(null)); // -1

alert(arr.includes(1)); // true

// Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.


let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert(fruits.indexOf('Яблоко')); // 0 (первый 'Яблоко')
alert(fruits.lastIndexOf('Яблоко')); // 2 (последний 'Яблоко')


// Метод includes правильно обрабатывает NaN
// Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от indexOf:

const arr = [NaN];
alert(arr.indexOf(NaN)); // -1 (неверно, должен быть 0)
alert(arr.includes(NaN));// true (верно)
// Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный алгоритм сравнения.


// find и findIndex/findLastIndex

function isPrime(element, index, array) {
    var start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {
            return false;
        }
    }
    return element > 1;
}

console.log([4, 6, 8, 12].find(isPrime)); // undefined, не найдено
console.log([4, 5, 8, 12].find(isPrime)); // 5

let result = arr.find(function (item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"},
    {id: 4, name: "Вася"}
];

// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0

// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3


// filter
// Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
//
//     Если найденных элементов может быть много, можно использовать arr.filter(fn).
//
//     Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

let results = arr.filter(function (item, index, array) {
    // если `true` -- элемент добавляется к results и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});
// Например:

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2


// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.


let result = arr.map(function (item, index, array) {
    // возвращается новое значение вместо элемента
});
// Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6


// sort(fn)
// По умолчанию элементы сортируются как строки.
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}

let arr = [1, 2, 15];
arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
[1, -2, 15, 2, 0, 8].sort(function (a, b) {
    alert(a + " <> " + b);
    return a - b;
});

let arr = [1, 2, 15];
arr.sort(function (a, b) {
    return a - b;
});
alert(arr);  // 1, 2, 15

// стрелочные функции

arr.sort((a, b) => a - b);


// Используйте localeCompare для строк
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert(countries.sort((a, b) => a > b ? 1 : -1)); // Andorra, Vietnam, Österreich (неправильно)
alert(countries.sort((a, b) => a.localeCompare(b))); // Andorra,Österreich,Vietnam (правильно!)


// reverse
// Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert(arr); // 5,4,3,2,1


// split и join

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
    alert(`Сообщение получат: ${name}.`); // Сообщение получат: Вася (и другие имена)
}
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert(str.split('')); // т,е,с,т


let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert(str); // Вася;Петя;Маша


// let value = arr.reduce(function(accumulator, item, index, array) {
//     // ...
// }, [initial]);
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

// Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.


// Массивы не образуют отдельный тип данных. Они основаны на объектах.
alert(typeof {}); // object
alert(typeof []); // тоже object

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true


for (let char of "test") {
    // срабатывает 4 раза: по одному для каждого символа
    alert(char); // t, затем e, затем s, затем t
}


// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
//     map.size – возвращает текущее количество элементов.

let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3


// в обычном обьекте нельзя нормально сделать поле обьектом, а в map можно
let john = {name: "John"};
let ben = {name: "Ben"};

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет замещён

// Вот что там было записано!
alert(visitsCountObj["[object Object]"]); // 123


//map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.


let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук", 50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
    alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
    alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
    alert(entry); // огурец,500 (и так далее)
}


// Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
    alert(`${key}: ${value}`); // огурец: 500 и так далее
});


// Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
    name: "John",
    age: 30
};

let map = new Map(Object.entries(obj));

alert(map.get('name')); // John


// Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2


//Set
// Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
//
// Его основные методы это:
//
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.
// Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

let set = new Set();

let john = {name: "John"};
let pete = {name: "Pete"};
let mary = {name: "Mary"};

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
    alert(user.name); // John (потом Pete и Mary)
}

// Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:
let set = new Set(["апельсин", "яблоко", "банан"]);
for (let value of set) alert(value);
// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
    alert(value);
});


//set.values() – возвращает перебираемый объект для значений,
// set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
// set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


let john = {name: "John"};

let array = [john];
john.name = 123;
console.log(john)// 123!!!
console.log(array)// 123!!!


// Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект


Object.keys(obj), Object.values(obj), Object.entries(obj).map.keys(), map.values(), map.entries()
//     Методы поддерживаются для структур:
// Map
// Set
// Array

let user = {
    name: "John",
    age: 30
};
// Object.keys(user) = ["name", "age"]
// Object.values(user) = ["John", 30]
// Object.entries(user) = [ ["name","John"], ["age",30] ]

let user = {
    name: "John",
    age: 30
};

// перебор значений
for (let value of Object.values(user)) {
    alert(value); // John, затем 30
}


//Object.keys/values/entries игнорируют символьные свойства
// Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.


//Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:
//
// Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:
//
let prices = {
    banana: 1,
    orange: 2,
    meat: 4,
};

let doublePrices = Object.fromEntries(
    // преобразовать в массив, затем map, затем fromEntries обратно объект
    Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8


// Деструктуризация массива
// Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
alert(firstName); // Ilya
alert(surname);  // Kantor


// «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2


//Деструктуризация объекта

let options = {
    title: "Menu",
    width: 100,
    height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200


let now = new Date();
alert(now); // показывает текущие дату и время

// Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert(Jan01_1970);

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert(Jan02_1970);


// Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

// Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert(Dec31_1969);


let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)


new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
// Максимальная точность – 1 мс (до 1/1000 секунды):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(date); // 1.01.2011, 02:03:04.567

// getFullYear()
// Получить год (4 цифры)
// getMonth()
// Получить месяц, от 0 до 11.
// getDate()
// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getDay()
// getTime()


// getTimezoneOffset()
// Возвращает разницу в минутах между UTC и местным часовым поясом:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert(new Date().getTimezoneOffset());

// Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0:
// getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить

//Установка компонентов даты
// Следующие методы позволяют установить компоненты даты и времени:
//
// setFullYear(year, [month], [date])
// setMonth(month, [date])
// setDate(date)
// setHours(hour, [min], [sec], [ms])
// setMinutes(min, [sec], [ms])
// setSeconds(sec, [ms])
// setMilliseconds(ms)
// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().


// Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!

let date = new Date();
alert(+date); // количество миллисекунд, то же самое, что date.getTime()


let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
    let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert(`Цикл отработал за ${end - start} миллисекунд`); // вычитаются числа, а не даты


// Но какая функция быстрее?
//
//     Для начала можно запустить их много раз подряд и засечь разницу. В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.
//
//     Проведём измерения:

function diffSubtract(date1, date2) {
    return date2 - date1;
}

function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime();
}

function bench(f) {
    let date1 = new Date(0);
    let date2 = new Date();

    let start = Date.now();
    for (let i = 0; i < 100000; i++) f(date1, date2);
    return Date.now() - start;
}

alert('Время diffSubtract: ' + bench(diffSubtract) + 'мс');
alert('Время diffGetTime: ' + bench(diffGetTime) + 'мс');
// Вот это да! Метод getTime() работает ощутимо быстрее! Всё потому, что не производится преобразование типов, и интерпретаторам такое намного легче оптимизировать.

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)


// JSON.stringify для преобразования объектов в JSON.
// JSON.parse для преобразования JSON обратно в объект.

let student = {
    name: 'John',
    age: 30,
    isAdmin: false,
    courses: ['html', 'css', 'js'],
    wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // мы получили строку!

alert(json);
/* выведет объект в формате JSON:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
// число в JSON остаётся числом
alert(JSON.stringify(1)) // 1

// строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
alert(JSON.stringify('test')) // "test"

alert(JSON.stringify(true)); // true

alert(JSON.stringify([1, 2, 3])); // [1,2,3]


//JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.
//
// Свойства-функции (методы).
// Символьные ключи и значения.
// Свойства, содержащие undefined.
let user = {
    sayHi() { // будет пропущено
        alert("Hello");
    },
    [Symbol("id")]: 123, // также будет пропущено
    something: undefined // как и это - пропущено
};

alert(JSON.stringify(user)); // {} (пустой объект)

// Вот типичные ошибки в написанном от руки JSON (иногда приходится писать его для отладки):
JSON.parse(json);
let json = `{
  name: "John",                     // Ошибка: имя свойства без кавычек
  "surname": 'Smith',               // Ошибка: одинарные кавычки в значении (должны быть двойными)
  'isAdmin': false,                 // Ошибка: одинарные кавычки в ключе (должны быть двойными)
  "birthday": new Date(2000, 2, 3), // Ошибка: не допускается конструктор "new", только значения
  "gender": "male"                  // Ошибка: отсутствует запятая после непоследнего свойства
  "friends": [0,1,2,3],             // Ошибка: не должно быть запятой после последнего свойства
}`;

let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function (key, value) {
    if (key == 'date') return new Date(value);
    return value;
});

alert(schedule.meetups[1].date.getDate()); // 18 - отлично!


// Итеративный способ: цикл for:

function pow(x, n) {
    let result = 1;

    // умножаем result на x n раз в цикле
    for (let i = 0; i < n; i++) {
        result *= x;
    }

    return result;
}

alert(pow(2, 3)); // 8
// Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
}

alert(pow(2, 3)); // 8


//Остаточные параметры (...)


//Многие встроенные функции JavaScript поддерживают произвольное количество аргументов.
//
// Math.max(arg1, arg2, ..., argN) – вычисляет максимальное число из переданных.
// Object.assign(dest, src1, ..., srcN) – копирует свойства из исходных объектов src1..N в

function sum(a, b) {
    return a + b;
}

function sumAll(...args) { // args — имя массива
    let sum = 0;

    for (let arg of args) sum += arg;

    return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6


// Остаточные параметры должны располагаться в конце
// Остаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них. Это вызовет ошибку:

// function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!
//                                   // Ошибка
// }


// Переменная "arguments"
// Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.

function showName() {
    alert(arguments.length);
    alert(arguments[0]);
    alert(arguments[1]);

    // Объект arguments можно перебирать
    // for (let arg of arguments) alert(arg);
}

// Вывод: 2, Юлий, Цезарь
showName("Юлий", "Цезарь");

// Вывод: 1, Илья, undefined (второго аргумента нет)
showName("Илья");


// Стрелочные функции не имеют "arguments"
// Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.

function f() {
    let showArg = () => alert(arguments[0]);
    showArg(2);
}

f(1); // 1
// Как мы помним, у стрелочных функций нет собственного this. Теперь мы знаем, что нет и своего объекта arguments.


let arr = [3, 5, 1];

alert(Math.max(arr)); // NaN

let arr = [3, 5, 1];

alert(Math.max(...arr)); // 5 (оператор "раскрывает" массив в список аргументов)

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(...arr1, ...arr2)); // 8

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(1, ...arr1, 2, ...arr2, 25)); // 25


let str = "Привет";

alert([...str]); // П,р,и,в,е,т


// Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.
{
    // показать сообщение
    let message = "Hello";
    alert(message);
}

{
    // показать другое сообщение
    let message = "Goodbye";
    alert(message);
}

// Функция называется «вложенной», когда она создаётся внутри другой функции.

function sayHiBye(firstName, lastName) {

    // функция-помощник, которую мы используем ниже
    function getFullName() {
        return firstName + " " + lastName;
    }

    alert("Hello, " + getFullName());
    alert("Bye, " + getFullName());

}

// Ниже, makeCounter создает функцию «счётчик», которая при каждом вызове возвращает следующее число:

function makeCounter() {
    let count = 0;

    return function () {
        return count++; // есть доступ к внешней переменной "count"
    };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2


//Замыкания
// В программировании есть общий термин: «замыкание», – который должен знать каждый разработчик.
//
// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// В некоторых языках это невозможно, или функция должна быть написана специальным образом,
// чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются
// замыканиями (есть только одно исключение, про которое будет рассказано в


// Для «var» не существует блочной области видимости


// Глобальный объект
// Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.
// По умолчанию это те, что встроены в язык или среду исполнения.
//
//     В браузере он называется window


//Объект функции, NFE
// Как мы уже знаем, в JavaScript функция – это значение.
//
// Каждое значение в JavaScript имеет свой тип. А функция – это какой тип?
//
// В JavaScript функции – это объекты.

function sayHi() {
    alert("Hi");
}

alert(sayHi.name); // sayHi

let sayHi = function () {
    alert("Hi");
};

alert(sayHi.name); // sayHi (есть имя!)
let user = {

    sayHi() {
        // ...
    },

    sayBye: function () {
        // ...
    }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye


// функция объявлена внутри массива
let arr = [function () {
}];

alert(arr[0].name); // <пустая строка>
// здесь отсутствует возможность определить имя, поэтому его нет


// Свойство «length»
// Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. Например:

function f1(a) {
}

function f2(a, b) {
}

function many(a, b, ...more) {
}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2


//
// Пользовательские свойства
// Мы также можем добавить свои собственные свойства.
//
//     Давайте добавим свойство counter для отслеживания общего количества вызовов:

function sayHi() {
    alert("Hi");

    // давайте посчитаем, сколько вызовов мы сделали
    sayHi.counter++;
}

sayHi.counter = 0; // начальное значение

sayHi(); // Hi
sayHi(); // Hi

alert(`Вызвана ${sayHi.counter} раза`); // Вызвана 2 раза


// Синтаксис "new Function"
// Существует ещё один вариант объявления функции. Он используется крайне редко, но иногда другого решения не найти.

let func = new Function([arg1, arg2, ...argN], functionBody);
// Функция создаётся с заданными аргументами arg1...argN и телом functionBody.
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
// А вот функция без аргументов, в этом случае достаточно указать только тело:
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
// let str = ... код, полученный с сервера динамически ...

let func = new Function(str);
func();


// setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
// setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.


function sayHi() {
    alert('Привет');
}

setTimeout(sayHi, 1000);

function sayHi(phrase, who) {
    alert(phrase + ', ' + who);
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

// неправильно!
// setTimeout(sayHi(), 1000);


// Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.

let timerId = setTimeout(eny);
clearTimeout(timerId);

let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)


// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => {
    clearInterval(timerId);
    alert('stop');
}, 5000);

/** вместо:
 let timerId = setInterval(() => alert('tick'), 2000);
 */

let timerId = setTimeout(function tick() {
    alert('tick');
    timerId = setTimeout(tick, 2000); // (*)
}, 2000);


// Прозрачное кеширование
function slow(x) {
    // здесь могут быть ресурсоёмкие вычисления
    alert(`Called with ${x}`);
    return x;
}

function cachingDecorator(func) {
    let cache = new Map();

    return function (x) {
        if (cache.has(x)) {    // если кеш содержит такой x,
            return cache.get(x); // читаем из него результат
        }

        let result = func(x); // иначе, вызываем функцию

        cache.set(x, result); // и кешируем (запоминаем) результат
        return result;
    };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1) кешируем
alert("Again: " + slow(1)); // возвращаем из кеша

alert(slow(2)); // slow(2) кешируем
alert("Again: " + slow(2)); // возвращаем из кеша


// Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами.
function say(phrase) {
    alert(this.name + ': ' + phrase);
}

let user = {name: "John"};

// 'user' становится 'this', и "Hello" становится первым аргументом
say.call(user, "Hello"); // John: Hello


let worker = {
    someMethod() {
        return 1;
    },

    slow(x) {
        alert("Called with " + x);
        return x * this.someMethod(); // (*)
    }
};

function cachingDecorator(func) {
    let cache = new Map();
    return function (x) {
        if (cache.has(x)) {
            return cache.get(x);
        }
        let result = func.call(this, x); // теперь 'this' передаётся правильно
        cache.set(x, result);
        return result;
    };
}

worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

alert(worker.slow(2)); // работает
alert(worker.slow(2)); // работает, не вызывая первоначальную функцию (кешируется)

// Чтобы всё было понятно, давайте посмотрим глубже, как передаётся this:

// После декорации worker.slow становится обёрткой function (x) { ... }.
// Так что при выполнении worker.slow(2) обёртка получает 2 в качестве аргумента и this=worker (так как это объект перед точкой).
// Внутри обёртки, если результат ещё не кеширован, func.call(this, x) передаёт текущий this (=worker) и текущий аргумент (=2) в оригинальную функцию.


//Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов, в то время как apply принимает псевдомассив.
//
// Эти два вызова почти эквивалентны:
//
// func.call(context, ...args); // передаёт массив как список с оператором расширения
// func.apply(context, args);   // тот же эффект
// Есть только одна небольшая разница:
//
// Оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.
// А apply принимает только псевдомассив args.
// Так что эти вызовы дополняют друг друга. Для перебираемых объектов сработает call, а где мы ожидаем псевдомассив – apply.

//Теперь давайте сделаем ещё одно небольшое улучшение функции хеширования:
//
// function hash(args) {
//   return args[0] + ',' + args[1];
// }
// На данный момент она работает только для двух аргументов. Было бы лучше, если бы она могла склеить любое количество args.
//
// Естественным решением было бы использовать метод arr.join:
//
// function hash(args) {
//   return args.join();
// }
// …К сожалению, это не сработает, потому что мы вызываем hash(arguments), а объект arguments является перебираемым и псевдомассивом, но не реальным массивом.
//
// Таким образом, вызов join для него потерпит неудачу, что мы и можем видеть ниже:
//
// function hash() {
//   alert( arguments.join() ); // Ошибка: arguments.join не является функцией
// }
//
// hash(1, 2);
// Тем не менее, есть простой способ использовать соединение массива:
//
// function hash() {
//   alert( [].join.call(arguments) ); // 1,2
// }
//
// hash(1, 2);
// Этот трюк называется заимствование метода.


//
// Потеря «this»
// Мы уже видели примеры потери this. Как только метод передаётся отдельно от объекта – this теряется.


let user = {
    firstName: "Вася",
    sayHi() {
        alert(`Привет, ${this.firstName}!`);
    }
};
setTimeout(user.sayHi, 1000); // Привет, undefined!


let user = {
    firstName: "Вася",
    sayHi() {
        alert(`Привет, ${this.firstName}!`);
    }
};

setTimeout(function () {
    user.sayHi(); // Привет, Вася!
}, 1000);
// setTimeout(() => user.sayHi(), 1000); // Привет, Вася!


// В современном JavaScript у функций есть встроенный метод bind, который позволяет зафиксировать this.

// полный синтаксис будет представлен немного позже
let boundFunc = func.bind(context);

let user = {
    firstName: "Вася",
    sayHi() {
        alert(`Привет, ${this.firstName}!`);
    }
};

let sayHi = user.sayHi.bind(user); // (*)

sayHi(); // Привет, Вася!

setTimeout(sayHi, 1000); // Привет, Вася!
// В строке (*) мы берём метод user.sayHi и привязываем его к user. Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или передана в setTimeout (контекст всегда будет правильным).

// Здесь мы можем увидеть, что bind исправляет только this, а аргументы передаются как есть:

let user = {
    firstName: "Вася",
    say(phrase) {
        alert(`${phrase}, ${this.firstName}!`);
    }
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
// Удобный метод: bindAll
// Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:

for (let key in user) {
    if (typeof user[key] == 'function') {
        user[key] = user[key].bind(user);
    }
}

function somef() {

}


// У стрелочных функций нет «this»
// Как мы помним из главы Методы объекта, "this", у стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.

let group = {
    title: "Our Group",
    students: ["John", "Pete", "Alice"],

    showList() {
        this.students.forEach(
            student => alert(this.title + ': ' + student)
        );
    }
};

group.showList();
// Здесь внутри forEach использована стрелочная функция, таким образом this.title в ней будет иметь точно такое же значение, как в методе showList: group.title.

let group = {
    title: "Our Group",
    students: ["John", "Pete", "Alice"],

    showList() {
        this.students.forEach(function (student) {
            // Error: Cannot read property 'title' of undefined
            alert(this.title + ': ' + student)
        });
    }
};

group.showList();

// У стрелочных функций также нет переменной arguments.
function defer(f, ms) {
    return function () {
        setTimeout(() => f.apply(this, arguments), ms)
    };
}

function sayHi(who) {
    alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John"); // выводит "Hello, John" через 2 секунды
// То же самое без стрелочной функции выглядело бы так:

function defer(f, ms) {
    return function (...args) {
        let ctx = this;
        setTimeout(function () {
            return f.apply(ctx, args);
        }, ms);
    };
}

// Здесь мы были вынуждены создать дополнительные переменные args и ctx, чтобы функция внутри setTimeout могла получить их.
//Итого
// Стрелочные функции:
//
// Не имеют this.
// Не имеют arguments.
// Не могут быть вызваны с new.
// (У них также нет super, но мы про это не говорили. Про это будет в главе Наследование классов).
// Всё это потому, что они предназначены для небольшого кода, который не имеет своего «контекста», выполняясь в текущем. И они отлично справляются с этой задачей!


//Флаги свойств
// Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).
//
// writable – если true, свойство можно изменить, иначе оно только для чтения.
// enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
// configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

let user = {
    name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert(JSON.stringify(descriptor, null, 2));
/* дескриптор свойства:
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/

// Например, здесь создаётся свойство name, все флаги которого имеют значение false:

let user = {};

Object.defineProperty(user, "name", {
    value: "John"
});

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert(JSON.stringify(descriptor, null, 2));
/*
{
  "value": "John",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */

// Сделаем свойство user.name доступным только для чтения. Для этого изменим флаг writable:

let user = {
    name: "John"
};

Object.defineProperty(user, "name", {
    writable: false
});

user.name = "Pete"; // Ошибка: Невозможно изменить доступное только для чтения свойство 'name'


//Ошибки появляются только в строгом режиме
// В нестрогом режиме, без use strict, мы не увидим никаких ошибок при записи
// в свойства «только для чтения» и т.п. Но эти операции всё равно не будут выполнены успешно. Действия, нарушающие ограничения флагов, в нестрогом режиме просто молча игнорируются.


// Неперечислимое свойство
let user = {
    name: "John",
    toString() {
        return this.name;
    }
};

Object.defineProperty(user, "toString", {
    enumerable: false
});

// Теперь наше свойство toString пропало из цикла:
for (let key in user) alert(key); // name


// Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.


Object.defineProperties(user, {
    name: {value: "John", writable: false},
    surname: {value: "Smith", writable: false},
    // ...
});


// Свойства - геттеры и сеттеры
let obj = {
    get propName() {
        // геттер, срабатывает при чтении obj.propName
    },

    set propName(value) {
        // сеттер, срабатывает при записи obj.propName = value
    }
};

// Дескрипторы свойств доступа
// Дескрипторы свойств-аксессоров отличаются от «обычных» свойств-данных.
//
//     Свойства-аксессоры не имеют value и writable, но взамен предлагают функции get и set.
//
//     То есть, дескриптор аксессора может иметь:
//
//     get – функция без аргументов, которая сработает при чтении свойства,
//     set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
//     enumerable – то же самое, что и для свойств-данных,
//     configurable – то же самое, что и для свойств-данных.
//     Например, для создания аксессора fullName при помощи defineProperty мы можем передать дескриптор с использованием get и set:

let user = {
    name: "John",
    surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
    get() {
        return `${this.name} ${this.surname}`;
    },

    set(value) {
        [this.name, this.surname] = value.split(" ");
    }
});

alert(user.fullName); // John Smith

for (let key in user) alert(key); // name, surname
// Ещё раз заметим, что свойство объекта может быть либо свойством-аксессором (с методами get/set), либо свойством-данным (со значением value).

// При попытке указать и get, и value в одном дескрипторе будет ошибка:

// Error: Invalid property descriptor.
Object.defineProperty({}, 'prop', {
    get() {
        return 1
    },

    value: 2
});

// Умные геттеры/сеттеры
// Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, чтобы получить больше контроля над операциями с ними.
//
//     Например, если мы хотим запретить устанавливать короткое имя для user, мы можем использовать сеттер name для проверки, а само значение хранить в отдельном свойстве _name:

let user = {
    get name() {
        return this._name;
    },

    set name(value) {
        if (value.length < 4) {
            alert("Имя слишком короткое, должно быть более 4 символов");
            return;
        }
        this._name = value;
    }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = ""; // Имя слишком короткое...


// Прототипы, наследование

// Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object,
// а оно отсутствует, JavaScript автоматически берёт его из прототипа.
// В программировании такой механизм называется «прототипным наследованием».
// Многие интересные возможности языка и техники программирования основываются на нём.


let animal = {
    eats: true
};
let rabbit = {
    jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true


let animal = {
    eats: true,
    walk() {
        alert("Animal walk");
    }
};

let rabbit = {
    jumps: true,
    __proto__: animal
};

let longEar = {
    earLength: 10,
    __proto__: rabbit
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)


// Операция записи не использует прототип
// Прототип используется только для чтения свойств.
//
//     Операции записи/удаления работают напрямую с объектом.
//
//     В приведённом ниже примере мы присваиваем rabbit собственный метод walk:

    let animal = {
        eats: true,
        walk() {
            /* этот метод не будет использоваться в rabbit */
        }
    };

let rabbit = {
    __proto__: animal
};

rabbit.walk = function() {
    alert("Rabbit! Bounce-bounce!");
};

rabbit.walk(); // Rabbit! Bounce-bounce!


// Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.

    // По этой причине admin.fullName работает корректно в приведённом ниже коде:

    let user = {
        name: "John",
        surname: "Smith",

        set fullName(value) {
            [this.name, this.surname] = value.split(" ");
        },

        get fullName() {
            return `${this.name} ${this.surname}`;
        }
    };

let admin = {
    __proto__: user,
    isAdmin: true
};

alert(admin.fullName); // John Smith (*)

// срабатывает сеттер!
admin.fullName = "Alice Cooper"; // (**)
alert(admin.name); // Alice
alert(admin.surname); // Cooper
// Здесь в строке (*) свойство admin.fullName имеет геттер в прототипе user, поэтому вызывается он. В строке (**) свойство также имеет сеттер в прототипе, который и будет вызван.



// Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.
// Цикл for…in
// Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.


let animal = {
    eats: true
};

let rabbit = {
    jumps: true,
    __proto__: animal
};

// Object.keys возвращает только собственные ключи
alert(Object.keys(rabbit)); // jumps

// for..in проходит и по своим, и по унаследованным ключам
for(let prop in rabbit) alert(prop); // jumps, затем eats



// Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

    let animal = {
        eats: true
    };

let rabbit = {
    jumps: true,
    __proto__: animal
};

for(let prop in rabbit) {
    let isOwn = rabbit.hasOwnProperty(prop);

    if (isOwn) {
        alert(`Our: ${prop}`); // Our: jumps
    } else {
        alert(`Inherited: ${prop}`); // Inherited: eats
    }
}


// F.prototype
// Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
let animal = {
    eats: true
};

function Rabbit(name) {
    this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
// Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".

// F.prototype используется только в момент вызова new F
// F.prototype используется только при вызове new F и присваивается в качестве свойства [[Prototype]] нового объекта.

// Если после создания свойство F.prototype изменится (F.prototype = <другой объект>), то новые объекты, созданные с помощью new F, будут иметь в качестве [[Prototype]] другой объект, а уже существующие объекты сохранят старый.

// У каждой функции (за исключением стрелочных) по умолчанию уже есть свойство "prototype".

// По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.


    function Rabbit() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true
// Соответственно, если мы ничего не меняем, то свойство constructor будет доступно всем кроликам через [[Prototype]]:

function Rabbit() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // наследует от {constructor: Rabbit}

alert(rabbit.constructor == Rabbit); // true (свойство получено из прототипа)








// Встроенные прототипы
// Свойство "prototype" широко используется внутри самого языка JavaScript. Все встроенные функции-конструкторы используют его.
// …Но краткая нотация obj = {} – это то же самое, что и obj = new Object()


// Таким образом, когда вызывается obj.toString(), метод берётся из Object.prototype.
let obj = {};
alert(obj.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString === Object.prototype.toString
// Обратите внимание, что по цепочке прототипов выше Object.prototype больше нет свойства [[Prototype]]:
alert(Object.prototype.__proto__); // null

//Другие встроенные прототипы
// Другие встроенные объекты, такие как Array, Date, Function и другие, также хранят свои методы в прототипах.
//
// Например, при создании массива [1, 2, 3] внутренне используется конструктор массива Array. Поэтому прототипом массива становится Array.prototype, предоставляя ему свои методы. Это позволяет эффективно использовать память.
//
// Согласно спецификации, наверху иерархии встроенных прототипов находится Object.prototype. Поэтому иногда говорят, что «всё наследует от объектов».
//
// Вот более полная картина (для трёх встроенных объектов):


//Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом. Методы этих объектов также находятся в прототипах, доступных как String.prototype, Number.prototype и Boolean.prototype.
//
// Значения null и undefined не имеют объектов-обёрток
// Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.

//Изменение встроенных прототипов
// Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:
//
// String.prototype.show = function() {
//   alert(this);
// };
//
// "BOOM!".show(); // BOOM!

//В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.
//
// Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.
//
// Тогда мы можем реализовать его сами и добавить во встроенный прототип.

// if (!String.prototype.repeat) { // Если такого метода нет
//   // добавляем его в прототип
//
//   String.prototype.repeat = function(n) {
//     // повторить строку n раз
//
//     // на самом деле код должен быть немного более сложным
//     // (полный алгоритм можно найти в спецификации)
//     // но даже неполный полифил зачастую достаточно хорош для использования
//     return new Array(n + 1).join(this);
//   };
// }
//
// alert( "La".repeat(3) ); // LaLaLa

























//Методы прототипов, объекты без свойства __proto__
// Свойство __proto__ считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.
//
// Современные же методы это:
//
// Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
// Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
// Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
// Эти методы нужно использовать вместо __proto__.
//
// Например:
//
// let animal = {
//   eats: true
// };
//
// // создаём новый объект с прототипом animal
// let rabbit = Object.create(animal);
//
// alert(rabbit.eats); // true
//
// alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit
//
// Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
// У Object.create есть необязательный второй аргумент: дескрипторы свойств. Мы можем добавить дополнительное свойство новому объекту таким образом:
//
// let animal = {
//   eats: true
// };
//
// let rabbit = Object.create(animal, {
//   jumps: {
//     value: true
//   }
// });
//
// alert(rabbit.jumps); // true
// Формат задания дескрипторов описан в главе Флаги и дескрипторы свойств.
//
// Мы также можем использовать Object.create для «продвинутого» клонирования объекта, более мощного, чем копирование свойств в цикле for..in:
//
// // клон obj c тем же прототипом (с поверхностным копированием свойств)
// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// Такой вызов создаёт точную копию объекта obj, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё это с правильным свойством [[Prototype]].
//
// Краткая история
// Если пересчитать все способы управления прототипом, то их будет много! И многие из них делают одно и то же!
//
// Почему так?
//
// В силу исторических причин.
//
// Свойство "prototype" функции-конструктора существует с совсем давних времён.
// Позднее, в 2012 году, в стандарте появился метод Object.create. Это давало возможность создавать объекты с указанным прототипом, но не позволяло устанавливать/получать его. Тогда браузеры реализовали нестандартный аксессор __proto__, который позволил устанавливать/получать прототип в любое время.
// Позднее, в 2015 году, в стандарт были добавлены Object.setPrototypeOf и Object.getPrototypeOf, заменяющие собой аксессор __proto__, который упоминается в Приложении Б стандарта, которое не обязательно к поддержке в небраузерных окружениях. При этом де-факто __proto__ всё ещё поддерживается везде.
// В итоге сейчас у нас есть все эти способы для работы с прототипом.
//
// Почему же __proto__ был заменён на функции getPrototypeOf/setPrototypeOf? Читайте далее, чтобы узнать ответ.
//
// Не меняйте [[Prototype]] существующих объектов, если важна скорость
// Технически мы можем установить/получить [[Prototype]] в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, а после не меняем: rabbit наследует от animal, и это не изменится.
//
// И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта. Так что лучше избегайте этого кроме тех случаев, когда вы знаете, что делаете, или же когда скорость JavaScript для вас не имеет никакого значения.
//
// "Простейший" объект
// Как мы знаем, объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.
//
// …Но если мы попробуем хранить созданные пользователями ключи (например, словари с пользовательским вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением "__proto__".
//
// Посмотрите на пример:
//
// let obj = {};
//
// let key = prompt("What's the key?", "__proto__");
// obj[key] = "some value";
//
// alert(obj[key]); // [object Object], не "some value"!
// Если пользователь введёт __proto__, присвоение проигнорируется!
//
// И это не должно удивлять нас. Свойство __proto__ особенное: оно должно быть либо объектом, либо null, а строка не может стать прототипом.
//
// Но мы не намеревались реализовывать такое поведение, не так ли? Мы хотим хранить пары ключ/значение, и ключ с именем "__proto__" не был сохранён надлежащим образом. Так что это ошибка!
//
// Конкретно в этом примере последствия не так ужасны, но если мы присваиваем объектные значения, то прототип и в самом деле может быть изменён. В результате дальнейшее выполнение пойдёт совершенно непредсказуемым образом.
//
// Что хуже всего – разработчики не задумываются о такой возможности совсем. Это делает такие ошибки сложным для отлавливания или даже превращает их в уязвимости, особенно когда JavaScript используется на сервере.
//
// Неожиданные вещи могут случаться также при присвоении свойства toString, которое по умолчанию функция, и других свойств, которые тоже на самом деле являются встроенными методами.
//
// Как же избежать проблемы?
//
// Во-первых, мы можем переключиться на использование коллекции Map, и тогда всё будет в порядке.
//
// Но и Object может также хорошо подойти, потому что создатели языка уже давно продумали решение проблемы.
//
// Свойство __proto__ – не обычное, а аксессор, заданный в Object.prototype:
//
//
// Так что при чтении или установке obj.__proto__ вызывается соответствующий геттер/сеттер из прототипа obj, и именно он устанавливает/получает свойство [[Prototype]].
//
// Как было сказано в начале этой секции учебника, __proto__ – это способ доступа к свойству [[Prototype]], это не само свойство [[Prototype]].
//
// Теперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:
//
// let obj = Object.create(null);
//
// let key = prompt("What's the key?", "__proto__");
// obj[key] = "some value";
//
// alert(obj[key]); // "some value"
// Object.create(null) создаёт пустой объект без прототипа ([[Prototype]] будет null):
//
//
// Таким образом не будет унаследованного геттера/сеттера для __proto__. Теперь это свойство обрабатывается как обычное свойство, и приведённый выше пример работает правильно.
//
// Мы можем назвать такой объект «простейшим» или «чистым словарным объектом», потому что он ещё проще, чем обычные объекты {...}.
//
// Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как toString:
//
// let obj = Object.create(null);
//
// alert(obj); // Ошибка (no toString)
// …Но обычно это нормально для ассоциативных массивов.
//
// Обратите внимание, что большая часть методов, связанных с объектами, имеют вид Object.something(...). К примеру, Object.keys(obj). Подобные методы не находятся в прототипе, так что они продолжат работать для таких объектов:
//
// let chineseDictionary = Object.create(null);
// chineseDictionary.hello = "你好";
// chineseDictionary.bye = "再见";
//
// alert(Object.keys(chineseDictionary)); // hello,bye
// Итого
// Современные способы установки и прямого доступа к прототипу это:
//
// Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), и необязательными дескрипторами свойств.
// Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
// Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
// Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте. Как минимум потому, что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.
//
// Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.
//
// Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:
//
// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.
//
// Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно использовать как «чистые словари», у них нет проблем с использованием строки "__proto__" в качестве ключа.
//
// Ещё методы:
//
// Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
// Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
// Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
// Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
// obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.
// Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом for..in.





























//Класс: базовый синтаксис
// В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).
//
// Википедия
// На практике нам часто надо создавать много объектов одного вида, например пользователей, товары или что-то ещё.
//
// Как мы уже знаем из главы Конструктор, оператор "new", с этим может помочь new function.
//
// Но в современном JavaScript есть и более продвинутая конструкция «class», которая предоставляет новые возможности, полезные для объектно-ориентированного программирования.
//
// Синтаксис «class»
// Базовый синтаксис выглядит так:
//
// class MyClass {
//   // методы класса
//   constructor() { ... }
//   method1() { ... }
//   method2() { ... }
//   method3() { ... }
//   ...
// }
// Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.
//
// При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.
//
// Например:
//
// class User {
//
//   constructor(name) {
//     this.name = name;
//   }
//
//   sayHi() {
//     alert(this.name);
//   }
//
// }
//
// // Использование:
// let user = new User("Иван");
// user.sayHi();
// Когда вызывается new User("Иван"):
//
// Создаётся новый объект.
// constructor запускается с заданным аргументом и сохраняет его в this.name.
// …Затем можно вызывать на объекте методы, такие как user.sayHi().
//
// Методы в классе не разделяются запятой
// Частая ошибка начинающих разработчиков – ставить запятую между методами класса, что приводит к синтаксической ошибке.
//
// Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.
//
// Что такое класс?
// Итак, что же такое class? Это не полностью новая языковая сущность, как может показаться на первый взгляд.
//
// Давайте развеем всю магию и посмотрим, что такое класс на самом деле. Это поможет в понимании многих сложных аспектов.
//
// В JavaScript класс – это разновидность функции.
//
// Взгляните:
//
// class User {
//   constructor(name) { this.name = name; }
//   sayHi() { alert(this.name); }
// }
//
// // доказательство: User - это функция
// alert(typeof User); // function
// Вот что на самом деле делает конструкция class User {...}:
//
// Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
// Сохраняет все методы, такие как sayHi, в User.prototype.
// При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.
//
// На картинке показан результат объявления class User:
//
//
// Можно проверить вышесказанное и при помощи кода:
//
// class User {
//   constructor(name) { this.name = name; }
//   sayHi() { alert(this.name); }
// }
//
// // класс - это функция
// alert(typeof User); // function
//
// // ...или, если точнее, это метод constructor
// alert(User === User.prototype.constructor); // true
//
// // Методы находятся в User.prototype, например:
// alert(User.prototype.sayHi); // sayHi() { alert(this.name); }
//
// // в прототипе ровно 2 метода
// alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
// Не просто синтаксический сахар
// Иногда говорят, что class – это просто «синтаксический сахар» в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому что мы можем сделать всё то же самое без конструкции class:
//
// // перепишем класс User на чистых функциях
//
// // 1. Создаём функцию constructor
// function User(name) {
//   this.name = name;
// }
// // каждый прототип функции имеет свойство constructor по умолчанию,
// // поэтому нам нет необходимости его создавать
//
// // 2. Добавляем метод в прототип
// User.prototype.sayHi = function() {
//   alert(this.name);
// };
//
// // Использование:
// let user = new User("Иван");
// user.sayHi();
// Результат этого кода очень похож. Поэтому, действительно, есть причины, по которым class можно считать синтаксическим сахаром для определения конструктора вместе с методами прототипа.
//
// Однако есть важные отличия:
//
// Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.
//
// В отличие от обычных функций, конструктор класса не может быть вызван без new:
//
// class User {
//   constructor() {}
// }
//
// alert(typeof User); // function
// User(); // Error: Class constructor User cannot be invoked without 'new'
// Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
//
// class User {
//   constructor() {}
// }
//
// alert(User); // class User { ... }
// Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
//
// И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.
//
// Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
//
// Также в дополнение к основной, описанной выше, функциональности, синтаксис class даёт ряд других интересных возможностей, с которыми мы познакомимся чуть позже.
//
// Class Expression
// Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.
//
// Пример Class Expression (по аналогии с Function Expression):
//
// let User = class {
//   sayHi() {
//     alert("Привет");
//   }
// };
// Аналогично Named Function Expression, Class Expression может иметь имя.
//
// Если у Class Expression есть имя, то оно видно только внутри класса:
//
// // "Named Class Expression"
// // (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
// let User = class MyClass {
//   sayHi() {
//     alert(MyClass); // имя MyClass видно только внутри класса
//   }
// };
//
// new User().sayHi(); // работает, выводит определение MyClass
//
// alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
// Мы даже можем динамически создавать классы «по запросу»:
//
// function makeClass(phrase) {
//   // объявляем класс и возвращаем его
//   return class {
//     sayHi() {
//       alert(phrase);
//     };
//   };
// }
//
// // Создаём новый класс
// let User = makeClass("Привет");
//
// new User().sayHi(); // Привет
// Геттеры/сеттеры, другие сокращения
// Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.
//
// Вот пример user.name, реализованного с использованием get/set:
//
// class User {
//
//   constructor(name) {
//     // вызывает сеттер
//     this.name = name;
//   }
//
//   get name() {
//     return this._name;
//   }
//
//   set name(value) {
//     if (value.length < 4) {
//       alert("Имя слишком короткое.");
//       return;
//     }
//     this._name = value;
//   }
//
// }
//
// let user = new User("Иван");
// alert(user.name); // Иван
//
// user = new User(""); // Имя слишком короткое.
// При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
//
// Object.defineProperties(User.prototype, {
//   name: {
//     get() {
//       return this._name
//     },
//     set(name) {
//       // ...
//     }
//   }
// });
// Пример с вычисляемым свойством в скобках [...]:
//
// class User {
//
//   ['say' + 'Hi']() {
//     alert("Привет");
//   }
//
// }
//
// new User().sayHi();
// Свойства классов
// Старым браузерам может понадобиться полифил
// Свойства классов добавлены в язык недавно.
//
// В приведённом выше примере у класса User были только методы. Давайте добавим свойство:
//
// class User {
//   name = "Аноним";
//
//   sayHi() {
//     alert(`Привет, ${this.name}!`);
//   }
// }
//
// new User().sayHi();
// Свойство name не устанавливается в User.prototype. Вместо этого оно создаётся оператором new перед запуском конструктора, это именно свойство объекта.
//
// Итого
// Базовый синтаксис для классов выглядит так:
//
// class MyClass {
//   prop = value; // свойство
//   constructor(...) { // конструктор
//     // ...
//   }
//   method(...) {} // метод
//   get something(...) {} // геттер
//   set something(...) {} // сеттер
//   [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
//   // ...
// }
// MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.
//
// В следующих главах мы узнаем больше о классах, включая наследование и другие возможности.














//Наследование классов
// Наследование классов – это способ расширения одного класса другим классом.
//
// Таким образом, мы можем добавить новый функционал к уже существующему.
//
// Ключевое слово «extends»
// Допустим, у нас есть класс Animal:
//
// class Animal {
//   constructor(name) {
//     this.speed = 0;
//     this.name = name;
//   }
//   run(speed) {
//     this.speed = speed;
//     alert(`${this.name} бежит со скоростью ${this.speed}.`);
//   }
//   stop() {
//     this.speed = 0;
//     alert(`${this.name} стоит неподвижно.`);
//   }
// }
//
// let animal = new Animal("Мой питомец");
// Вот как мы можем представить объект animal и класс Animal графически:
//
//
// …И мы хотели бы создать ещё один class Rabbit.
//
// Поскольку кролики – это животные, класс Rabbit должен быть основан на Animal, и иметь доступ к методам животных, так чтобы кролики могли делать то, что могут делать «общие» животные.
//
// Синтаксис для расширения другого класса следующий: class Child extends Parent.
//
// Давайте создадим class Rabbit, который наследуется от Animal:
//
// class Rabbit extends Animal {
//   hide() {
//     alert(`${this.name} прячется!`);
//   }
// }
//
// let rabbit = new Rabbit("Белый кролик");
//
// rabbit.run(5); // Белый кролик бежит со скоростью 5.
// rabbit.hide(); // Белый кролик прячется!
// Объект класса Rabbit имеет доступ как к методам Rabbit, таким как rabbit.hide(), так и к методам Animal, таким как rabbit.run().
//
// Внутри ключевое слово extends работает по старой доброй механике прототипов. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. Таким образом, если метода не оказалось в Rabbit.prototype, JavaScript берет его из Animal.prototype.
//
//
// Например, чтобы найти метод rabbit.run, движок проверяет (снизу вверх на картинке):
//
// Объект rabbit (не имеет run).
// Его прототип, то есть Rabbit.prototype (имеет hide, но не имеет run).
// Его прототип, то есть (вследствие extends) Animal.prototype, в котором, наконец, есть метод run.
// Как мы помним из главы Встроенные прототипы, сам JavaScript использует наследование на прототипах для встроенных объектов. Например, Date.prototype.[[Prototype]] является Object.prototype, поэтому у дат есть универсальные методы объекта.
//
// После extends разрешены любые выражения
// Синтаксис создания класса допускает указывать после extends не только класс, но и любое выражение.
//
// Пример вызова функции, которая генерирует родительский класс:
//
// function f(phrase) {
//   return class {
//     sayHi() { alert(phrase); }
//   };
// }
//
// class User extends f("Привет") {}
//
// new User().sayHi(); // Привет
// Здесь class User наследует от результата вызова f("Привет").
//
// Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.
//
// Переопределение методов
// Теперь давайте продвинемся дальше и переопределим метод. По умолчанию все методы, не указанные в классе Rabbit, берутся непосредственно «как есть» из класса Animal.
//
// Но если мы укажем в Rabbit собственный метод, например stop(), то он будет использован вместо него:
//
// class Rabbit extends Animal {
//   stop() {
//     // ...теперь это будет использоваться для rabbit.stop()
//     // вместо stop() из класса Animal
//   }
// }
// Впрочем, обычно мы не хотим полностью заменить родительский метод, а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.
//
// У классов есть ключевое слово "super" для таких случаев.
//
// super.method(...) вызывает родительский метод.
// super(...) для вызова родительского конструктора (работает только внутри нашего конструктора).
// Пусть наш кролик автоматически прячется при остановке:
//
// class Animal {
//
//   constructor(name) {
//     this.speed = 0;
//     this.name = name;
//   }
//
//   run(speed) {
//     this.speed = speed;
//     alert(`${this.name} бежит со скоростью ${this.speed}.`);
//   }
//
//   stop() {
//     this.speed = 0;
//     alert(`${this.name} стоит.`);
//   }
//
// }
//
// class Rabbit extends Animal {
//   hide() {
//     alert(`${this.name} прячется!`);
//   }
//
//   stop() {
//     super.stop(); // вызываем родительский метод stop
//     this.hide(); // и затем hide
//   }
// }
//
// let rabbit = new Rabbit("Белый кролик");
//
// rabbit.run(5); // Белый кролик бежит со скоростью 5.
// rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
// Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop() в процессе выполнения.
//
// У стрелочных функций нет super
// Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.
//
// При обращении к super стрелочной функции он берётся из внешней функции:
//
// class Rabbit extends Animal {
//   stop() {
//     setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
//   }
// }
// В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:
//
// // Unexpected super
// setTimeout(function() { super.stop() }, 1000);
// Переопределение конструктора
// С конструкторами немного сложнее.
//
// До сих пор у Rabbit не было своего конструктора.
//
// Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:
//
// class Rabbit extends Animal {
//   // генерируется для классов-потомков, у которых нет своего конструктора
//   constructor(...args) {
//     super(...args);
//   }
// }
// Как мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор.
//
// Давайте добавим конструктор для Rabbit. Он будет устанавливать earLength в дополнение к name:
//
// class Animal {
//   constructor(name) {
//     this.speed = 0;
//     this.name = name;
//   }
//   // ...
// }
//
// class Rabbit extends Animal {
//
//   constructor(name, earLength) {
//     this.speed = 0;
//     this.name = name;
//     this.earLength = earLength;
//   }
//
//   // ...
// }
//
// // Не работает!
// let rabbit = new Rabbit("Белый кролик", 10); // Error: this is not defined.
// Упс! При создании кролика – ошибка! Что не так?
//
// Если коротко, то:
//
// Конструкторы в наследуемых классах должны обязательно вызывать super(...), и (!) делать это перед использованием this..
// …Но почему? Что происходит? Это требование кажется довольно странным.
//
// Конечно, всему есть своё объяснение. Давайте углубимся в детали, чтобы вы действительно поняли, что происходит.
//
// В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:"derived".
//
// Разница в следующем:
//
// Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
// Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
// Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.
//
// Чтобы конструктор Rabbit работал, он должен вызвать super() до того, как использовать this, чтобы не было ошибки:
//
// class Animal {
//
//   constructor(name) {
//     this.speed = 0;
//     this.name = name;
//   }
//
//   // ...
// }
//
// class Rabbit extends Animal {
//
//   constructor(name, earLength) {
//     super(name);
//     this.earLength = earLength;
//   }
//
//   // ...
// }
//
// // теперь работает
// let rabbit = new Rabbit("Белый кролик", 10);
// alert(rabbit.name); // Белый кролик
// alert(rabbit.earLength); // 10
// Переопределение полей класса: тонкое замечание
// Продвинутое замечание
// В этом подразделе предполагается, что у вас уже есть определённый опыт работы с классами, возможно, в других языках программирования.
//
// Это даёт лучшее представление о языке, а также объясняет поведение, которое может быть источником ошибок (но не очень часто).
//
// Если вы считаете этот материал слишком трудным для понимания, просто продолжайте читать дальше, а затем вернитесь к нему через некоторое время.
//
// Мы можем переопределять не только методы, но и поля класса.
//
// Однако, когда мы получаем доступ к переопределенному полю в родительском конструкторе, это поведение отличается от большинства других языков программирования.
//
// Рассмотрим этот пример:
//
// class Animal {
//   name = 'animal';
//
//   constructor() {
//     alert(this.name); // (*)
//   }
// }
//
// class Rabbit extends Animal {
//   name = 'rabbit';
// }
//
// new Animal(); // animal
// new Rabbit(); // animal
// Здесь, класс Rabbit расширяет Animal и переопределяет поле name своим собственным значением.
//
// В Rabbit нет собственного конструктора, поэтому вызывается конструктор Animal.
//
// Что интересно, в обоих случаях: new Animal() и new Rabbit(), alert в строке (*) показывает animal.
//
// Другими словами, родительский конструктор всегда использует своё собственное значение поля, а не переопределённое.
//
// Что же в этом странного?
//
// Если это ещё не ясно, сравните с методами.
//
// Вот тот же код, но вместо поля this.name, мы вызываем метод this.showName():
//
// class Animal {
//   showName() {  // вместо this.name = 'animal'
//     alert('animal');
//   }
//
//   constructor() {
//     this.showName(); // вместо alert(this.name);
//   }
// }
//
// class Rabbit extends Animal {
//   showName() {
//     alert('rabbit');
//   }
// }
//
// new Animal(); // animal
// new Rabbit(); // rabbit
// Обратите внимание: теперь результат другой.
//
// И это то, чего мы, естественно, ожидаем. Когда родительский конструктор вызывается в производном классе, он использует переопределённый метод.
//
// …Но для полей класса это не так. Как уже было сказано, родительский конструктор всегда использует родительское поле.
//
// Почему же наблюдается разница?
//
// Что ж, причина заключается в порядке инициализации полей. Поле класса инициализируется:
//
// Перед конструктором для базового класса (который ничего не расширяет),
// Сразу после super() для производного класса.
// В нашем случае Rabbit – это производный класс. В нем нет конструктора constructor(). Как было сказано ранее, это то же самое, как если бы был пустой конструктор, содержащий только super(...args).
//
// Итак, new Rabbit() вызывает super(), таким образом, выполняя родительский конструктор, и (согласно правилу для производных классов) только после этого инициализируются поля его класса. На момент выполнения родительского конструктора ещё нет полей класса Rabbit, поэтому используются поля Animal.
//
// Это тонкое различие между полями и методами характерно для JavaScript.
//
// К счастью, такое поведение проявляется только в том случае, когда переопределенное поле используется в родительском конструкторе. Тогда может быть трудно понять, что происходит, поэтому мы объясняем это здесь.
//
// Если это становится проблемой, её можно решить, используя методы или геттеры/сеттеры вместо полей.
//
// Устройство super, [[HomeObject]]
// Продвинутая информация
// Если вы читаете учебник первый раз – эту секцию можно пропустить.
//
// Она рассказывает о внутреннем устройстве наследования и вызов super.
//
// Давайте заглянем «под капот» super. Здесь есть некоторые интересные моменты.
//
// Вообще, исходя из наших знаний до этого момента, super вообще не может работать!
//
// Ну правда, давайте спросим себя – как он должен работать, чисто технически? Когда метод объекта выполняется, он получает текущий объект как this. Если мы вызываем super.method(), то движку необходимо получить method из прототипа текущего объекта. И как ему это сделать?
//
// Задача может показаться простой, но это не так. Движок знает текущий this и мог бы попытаться получить родительский метод как this.__proto__.method. Однако, увы, такой «наивный» путь не работает.
//
// Продемонстрируем проблему. Без классов, используя простые объекты для наглядности.
//
// Вы можете пропустить эту часть и перейти ниже к подсекции [[HomeObject]], если не хотите знать детали. Вреда не будет. Или читайте далее, если хотите разобраться.
//
// В примере ниже rabbit.__proto__ = animal. Попробуем в rabbit.eat() вызвать animal.eat(), используя this.__proto__:
//
// let animal = {
//   name: "Animal",
//   eat() {
//     alert(`${this.name} ест.`);
//   }
// };
//
// let rabbit = {
//   __proto__: animal,
//   name: "Кролик",
//   eat() {
//     // вот как предположительно может работать super.eat()
//     this.__proto__.eat.call(this); // (*)
//   }
// };
//
// rabbit.eat(); // Кролик ест.
// В строке (*) мы берём eat из прототипа (animal) и вызываем его в контексте текущего объекта. Обратите внимание, что .call(this) здесь неспроста: простой вызов this.__proto__.eat() будет выполнять родительский eat в контексте прототипа, а не текущего объекта.
//
// Приведённый выше код работает так, как задумано: выполняется нужный alert.
//
// Теперь давайте добавим ещё один объект в цепочку наследования и увидим, как все сломается:
//
// let animal = {
//   name: "Животное",
//   eat() {
//     alert(`${this.name} ест.`);
//   }
// };
//
// let rabbit = {
//   __proto__: animal,
//   eat() {
//     // ...делаем что-то специфичное для кролика и вызываем родительский (animal) метод
//     this.__proto__.eat.call(this); // (*)
//   }
// };
//
// let longEar = {
//   __proto__: rabbit,
//   eat() {
//     // ...делаем что-то, связанное с длинными ушами, и вызываем родительский (rabbit) метод
//     this.__proto__.eat.call(this); // (**)
//   }
// };
//
// longEar.eat(); // Error: Maximum call stack size exceeded
// Теперь код не работает! Ошибка возникает при попытке вызова longEar.eat().
//
// На первый взгляд все не так очевидно, но если мы проследим вызов longEar.eat(), то сможем понять причину ошибки. В обеих строках (*) и (**) значение this – это текущий объект (longEar). Это важно: для всех методов объекта this указывает на текущий объект, а не на прототип или что-то ещё.
//
// Итак, в обеих линиях (*) и (**) значение this.__proto__ одно и то же: rabbit. В обоих случаях метод rabbit.eat вызывается в бесконечном цикле не поднимаясь по цепочке вызовов.
//
// Картина того, что происходит:
//
//
// Внутри longEar.eat() строка (**) вызывает rabbit.eat со значением this=longEar.
//
// // внутри longEar.eat() у нас this = longEar
// this.__proto__.eat.call(this) // (**)
// // становится
// longEar.__proto__.eat.call(this)
// // то же что и
// rabbit.eat.call(this);
// В строке (*) в rabbit.eat мы хотим передать вызов выше по цепочке, но this=longEar, поэтому this.__proto__.eat снова равен rabbit.eat!
//
// // внутри rabbit.eat() у нас также this = longEar
// this.__proto__.eat.call(this) // (*)
// // становится
// longEar.__proto__.eat.call(this)
// // или (снова)
// rabbit.eat.call(this);
// …rabbit.eat вызывает себя в бесконечном цикле, потому что не может подняться дальше по цепочке.
//
// Проблема не может быть решена с помощью одного только this.
//
// [[HomeObject]]
// Для решения этой проблемы в JavaScript было добавлено специальное внутреннее свойство для функций: [[HomeObject]].
//
// Когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]] становится равно этому объекту.
//
// Затем super использует его, чтобы получить прототип родителя и его методы.
//
// Давайте посмотрим, как это работает – опять же, используя простые объекты:
//
// let animal = {
//   name: "Животное",
//   eat() {         // animal.eat.[[HomeObject]] == animal
//     alert(`${this.name} ест.`);
//   }
// };
//
// let rabbit = {
//   __proto__: animal,
//   name: "Кролик",
//   eat() {         // rabbit.eat.[[HomeObject]] == rabbit
//     super.eat();
//   }
// };
//
// let longEar = {
//   __proto__: rabbit,
//   name: "Длинноух",
//   eat() {         // longEar.eat.[[HomeObject]] == longEar
//     super.eat();
//   }
// };
//
// // работает верно
// longEar.eat();  // Длинноух ест.
// Это работает как задумано благодаря [[HomeObject]]. Метод, такой как longEar.eat, знает свой [[HomeObject]] и получает метод родителя из его прототипа. Вообще без использования this.
//
// Методы не «свободны»
// До этого мы неоднократно видели, что функции в JavaScript «свободны», не привязаны к объектам. Их можно копировать между объектами и вызывать с любым this.
//
// Но само существование [[HomeObject]] нарушает этот принцип, так как методы запоминают свои объекты. [[HomeObject]] нельзя изменить, эта связь – навсегда.
//
// Единственное место в языке, где используется [[HomeObject]] – это super. Поэтому если метод не использует super, то мы все ещё можем считать его свободным и копировать между объектами. А вот если super в коде есть, то возможны побочные эффекты.
//
// Вот пример неверного результата super после копирования:
//
// let animal = {
//   sayHi() {
//     alert("Я животное");
//   }
// };
//
// // rabbit наследует от animal
// let rabbit = {
//   __proto__: animal,
//   sayHi() {
//     super.sayHi();
//   }
// };
//
// let plant = {
//   sayHi() {
//     alert("Я растение");
//   }
// };
//
// // tree наследует от plant
// let tree = {
//   __proto__: plant,
//   sayHi: rabbit.sayHi // (*)
// };
//
// tree.sayHi();  // Я животное (?!?)
// Вызов tree.sayHi() показывает «Я животное». Определённо неверно.
//
// Причина проста:
//
// В строке (*), метод tree.sayHi скопирован из rabbit. Возможно, мы хотели избежать дублирования кода?
// Его [[HomeObject]] – это rabbit, ведь он был создан в rabbit. Свойство [[HomeObject]] никогда не меняется.
// В коде tree.sayHi() есть вызов super.sayHi(). Он идёт вверх от rabbit и берёт метод из animal.
// Вот диаграмма происходящего:
//
//
// Методы, а не свойства-функции
// Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".
//
// Для нас различий нет, но они есть для JavaScript.
//
// В приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет [[HomeObject]], и наследование не работает:
//
// let animal = {
//   eat: function() { // намеренно пишем так, а не eat() { ...
//     // ...
//   }
// };
//
// let rabbit = {
//   __proto__: animal,
//   eat: function() {
//     super.eat();
//   }
// };
//
// rabbit.eat();  // Ошибка вызова super (потому что нет [[HomeObject]])
// Итого
// Чтобы унаследовать от класса: class Child extends Parent:
// При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.
// При переопределении конструктора:
// Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.
// При переопределении другого метода:
// Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.
// Внутренние детали:
// Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы.
// Поэтому копировать метод, использующий super, между разными объектами небезопасно.
// Также:
//
// У стрелочных функций нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.









//Статические свойства и методы
// Мы также можем присвоить метод самому классу. Такие методы называются статическими.
//
// В объявление класса они добавляются с помощью ключевого слова static, например:
//
// class User {
//   static staticMethod() {
//     alert(this === User);
//   }
// }
//
// User.staticMethod(); // true
// Это фактически то же самое, что присвоить метод напрямую как свойство функции:
//
// class User { }
//
// User.staticMethod = function() {
//   alert(this === User);
// };
// Значением this при вызове User.staticMethod() является сам конструктор класса User (правило «объект до точки»).
//
// Обычно статические методы используются для реализации функций, которые будут принадлежать классу в целом, но не какому-либо его конкретному объекту.
//
// Звучит не очень понятно? Сейчас все встанет на свои места.
//
// Например, есть объекты статей Article, и нужна функция для их сравнения.
//
// Естественное решение – сделать для этого статический метод Article.compare:
//
// class Article {
//   constructor(title, date) {
//     this.title = title;
//     this.date = date;
//   }
//
//   static compare(articleA, articleB) {
//     return articleA.date - articleB.date;
//   }
// }
//
// // использование
// let articles = [
//   new Article("HTML", new Date(2019, 1, 1)),
//   new Article("CSS", new Date(2019, 0, 1)),
//   new Article("JavaScript", new Date(2019, 11, 1))
// ];
//
// articles.sort(Article.compare);
//
// alert( articles[0].title ); // CSS
// Здесь метод Article.compare стоит «над» статьями, как средство для их сравнения. Это метод не отдельной статьи, а всего класса.
//
// Другим примером может быть так называемый «фабричный» метод.
//
// Скажем, нам нужно несколько способов создания статьи:
//
// Создание через заданные параметры (title, date и т. д.).
// Создание пустой статьи с сегодняшней датой.
// …или как-то ещё.
// Первый способ может быть реализован через конструктор. А для второго можно использовать статический метод класса.
//
// Такой как Article.createTodays() в следующем примере:
//
// class Article {
//   constructor(title, date) {
//     this.title = title;
//     this.date = date;
//   }
//
//   static createTodays() {
//     // помним, что this = Article
//     return new this("Сегодняшний дайджест", new Date());
//   }
// }
//
// let article = Article.createTodays();
//
// alert( article.title ); // Сегодняшний дайджест
// Теперь каждый раз, когда нам нужно создать сегодняшний дайджест, нужно вызывать Article.createTodays(). Ещё раз, это не метод одной статьи, а метод всего класса.
//
// Статические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных, например:
//
// // предположим, что Article - это специальный класс для управления статьями
// // статический метод для удаления статьи по id:
// Article.remove({id: 12345});
// Статические методы недоступны для отдельных объектов
// Статические методы могут вызываться для классов, но не для отдельных объектов.
//
// Например. такой код не будет работать:
//
// // ...
// article.createTodays(); /// Error: article.createTodays is not a function
// Статические свойства
// Новая возможность
// Эта возможность была добавлена в язык недавно. Примеры работают в последнем Chrome.
// Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:
//
// class Article {
//   static publisher = "Илья Кантор";
// }
//
// alert( Article.publisher ); // Илья Кантор
// Это то же самое, что и прямое присваивание Article:
//
// Article.publisher = "Илья Кантор";
// Наследование статических свойств и методов
// Статические свойства и методы наследуются.
//
// Например, метод Animal.compare в коде ниже наследуется и доступен как Rabbit.compare:
//
// class Animal {
//
//   constructor(name, speed) {
//     this.speed = speed;
//     this.name = name;
//   }
//
//   run(speed = 0) {
//     this.speed += speed;
//     alert(`${this.name} бежит со скоростью ${this.speed}.`);
//   }
//
//   static compare(animalA, animalB) {
//     return animalA.speed - animalB.speed;
//   }
//
// }
//
// // Наследует от Animal
// class Rabbit extends Animal {
//   hide() {
//     alert(`${this.name} прячется!`);
//   }
// }
//
// let rabbits = [
//   new Rabbit("Белый кролик", 10),
//   new Rabbit("Чёрный кролик", 5)
// ];
//
// rabbits.sort(Rabbit.compare);
//
// rabbits[0].run(); // Чёрный кролик бежит со скоростью 5.
// Мы можем вызвать Rabbit.compare, при этом будет вызван унаследованный Animal.compare.
//
// Как это работает? Снова с использованием прототипов. Как вы уже могли предположить, extends даёт Rabbit ссылку [[Prototype]] на Animal.
//
//
// Так что Rabbit extends Animal создаёт две ссылки на прототип:
//
// Функция Rabbit прототипно наследует от функции Animal.
// Rabbit.prototype прототипно наследует от Animal.prototype.
// В результате наследование работает как для обычных, так и для статических методов.
//
// Давайте это проверим кодом:
//
// class Animal {}
// class Rabbit extends Animal {}
//
// // для статики
// alert(Rabbit.__proto__ === Animal); // true
//
// // для обычных методов
// alert(Rabbit.prototype.__proto__ === Animal.prototype); // true
// Итого
// Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.
//
// Например, метод для сравнения двух статей Article.compare(article1, article2) или фабричный метод Article.createTodays().
//
// В объявлении класса они помечаются ключевым словом static.
//
// Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.
//
// Синтаксис:
//
// class MyClass {
//   static property = ...;
//
//   static method() {
//     ...
//   }
// }
// Технически, статическое объявление – это то же самое, что и присвоение классу:
//
// MyClass.property = ...
// MyClass.method = ...
// Статические свойства и методы наследуются.
//
// Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.















//Приватные и защищённые методы и свойства
// Один из важнейших принципов объектно-ориентированного программирования – разделение внутреннего и внешнего интерфейсов.
//
// Это обязательная практика в разработке чего-либо сложнее, чем «hello world».
//
// Чтобы понять этот принцип, давайте на секунду забудем о программировании и обратим взгляд на реальный мир.
//
// Устройства, которыми мы пользуемся, обычно довольно сложно устроены. Но разделение внутреннего и внешнего интерфейсов позволяет нам пользоваться ими без каких-либо проблем.
//
// Пример из реальной жизни
// Например, кофеварка. Простая снаружи: кнопка, экран, несколько отверстий… И, конечно, результат – прекрасный кофе! :)
//
//
// Но внутри… (картинка из инструкции по ремонту)
//
//
// Множество деталей. Но мы можем пользоваться ею, ничего об этом не зная.
//
// Кофеварки довольно надёжны, не так ли? Мы можем пользоваться ими годами, и если что-то пойдёт не так – отнесём в ремонт.
//
// Секрет надёжности и простоты кофеварки – все детали хорошо отлажены и спрятаны внутри.
//
// Если мы снимем защитный кожух с кофеварки, то пользоваться ею будет гораздо сложнее (куда нажимать?) и опаснее (может привести к поражению электрическим током).
//
// Как мы увидим, в программировании объекты похожи на кофеварки.
//
// Но, чтобы скрыть внутренние детали, мы будем использовать не защитный кожух, а специальный синтаксис языка и соглашения.
//
// Внутренний и внешний интерфейсы
// В объектно-ориентированном программировании свойства и методы разделены на 2 группы:
//
// Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
// Внешний интерфейс – методы и свойства, доступные снаружи класса.
// Если мы продолжаем аналогию с кофеваркой – то, что скрыто внутри: трубка кипятильника, нагревательный элемент и т.д. – это внутренний интерфейс.
//
// Внутренний интерфейс используется для работы объекта, его детали используют друг друга. Например, трубка кипятильника прикреплена к нагревательному элементу.
//
// Но снаружи кофеварка закрыта защитным кожухом, так что никто не может добраться до сложных частей. Детали скрыты и недоступны. Мы можем использовать их функции через внешний интерфейс.
//
// Итак, всё, что нам нужно для использования объекта, это знать его внешний интерфейс. Мы можем совершенно не знать, как это работает внутри, и это здорово.
//
// Это было общее введение.
//
// В JavaScript есть два типа полей (свойств и методов) объекта:
//
// Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
// Приватные: доступны только внутри класса. Они для внутреннего интерфейса.
// Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или для дочерних классов (то есть, как приватные, но разрешён доступ для наследующих классов) и также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.
//
// Защищённые поля не реализованы в JavaScript на уровне языка, но на практике они очень удобны, поэтому их эмулируют.
//
// А теперь давайте сделаем кофеварку на JavaScript со всеми этими типами свойств. Кофеварка имеет множество деталей, мы не будем их моделировать для простоты примера (хотя могли бы).
//
// Защищённое свойство «waterAmount»
// Давайте для начала создадим простой класс для описания кофеварки:
//
// class CoffeeMachine {
//   waterAmount = 0; // количество воды внутри
//
//   constructor(power) {
//     this.power = power;
//     alert( `Создана кофеварка, мощность: ${power}` );
//   }
//
// }
//
// // создаём кофеварку
// let coffeeMachine = new CoffeeMachine(100);
//
// // добавляем воды
// coffeeMachine.waterAmount = 200;
// Прямо сейчас свойства waterAmount и power публичные. Мы можем легко получать и устанавливать им любое значение извне.
//
// Давайте изменим свойство waterAmount на защищённое, чтобы иметь больше контроля над ним. Например, мы не хотим, чтобы кто-либо устанавливал его ниже нуля.
//
// Защищённые свойства обычно начинаются с префикса _.
//
// Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.
//
// Так что наше свойство будет называться _waterAmount:
//
// class CoffeeMachine {
//   _waterAmount = 0;
//
//   set waterAmount(value) {
//     if (value < 0) throw new Error("Отрицательное количество воды");
//     this._waterAmount = value;
//   }
//
//   get waterAmount() {
//     return this._waterAmount;
//   }
//
//   constructor(power) {
//     this._power = power;
//   }
//
// }
//
// // создаём новую кофеварку
// let coffeeMachine = new CoffeeMachine(100);
//
// // устанавливаем количество воды
// coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
// Теперь доступ под контролем, поэтому указать воду ниже нуля не удалось.
//
// Свойство только для чтения «power»
// Давайте сделаем свойство power доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось.
//
// Это как раз требуется для кофеварки: мощность никогда не меняется.
//
// Для этого нам нужно создать только геттер, но не сеттер:
//
// class CoffeeMachine {
//   // ...
//
//   constructor(power) {
//     this._power = power;
//   }
//
//   get power() {
//     return this._power;
//   }
//
// }
//
// // создаём кофеварку
// let coffeeMachine = new CoffeeMachine(100);
//
// alert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W
//
// coffeeMachine.power = 25; // Error (no setter)
// Геттеры/сеттеры
// Здесь мы использовали синтаксис геттеров/сеттеров.
//
// Но в большинстве случаев использование функций get.../set... предпочтительнее:
//
// class CoffeeMachine {
//   _waterAmount = 0;
//
//   setWaterAmount(value) {
//     if (value < 0) throw new Error("Отрицательное количество воды");
//     this._waterAmount = value;
//   }
//
//   getWaterAmount() {
//     return this._waterAmount;
//   }
// }
//
// new CoffeeMachine().setWaterAmount(100);
// Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны). Итак, на будущее, если нам надо что-то отрефакторить, функции – более безопасный выбор.
//
// С другой стороны, синтаксис get/set короче, решать вам.
//
// Защищённые поля наследуются
// Если мы унаследуем class MegaMachine extends CoffeeMachine, ничто не помешает нам обращаться к this._waterAmount или this._power из методов нового класса.
//
// Таким образом, защищённые поля, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.
//
// Приватное свойство «#waterLimit»
// Новая возможность
// Эта возможность была добавлена в язык недавно. В движках JavaScript пока не поддерживается или поддерживается частично, нужен полифил.
// Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов.
//
// Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
//
// Например, в классе ниже есть приватное свойство #waterLimit и приватный метод #checkWater для проверки количества воды:
//
// class CoffeeMachine {
//   #waterLimit = 200;
//
//   #checkWater(value) {
//     if (value < 0) throw new Error("Отрицательный уровень воды");
//     if (value > this.#waterLimit) throw new Error("Слишком много воды");
//   }
// }
//
// let coffeeMachine = new CoffeeMachine();
//
// // снаружи  нет доступа к приватным методам класса
// coffeeMachine.#checkWater(); // Error
// coffeeMachine.#waterLimit = 1000; // Error
// На уровне языка # является специальным символом, который означает, что поле приватное. Мы не можем получить к нему доступ извне или из наследуемых классов.
//
// Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно – приватное #waterAmount и публичное waterAmount.
//
// Например, давайте сделаем аксессор waterAmount для #waterAmount:
//
// class CoffeeMachine {
//
//   #waterAmount = 0;
//
//   get waterAmount() {
//     return this.#waterAmount;
//   }
//
//   set waterAmount(value) {
//     if (value < 0) throw new Error("Отрицательный уровень воды");
//     this.#waterAmount = value;
//   }
// }
//
// let machine = new CoffeeMachine();
//
// machine.waterAmount = 100;
// alert(machine.#waterAmount); // Error
// В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.
//
// Но если мы унаследуем от CoffeeMachine, то мы не получим прямого доступа к #waterAmount. Мы будем вынуждены полагаться на геттер/сеттер waterAmount:
//
// class MegaCoffeeMachine extends CoffeeMachine {
//   method() {
//     alert( this.#waterAmount ); // Error: can only access from CoffeeMachine
//   }
// }
// Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем CoffeeMachine, у нас может быть вполне законная причина для доступа к внутренним методам и свойствам. Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.
//
// Важно:
// Приватные поля особенные.
//
// Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]:
//
// class User {
//   ...
//   sayHi() {
//     let fieldName = "name";
//     alert(`Hello, ${this[fieldName]}`);
//   }
// }
// С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.
//
// Итого
// В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.
//
// Это даёт следующие выгоды:
//
// Защита для пользователей, чтобы они не выстрелили себе в ногу
// Представьте себе, что есть команда разработчиков, использующая кофеварку. Она была изготовлена компанией «Лучшие Кофеварки» и работает нормально, но защитный кожух был снят. Внутренний интерфейс стал доступен извне.
//
// Все разработчики культурны – они используют кофеварку по назначению. Но один из них, Джон, решил, что он самый умный, и сделал некоторые изменения во внутренностях кофеварки. После чего кофеварка вышла из строя через два дня.
//
// Это, конечно, не вина Джона, а скорее человека, который снял защитный кожух и позволил Джону делать свои манипуляции.
//
// То же самое в программировании. Если пользователь класса изменит вещи, не предназначенные для изменения извне – последствия непредсказуемы.
//
// Поддерживаемость
// Ситуация в программировании сложнее, чем с реальной кофеваркой, потому что мы не просто покупаем её один раз. Код постоянно подвергается разработке и улучшению.
//
// Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять его внутренние свойства и методы, даже не информируя пользователей…
//
// Если вы разработчик такого класса, то приятно знать, что приватные методы можно безопасно переименовывать, их параметры можно изменять и даже удалять, потому что от них не зависит никакой внешний код.
//
// В новой версии вы можете полностью всё переписать, но пользователю будет легко обновиться, если внешний интерфейс остался такой же.
//
// Сокрытие сложности
// Люди обожают использовать простые вещи. По крайней мере, снаружи. Что внутри – это другое дело.
//
// Программисты не являются исключением.
//
// Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный внешний интерфейс.
//
// Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:
//
// Защищённые поля имеют префикс _. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.
// Приватные поля имеют префикс #. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.
// В настоящее время приватные поля не очень хорошо поддерживаются в браузерах, но можно использовать полифил.











//Расширение встроенных классов
// От встроенных классов, таких как Array, Map и других, тоже можно наследовать.
//
// Например, в этом примере PowerArray наследуется от встроенного Array:
//
// // добавим один метод (можно более одного)
// class PowerArray extends Array {
//   isEmpty() {
//     return this.length === 0;
//   }
// }
//
// let arr = new PowerArray(1, 2, 5, 10, 50);
// alert(arr.isEmpty()); // false
//
// let filteredArr = arr.filter(item => item >= 10);
// alert(filteredArr); // 10, 50
// alert(filteredArr.isEmpty()); // false
// Обратите внимание на интересный момент: встроенные методы, такие как filter, map и другие возвращают новые объекты унаследованного класса PowerArray. Их внутренняя реализация такова, что для этого они используют свойство объекта constructor.
//
// В примере выше,
//
// arr.constructor === PowerArray
// Поэтому при вызове метода arr.filter() он внутри создаёт массив результатов, именно используя arr.constructor, а не обычный массив. Это замечательно, поскольку можно продолжать использовать методы PowerArray далее на результатах.
//
// Более того, мы можем настроить это поведение.
//
// При помощи специального статического геттера Symbol.species можно вернуть конструктор, который JavaScript будет использовать в filter, map и других методах для создания новых объектов.
//
// Если бы мы хотели, чтобы методы map, filter и т. д. возвращали обычные массивы, мы могли бы вернуть Array в Symbol.species, вот так:
//
// class PowerArray extends Array {
//   isEmpty() {
//     return this.length === 0;
//   }
//
//   // встроенные методы массива будут использовать этот метод как конструктор
//   static get [Symbol.species]() {
//     return Array;
//   }
// }
//
// let arr = new PowerArray(1, 2, 5, 10, 50);
// alert(arr.isEmpty()); // false
//
// // filter создаст новый массив, используя arr.constructor[Symbol.species] как конструктор
// let filteredArr = arr.filter(item => item >= 10);
//
// // filteredArr не является PowerArray, это Array
// alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
// Как вы видите, теперь .filter возвращает Array. Расширенная функциональность не будет передаваться далее.
//
// Аналогично работают другие коллекции
// Другие коллекции, такие как Map, Set, работают аналогично. Они также используют Symbol.species.
//
// Отсутствие статического наследования встроенных классов
// У встроенных объектов есть собственные статические методы, например Object.keys, Array.isArray и т. д.
//
// Как мы уже знаем, встроенные классы расширяют друг друга.
//
// Обычно, когда один класс наследует другой, то наследуются и статические методы. Это было подробно разъяснено в главе Статические свойства и методы.
//
// Но встроенные классы – исключение. Они не наследуют статические методы друг друга.
//
// Например, и Array, и Date наследуют от Object, так что в их экземплярах доступны методы из Object.prototype. Но Array.[[Prototype]] не ссылается на Object, поэтому нет методов Array.keys() или Date.keys().
//
// Ниже вы видите структуру Date и Object:
//
//
// Как видите, нет связи между Date и Object. Они независимы, только Date.prototype наследует от Object.prototype.
//
// В этом важное отличие наследования встроенных объектов от того, что мы получаем с использованием extends.
//
// Проводим












//Проверка класса: "instanceof"
// Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.
//
// Такая проверка может потребоваться во многих случаях. Здесь мы используем её для создания полиморфной функции, которая интерпретирует аргументы по-разному в зависимости от их типа.
//
// Оператор instanceof
// Синтаксис:
//
// obj instanceof Class
// Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.
//
// Например:
//
// class Rabbit {}
// let rabbit = new Rabbit();
//
// // это объект класса Rabbit?
// alert( rabbit instanceof Rabbit ); // true
// Также это работает с функциями-конструкторами:
//
// // вместо класса
// function Rabbit() {}
//
// alert( new Rabbit() instanceof Rabbit ); // true
// …И для встроенных классов, таких как Array:
//
// let arr = [1, 2, 3];
// alert( arr instanceof Array ); // true
// alert( arr instanceof Object ); // true
// Пожалуйста, обратите внимание, что arr также принадлежит классу Object, потому что Array наследует от Object.
//
// Обычно оператор instanceof просматривает для проверки цепочку прототипов. Но это поведение может быть изменено при помощи статического метода Symbol.hasInstance.
//
// Алгоритм работы obj instanceof Class работает примерно так:
//
// Если имеется статический метод Symbol.hasInstance, тогда вызвать его: Class[Symbol.hasInstance](obj). Он должен вернуть либо true, либо false, и это конец. Это как раз и есть возможность ручной настройки instanceof.
//
// Пример:
//
// // проверка instanceof будет полагать,
// // что всё со свойством canEat - животное Animal
// class Animal {
//   static [Symbol.hasInstance](obj) {
//     if (obj.canEat) return true;
//   }
// }
//
// let obj = { canEat: true };
// alert(obj instanceof Animal); // true: вызван Animal[Symbol.hasInstance](obj)
// Большая часть классов не имеет метода Symbol.hasInstance. В этом случае используется стандартная логика: проверяется, равен ли Class.prototype одному из прототипов в прототипной цепочке obj.
//
// Другими словами, сравнивается:
//
// obj.__proto__ === Class.prototype?
// obj.__proto__.__proto__ === Class.prototype?
// obj.__proto__.__proto__.__proto__ === Class.prototype?
// ...
// // если какой-то из ответов true - возвратить true
// // если дошли до конца цепочки - false
// В примере выше rabbit.__proto__ === Rabbit.prototype, так что результат будет получен немедленно.
//
// В случае с наследованием, совпадение будет на втором шаге:
//
// class Animal {}
// class Rabbit extends Animal {}
//
// let rabbit = new Rabbit();
// alert(rabbit instanceof Animal); // true
//
// // rabbit.__proto__ === Animal.prototype (нет совпадения)
// // rabbit.__proto__.__proto__ === Animal.prototype (совпадение!)
// Вот иллюстрация того как rabbit instanceof Animal сравнивается с Animal.prototype:
//
//
// Кстати, есть метод objA.isPrototypeOf(objB), который возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB. Так что obj instanceof Class можно перефразировать как Class.prototype.isPrototypeOf(obj).
//
// Забавно, но сам конструктор Class не участвует в процессе проверки! Важна только цепочка прототипов Class.prototype.
//
// Это может приводить к интересным последствиям при изменении свойства prototype после создания объекта.
//
// Как, например, тут:
//
// function Rabbit() {}
// let rabbit = new Rabbit();
//
// // заменяем прототип
// Rabbit.prototype = {};
//
// // ...больше не rabbit!
// alert( rabbit instanceof Rabbit ); // false
// Бонус: Object.prototype.toString возвращает тип
// Мы уже знаем, что обычные объекты преобразуются к строке как [object Object]:
//
// let obj = {};
//
// alert(obj); // [object Object]
// alert(obj.toString()); // то же самое
// Так работает реализация метода toString. Но у toString имеются скрытые возможности, которые делают метод гораздо более мощным. Мы можем использовать его как расширенную версию typeof и как альтернативу instanceof.
//
// Звучит странно? Так и есть. Давайте развеем мистику.
//
// Согласно спецификации встроенный метод toString может быть позаимствован у объекта и вызван в контексте любого другого значения. И результат зависит от типа этого значения.
//
// Для числа это будет [object Number]
// Для булева типа это будет [object Boolean]
// Для null: [object Null]
// Для undefined: [object Undefined]
// Для массивов: [object Array]
// …и т.д. (поведение настраивается).
// Давайте продемонстрируем:
//
// // скопируем метод toString в переменную для удобства
// let objectToString = Object.prototype.toString;
//
// // какой это тип?
// let arr = [];
//
// alert( objectToString.call(arr) ); // [object Array]
// В примере мы использовали call, как описано в главе Декораторы и переадресация вызова, call/apply, чтобы выполнить функцию objectToString в контексте this=arr.
//
// Внутри, алгоритм метода toString анализирует контекст вызова this и возвращает соответствующий результат. Больше примеров:
//
// let s = Object.prototype.toString;
//
// alert( s.call(123) ); // [object Number]
// alert( s.call(null) ); // [object Null]
// alert( s.call(alert) ); // [object Function]
// Symbol.toStringTag
// Поведение метода объектов toString можно настраивать, используя специальное свойство объекта Symbol.toStringTag.
//
// Например:
//
// let user = {
//   [Symbol.toStringTag]: "User"
// };
//
// alert( {}.toString.call(user) ); // [object User]
// Такое свойство есть у большей части объектов, специфичных для определённых окружений. Вот несколько примеров для браузера:
//
// // toStringTag для браузерного объекта и класса
// alert( window[Symbol.toStringTag]); // window
// alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest
//
// alert( {}.toString.call(window) ); // [object Window]
// alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]
// Как вы можете видеть, результат – это значение Symbol.toStringTag (если он имеется) обёрнутое в [object ...].
//
// В итоге мы получили «typeof на стероидах», который не только работает с примитивными типами данных, но также и со встроенными объектами, и даже может быть настроен.
//
// Можно использовать {}.toString.call вместо instanceof для встроенных объектов, когда мы хотим получить тип в виде строки, а не просто сделать проверку.
//
// Итого
// Давайте обобщим, какие методы для проверки типа мы знаем:
//
// работает для	возвращает
// typeof	примитивов	строка
// {}.toString	примитивов, встроенных объектов, объектов с Symbol.toStringTag	строка
// instanceof	объектов	true/false
// Как мы можем видеть, технически {}.toString «более продвинут», чем typeof.
//
// А оператор instanceof – отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом наследования.











//Примеси
// В JavaScript можно наследовать только от одного объекта. Объект имеет единственный [[Prototype]]. И класс может расширить только один другой класс.
//
// Иногда это может ограничивать нас. Например, у нас есть класс StreetSweeper и класс Bicycle, а мы хотим создать их смесь: StreetSweepingBicycle.
//
// Или у нас есть класс User, который реализует пользователей, и класс EventEmitter, реализующий события. Мы хотели бы добавить функциональность класса EventEmitter к User, чтобы пользователи могли легко генерировать события.
//
// Для таких случаев существуют «примеси».
//
// По определению из Википедии, примесь – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.
//
// Другими словами, примесь определяет методы, которые реализуют определённое поведение. Мы не используем примесь саму по себе, а используем её, чтобы добавить функциональность другим классам.
//
// Пример примеси
// Простейший способ реализовать примесь в JavaScript – это создать объект с полезными методами, которые затем могут быть легко добавлены в прототип любого класса.
//
// В примере ниже примесь sayHiMixin имеет методы, которые придают объектам класса User возможность вести разговор:
//
// // примесь
// let sayHiMixin = {
//   sayHi() {
//     alert(`Привет, ${this.name}`);
//   },
//   sayBye() {
//     alert(`Пока, ${this.name}`);
//   }
// };
//
// // использование:
// class User {
//   constructor(name) {
//     this.name = name;
//   }
// }
//
// // копируем методы
// Object.assign(User.prototype, sayHiMixin);
//
// // теперь User может сказать Привет
// new User("Вася").sayHi(); // Привет, Вася!
// Это не наследование, а просто копирование методов. Таким образом, класс User может наследовать от другого класса, но при этом также включать в себя примеси, «подмешивающие» другие методы, например:
//
// class User extends Person {
// // ...
// }
//
// Object.assign(User.prototype, sayHiMixin);
// Примеси могут наследовать друг друга.
//
// В примере ниже sayHiMixin наследует от sayMixin:
//
// let sayMixin = {
//   say(phrase) {
//     alert(phrase);
//   }
// };
//
// let sayHiMixin = {
//   __proto__: sayMixin, // (или мы можем использовать Object.setPrototypeOf для задания прототипа)
//
//   sayHi() {
//     // вызываем метод родителя
//     super.say(`Привет, ${this.name}`); // (*)
//   },
//   sayBye() {
//     super.say(`Пока, ${this.name}`); // (*)
//   }
// };
//
// class User {
//   constructor(name) {
//     this.name = name;
//   }
// }
//
// // копируем методы
// Object.assign(User.prototype, sayHiMixin);
//
// // теперь User может сказать Привет
// new User("Вася").sayHi(); // Привет, Вася!
// Обратим внимание, что при вызове родительского метода super.say() из sayHiMixin (строки, помеченные (*)) этот метод ищется в прототипе самой примеси, а не класса.
//
// Вот диаграмма (см. правую часть):
//
//
// Это связано с тем, что методы sayHi и sayBye были изначально созданы в объекте sayHiMixin. Несмотря на то, что они скопированы, их внутреннее свойство [[HomeObject]] ссылается на sayHiMixin, как показано на картинке выше.
//
// Так как super ищет родительские методы в [[HomeObject]].[[Prototype]], это означает, что он ищет sayHiMixin.[[Prototype]].
//
// EventMixin
// Многие объекты в браузерной разработке (и не только) обладают важной способностью – они могут генерировать события. События – отличный способ передачи информации всем, кто в ней заинтересован. Давайте создадим примесь, которая позволит легко добавлять функциональность по работе с событиями любым классам/объектам.
//
// Примесь добавит метод .trigger(name, [...data]) для генерации события. Аргумент name – это имя события, за которым могут следовать дополнительные аргументы с данными для события.
// Также будет добавлен метод .on(name, handler), который назначает обработчик для события с заданным именем. Обработчик будет вызван, когда произойдёт событие с указанным именем name, и получит данные из .trigger.
// …и метод .off(name, handler), который удаляет обработчик указанного события.
// После того, как все методы примеси будут добавлены, объект user сможет сгенерировать событие "login" после входа пользователя в личный кабинет. А другой объект, к примеру, calendar сможет использовать это событие, чтобы показывать зашедшему пользователю актуальный для него календарь.
//
// Или menu может генерировать событие "select", когда элемент меню выбран, а другие объекты могут назначать обработчики, чтобы реагировать на это событие, и т.п.
//
// Вот код примеси:
//
// let eventMixin = {
//   /**
//    * Подписаться на событие, использование:
//    * menu.on('select', function(item) { ... }
//    */
//   on(eventName, handler) {
//     if (!this._eventHandlers) this._eventHandlers = {};
//     if (!this._eventHandlers[eventName]) {
//       this._eventHandlers[eventName] = [];
//     }
//     this._eventHandlers[eventName].push(handler);
//   },
//
//   /**
//    * Отменить подписку, использование:
//    * menu.off('select', handler)
//    */
//   off(eventName, handler) {
//     let handlers = this._eventHandlers?.[eventName];
//     if (!handlers) return;
//     for (let i = 0; i < handlers.length; i++) {
//       if (handlers[i] === handler) {
//         handlers.splice(i--, 1);
//       }
//     }
//   },
//
//   /**
//    * Сгенерировать событие с указанным именем и данными
//    * this.trigger('select', data1, data2);
//    */
//   trigger(eventName, ...args) {
//     if (!this._eventHandlers?.[eventName]) {
//       return; // обработчиков для этого события нет
//     }
//
//     // вызовем обработчики
//     this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
//   }
// };
// Итак, у нас есть 3 метода:
//
// .on(eventName, handler) – назначает функцию handler, чтобы обработать событие с заданным именем.
//
// Технически существует свойство _eventHandlers, в котором хранится массив обработчиков для каждого имени события, и оно просто добавляет это событие в список.
//
// .off(eventName, handler) – убирает функцию из списка обработчиков.
//
// .trigger(eventName, ...args) – генерирует событие: все назначенные обработчики из _eventHandlers[eventName] вызываются, и ...args передаются им в качестве аргументов.
//
// Использование:
//
// // Создадим класс
// class Menu {
//   choose(value) {
//     this.trigger("select", value);
//   }
// }
// // Добавим примесь с методами для событий
// Object.assign(Menu.prototype, eventMixin);
//
// let menu = new Menu();
//
// // Добавим обработчик, который будет вызван при событии "select":
// menu.on("select", value => alert(`Выбранное значение: ${value}`));
//
// // Генерирует событие => обработчик выше запускается и выводит:
// menu.choose("123"); // Выбранное значение: 123
// Теперь если у нас есть код, заинтересованный в событии "select", то он может слушать его с помощью menu.on(...).
//
// А eventMixin позволяет легко добавить такое поведение в любой класс без вмешательства в цепочку наследования.
//
// Итого
// Примесь – общий термин в объектно-ориентированном программировании: класс, который содержит в себе методы для других классов.
//
// Некоторые другие языки допускают множественное наследование. JavaScript не поддерживает множественное наследование, но с помощью примесей мы можем реализовать нечто похожее, скопировав методы в прототип.
//
// Мы можем использовать примеси для расширения функциональности классов, например, для обработки событий, как мы сделали это выше.
//
// С примесями могут возникнуть конфликты, если они перезаписывают существующие методы класса. Стоит помнить об этом и быть внимательнее при выборе имён для методов примеси, чтобы их избежать.





//Обработка ошибок, "try..catch"
// Неважно, насколько мы хороши в программировании, иногда наши скрипты содержат ошибки. Они могут возникать из-за наших промахов, неожиданного ввода пользователя, неправильного ответа сервера и по тысяче других причин.
//
// Обычно скрипт в случае ошибки «падает» (сразу же останавливается), с выводом ошибки в консоль.
//
// Но есть синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное.
//
// Синтаксис «try…catch»
// Конструкция try..catch состоит из двух основных блоков: try, и затем catch:
//
// try {
//
//   // код...
//
// } catch (err) {
//
//   // обработка ошибки
//
// }
// Работает она так:
//
// Сначала выполняется код внутри блока try {...}.
// Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
// Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
//
// Таким образом, при ошибке в блоке try {…} скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.
//
// Давайте рассмотрим примеры.
//
// Пример без ошибок: выведет alert (1) и (2):
//
// try {
//
//   alert('Начало блока try');  // (1) <--
//
//   // ...код без ошибок
//
//   alert('Конец блока try');   // (2) <--
//
// } catch(err) {
//
//   alert('Catch игнорируется, так как нет ошибок'); // (3)
//
// }
// Пример с ошибками: выведет (1) и (3):
//
// try {
//
//   alert('Начало блока try');  // (1) <--
//
//   lalala; // ошибка, переменная не определена!
//
//   alert('Конец блока try (никогда не выполнится)');  // (2)
//
// } catch(err) {
//
//   alert(`Возникла ошибка!`); // (3) <--
//
// }
// try..catch работает только для ошибок, возникающих во время выполнения кода
// Чтобы try..catch работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код.
//
// Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:
//
// try {
//   {{{{{{{{{{{{
// } catch(e) {
//   alert("Движок не может понять этот код, он некорректен");
// }
// JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.
//
// Таким образом, try..catch может обрабатывать только ошибки, которые возникают в корректном коде. Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».
//
// try..catch работает синхронно
// Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:
//
// try {
//   setTimeout(function() {
//     noSuchVariable; // скрипт упадёт тут
//   }, 1000);
// } catch (e) {
//   alert( "не сработает" );
// }
// Это потому, что функция выполняется позже, когда движок уже покинул конструкцию try..catch.
//
// Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:
//
// setTimeout(function() {
//   try {
//     noSuchVariable; // try..catch обрабатывает ошибку!
//   } catch {
//     alert( "ошибка поймана!" );
//   }
// }, 1000);
// Объект ошибки
// Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch:
//
// try {
//   // ...
// } catch(err) { // <-- объект ошибки, можно использовать другое название вместо err
//   // ...
// }
// Для всех встроенных ошибок этот объект имеет два основных свойства:
//
// name
// Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
// message
// Текстовое сообщение о деталях ошибки.
// В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:
//
// stack
// Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.
// Например:
//
// try {
//   lalala; // ошибка, переменная не определена!
// } catch(err) {
//   alert(err.name); // ReferenceError
//   alert(err.message); // lalala is not defined
//   alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)
//
//   // Можем также просто вывести ошибку целиком
//   // Ошибка приводится к строке вида "name: message"
//   alert(err); // ReferenceError: lalala is not defined
// }
// Блок «catch» без переменной
// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.
// Если нам не нужны детали ошибки, в catch можно её пропустить:
//
// try {
//   // ...
// } catch { //  <-- без (err)
//   // ...
// }
// Использование «try…catch»
// Давайте рассмотрим реальные случаи использования try..catch.
//
// Как мы уже знаем, JavaScript поддерживает метод JSON.parse(str) для чтения JSON.
//
// Обычно он используется для декодирования данных, полученных по сети, от сервера или из другого источника.
//
// Мы получаем их и вызываем JSON.parse вот так:
//
// let json = '{"name":"John", "age": 30}'; // данные с сервера
//
// let user = JSON.parse(json); // преобразовали текстовое представление в JS-объект
//
// // теперь user - объект со свойствами из строки
// alert( user.name ); // John
// alert( user.age );  // 30
// Вы можете найти более детальную информацию о JSON в главе Формат JSON, метод toJSON.
//
// Если json некорректен, JSON.parse генерирует ошибку, то есть скрипт «падает».
//
// Устроит ли нас такое поведение? Конечно нет!
//
// Получается, что если вдруг что-то не так с данными, то посетитель никогда (если, конечно, не откроет консоль) об этом не узнает. А люди очень не любят, когда что-то «просто падает» без всякого сообщения об ошибке.
//
// Давайте используем try..catch для обработки ошибки:
//
// let json = "{ некорректный JSON }";
//
// try {
//
//   let user = JSON.parse(json); // <-- тут возникает ошибка...
//   alert( user.name ); // не сработает
//
// } catch (e) {
//   // ...выполнение прыгает сюда
//   alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
//   alert( e.name );
//   alert( e.message );
// }
// Здесь мы используем блок catch только для вывода сообщения, но мы также можем сделать гораздо больше: отправить новый сетевой запрос, предложить посетителю альтернативный способ, отослать информацию об ошибке на сервер для логирования, … Всё лучше, чем просто «падение».
//
// Генерация собственных ошибок
// Что если json синтаксически корректен, но не содержит необходимого свойства name?
//
// Например, так:
//
// let json = '{ "age": 30 }'; // данные неполны
//
// try {
//
//   let user = JSON.parse(json); // <-- выполнится без ошибок
//   alert( user.name ); // нет свойства name!
//
// } catch (e) {
//   alert( "не выполнится" );
// }
// Здесь JSON.parse выполнится без ошибок, но на самом деле отсутствие свойства name для нас ошибка.
//
// Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором throw.
//
// Оператор «throw»
// Оператор throw генерирует ошибку.
//
// Синтаксис:
//
// throw <объект ошибки>
// Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).
//
// В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.
//
// Их синтаксис:
//
// let error = new Error(message);
// // или
// let error = new SyntaxError(message);
// let error = new ReferenceError(message);
// // ...
// Для встроенных ошибок (не для любых объектов, только для ошибок), свойство name – это в точности имя конструктора. А свойство message берётся из аргумента.
//
// Например:
//
// let error = new Error("Ого, ошибка! o_O");
//
// alert(error.name); // Error
// alert(error.message); // Ого, ошибка! o_O
// Давайте посмотрим, какую ошибку генерирует JSON.parse:
//
// try {
//   JSON.parse("{ некорректный json o_O }");
// } catch(e) {
//   alert(e.name); // SyntaxError
//   alert(e.message); // Expected property name or '}' in JSON at position 2 (line 1 column 3)
// }
// Как мы видим, это SyntaxError.
//
// В нашем случае отсутствие свойства name – это ошибка, ведь пользователи должны иметь имена.
//
// Сгенерируем её:
//
// let json = '{ "age": 30 }'; // данные неполны
//
// try {
//
//   let user = JSON.parse(json); // <-- выполнится без ошибок
//
//   if (!user.name) {
//     throw new SyntaxError("Данные неполны: нет имени"); // (*)
//   }
//
//   alert( user.name );
//
// } catch(e) {
//   alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
// }
// В строке (*) оператор throw генерирует ошибку SyntaxError с сообщением message. Точно такого же вида, как генерирует сам JavaScript. Выполнение блока try немедленно останавливается, и поток управления прыгает в catch.
//
// Теперь блок catch становится единственным местом для обработки всех ошибок: и для JSON.parse и для других случаев.
//
// Проброс исключения
// В примере выше мы использовали try..catch для обработки некорректных данных. А что, если в блоке try {...} возникнет другая неожиданная ошибка? Например, программная (неопределённая переменная) или какая-то ещё, а не ошибка, связанная с некорректными данными.
//
// Пример:
//
// let json = '{ "age": 30 }'; // данные неполны
//
// try {
//   user = JSON.parse(json); // <-- забыл добавить "let" перед user
//
//   // ...
// } catch(err) {
//   alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined
//   // (не JSON ошибка на самом деле)
// }
// Конечно, возможно все! Программисты совершают ошибки. Даже в утилитах с открытым исходным кодом, используемых миллионами людей на протяжении десятилетий – вдруг может быть обнаружена ошибка, которая приводит к ужасным взломам.
//
// В нашем случае try..catch предназначен для выявления ошибок, связанных с некорректными данными. Но по своей природе catch получает все свои ошибки из try. Здесь он получает неожиданную ошибку, но всё также показывает то же самое сообщение "JSON Error". Это неправильно и затрудняет отладку кода.
//
// К счастью, мы можем выяснить, какую ошибку мы получили, например, по её свойству name:
//
// try {
//   user = { /*...*/ };
// } catch(e) {
//   alert(e.name); // "ReferenceError" из-за неопределённой переменной
// }
// Есть простое правило:
//
// Блок catch должен обрабатывать только те ошибки, которые ему известны, и «пробрасывать» все остальные.
//
// Техника «проброс исключения» выглядит так:
//
// Блок catch получает все ошибки.
// В блоке catch(err) {...} мы анализируем объект ошибки err.
// Если мы не знаем как её обработать, тогда делаем throw err.
// В коде ниже мы используем проброс исключения, catch обрабатывает только SyntaxError:
//
// let json = '{ "age": 30 }'; // данные неполны
// try {
//
//   let user = JSON.parse(json);
//
//   if (!user.name) {
//     throw new SyntaxError("Данные неполны: нет имени");
//   }
//
//   blabla(); // неожиданная ошибка
//
//   alert( user.name );
//
// } catch(e) {
//
//   if (e.name == "SyntaxError") {
//     alert( "JSON Error: " + e.message );
//   } else {
//     throw e; // проброс (*)
//   }
//
// }
// Ошибка в строке (*) из блока catch «выпадает наружу» и может быть поймана другой внешней конструкцией try..catch (если есть), или «убьёт» скрипт.
//
// Таким образом, блок catch фактически обрабатывает только те ошибки, с которыми он знает, как справляться, и пропускает остальные.
//
// Пример ниже демонстрирует, как такие ошибки могут быть пойманы с помощью ещё одного уровня try..catch:
//
// function readData() {
//   let json = '{ "age": 30 }';
//
//   try {
//     // ...
//     blabla(); // ошибка!
//   } catch (e) {
//     // ...
//     if (e.name != 'SyntaxError') {
//       throw e; // проброс исключения (не знаю как это обработать)
//     }
//   }
// }
//
// try {
//   readData();
// } catch (e) {
//   alert( "Внешний catch поймал: " + e ); // поймал!
// }
// Здесь readData знает только, как обработать SyntaxError, тогда как внешний блок try..catch знает, как обработать всё.
//
// try…catch…finally
// Подождите, это ещё не всё.
//
// Конструкция try..catch может содержать ещё одну секцию: finally.
//
// Если секция есть, то она выполняется в любом случае:
//
// после try, если не было ошибок,
// после catch, если ошибки были.
// Расширенный синтаксис выглядит следующим образом:
//
// try {
//    ... пробуем выполнить код...
// } catch(e) {
//    ... обрабатываем ошибки ...
// } finally {
//    ... выполняем всегда ...
// }
// Попробуйте запустить такой код:
//
// try {
//   alert( 'try' );
//   if (confirm('Сгенерировать ошибку?')) BAD_CODE();
// } catch (e) {
//   alert( 'catch' );
// } finally {
//   alert( 'finally' );
// }
// У кода есть два пути выполнения:
//
// Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try -> catch -> finally.
// Если ответите отрицательно, то try -> finally.
// Секцию finally часто используют, когда мы начали что-то делать и хотим завершить это вне зависимости от того, будет ошибка или нет.
//
// Например, мы хотим измерить время, которое занимает функция чисел Фибоначчи fib(n). Естественно, мы можем начать измерения до того, как функция начнёт выполняться и закончить после. Но что делать, если при вызове функции возникла ошибка? В частности, реализация fib(n) в коде ниже возвращает ошибку для отрицательных и для нецелых чисел.
//
// Секция finally отлично подходит для завершения измерений несмотря ни на что.
//
// Здесь finally гарантирует, что время будет измерено корректно в обеих ситуациях – и в случае успешного завершения fib и в случае ошибки:
//
// let num = +prompt("Введите положительное целое число?", 35)
//
// let diff, result;
//
// function fib(n) {
//   if (n < 0 || Math.trunc(n) != n) {
//     throw new Error("Должно быть целое неотрицательное число");
//   }
//   return n <= 1 ? n : fib(n - 1) + fib(n - 2);
// }
//
// let start = Date.now();
//
// try {
//   result = fib(num);
// } catch (e) {
//   result = 0;
// } finally {
//   diff = Date.now() - start;
// }
//
// alert(result || "возникла ошибка");
//
// alert( `Выполнение заняло ${diff}ms` );
// Вы можете это проверить, запустив этот код и введя 35 в prompt – код завершится нормально, finally выполнится после try. А затем введите -1 – незамедлительно произойдёт ошибка, выполнение займёт 0ms. Оба измерения выполняются корректно.
//
// Другими словами, неважно как завершилась функция: через return или throw. Секция finally срабатывает в обоих случаях.
//
// Переменные внутри try..catch..finally локальны
// Обратите внимание, что переменные result и diff в коде выше объявлены до try..catch.
//
// Если переменную объявить в блоке, например, в try, то она не будет доступна после него.
//
// finally и return
// Блок finally срабатывает при любом выходе из try..catch, в том числе и return.
//
// В примере ниже из try происходит return, но finally получает управление до того, как контроль возвращается во внешний код.
//
// function func() {
//
//   try {
//     return 1;
//
//   } catch (e) {
//     /* ... */
//   } finally {
//     alert( 'finally' );
//   }
// }
//
// alert( func() ); // сначала срабатывает alert из finally, а затем этот код
// try..finally
// Конструкция try..finally без секции catch также полезна. Мы применяем её, когда не хотим здесь обрабатывать ошибки (пусть выпадут), но хотим быть уверены, что начатые процессы завершились.
//
// function func() {
//   // начать делать что-то, что требует завершения (например, измерения)
//   try {
//     // ...
//   } finally {
//     // завершить это, даже если все упадёт
//   }
// }
// В приведённом выше коде ошибка всегда выпадает наружу, потому что тут нет блока catch. Но finally отрабатывает до того, как поток управления выйдет из функции.
//
// Глобальный catch
// Зависит от окружения
// Информация из данной секции не является частью языка JavaScript.
//
// Давайте представим, что произошла фатальная ошибка (программная или что-то ещё ужасное) снаружи try..catch, и скрипт упал.
//
// Существует ли способ отреагировать на такие ситуации? Мы можем захотеть залогировать ошибку, показать что-то пользователю (обычно они не видят сообщение об ошибке) и т.д.
//
// Такого способа нет в спецификации, но обычно окружения предоставляют его, потому что это весьма полезно. Например, в Node.js для этого есть process.on("uncaughtException"). А в браузере мы можем присвоить функцию специальному свойству window.onerror, которая будет вызвана в случае необработанной ошибки.
//
// Синтаксис:
//
// window.onerror = function(message, url, line, col, error) {
//   // ...
// };
// message
// Сообщение об ошибке.
// url
// URL скрипта, в котором произошла ошибка.
// line, col
// Номера строки и столбца, в которых произошла ошибка.
// error
// Объект ошибки.
// Пример:
//
// <script>
//   window.onerror = function(message, url, line, col, error) {
//     alert(`${message}\n В ${line}:${col} на ${url}`);
//   };
//
//   function readData() {
//     badFunc(); // Ой, что-то пошло не так!
//   }
//
//   readData();
// </script>
// Роль глобального обработчика window.onerror обычно заключается не в восстановлении выполнения скрипта – это скорее всего невозможно в случае программной ошибки, а в отправке сообщения об ошибке разработчикам.
//
// Существуют также веб-сервисы, которые предоставляют логирование ошибок для таких случаев, такие как https://errorception.com или http://www.muscula.com.
//
// Они работают так:
//
// Мы регистрируемся в сервисе и получаем небольшой JS-скрипт (или URL скрипта) от них для вставки на страницы.
// Этот JS-скрипт ставит свою функцию window.onerror.
// Когда возникает ошибка, она выполняется и отправляет сетевой запрос с информацией о ней в сервис.
// Мы можем войти в веб-интерфейс сервиса и увидеть ошибки.
// Итого
// Конструкция try..catch позволяет обрабатывать ошибки во время исполнения кода. Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.
//
// Синтаксис:
//
// try {
//   // исполняем код
// } catch(err) {
//   // если случилась ошибка, прыгаем сюда
//   // err - это объект ошибки
// } finally {
//   // выполняется всегда после try/catch
// }
// Секций catch или finally может не быть, то есть более короткие конструкции try..catch и try..finally также корректны.
//
// Объекты ошибок содержат следующие свойства:
//
// message – понятное человеку сообщение.
// name – строка с именем ошибки (имя конструктора ошибки).
// stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.
// Если объект ошибки не нужен, мы можем пропустить его, используя catch { вместо catch(err) {.
//
// Мы можем также генерировать собственные ошибки, используя оператор throw. Аргументом throw может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса Error. Подробнее о расширении ошибок см. в следующей главе.
//
// Проброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.
//
// Даже если у нас нет try..catch, большинство сред позволяют настроить «глобальный» обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.







//Пользовательские ошибки, расширение Error
// Когда что-то разрабатываем, то нам часто необходимы собственные классы ошибок для разных вещей, которые могут пойти не так в наших задачах. Для ошибок при работе с сетью может понадобиться HttpError, для операций с базой данных DbError, для поиска – NotFoundError и т.д.
//
// Наши ошибки должны поддерживать базовые свойства, такие как message, name и, желательно, stack. Но также они могут иметь свои собственные свойства. Например, объекты HttpError могут иметь свойство statusCode со значениями 404, 403 или 500.
//
// JavaScript позволяет вызывать throw с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от Error. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством obj instanceof Error. Так что лучше применять наследование.
//
// По мере роста приложения, наши собственные ошибки образуют иерархию, например, HttpTimeoutError может наследовать от HttpError и так далее.
//
// Расширение Error
// В качестве примера рассмотрим функцию readUser(json), которая должна читать данные пользователя в формате JSON.
//
// Пример того, как может выглядеть корректный json:
//
// let json = `{ "name": "John", "age": 30 }`;
// Внутри будем использовать JSON.parse. При получении некорректного json он будет генерировать ошибку SyntaxError. Но даже если json синтаксически верен, то это не значит, что это будет корректный пользователь, верно? Могут быть пропущены необходимые данные. Например, могут отсутствовать свойства nameи age, которые являются необходимыми для наших пользователей.
//
// Наша функция readUser(json) будет не только читать JSON-данные, но и проверять их («валидировать»). Если необходимые поля отсутствуют или данные в неверном формате, то это будет ошибкой. Но не синтаксической ошибкой SyntaxError, потому что данные синтаксически корректны. Это будет другая ошибка.
//
// Назовём её ошибкой валидации ValidationError и создадим для неё класс. Ошибка этого вида должна содержать информацию о поле, которое является источником ошибки.
//
// Наш класс ValidationError должен наследовать от встроенного класса Error.
//
// Класс Error встроенный, вот его примерный код, просто чтобы мы понимали, что расширяем:
//
// // "Псевдокод" встроенного класса Error, определённого самим JavaScript
// class Error {
//   constructor(message) {
//     this.message = message;
//     this.name = "Error"; // (разные имена для разных встроенных классов ошибок)
//     this.stack = <стек вызовов>; // нестандартное свойство, но обычно поддерживается
//   }
// }
// Теперь давайте унаследуем от него ValidationError и попробуем новый класс в действии:
//
// class ValidationError extends Error {
//   constructor(message) {
//     super(message); // (1)
//     this.name = "ValidationError"; // (2)
//   }
// }
//
// function test() {
//   throw new ValidationError("Упс!");
// }
//
// try {
//   test();
// } catch(err) {
//   alert(err.message); // Упс!
//   alert(err.name); // ValidationError
//   alert(err.stack); // список вложенных вызовов с номерами строк для каждого
// }
// Обратите внимание: в строке (1) вызываем родительский конструктор. JavaScript требует от нас вызова super в дочернем конструкторе, так что это обязательно. Родительский конструктор устанавливает свойство message.
//
// Родительский конструктор также устанавливает свойство name для "Error", поэтому в строке (2) мы сбрасываем его на правильное значение.
//
// Попробуем использовать его в readUser(json):
//
// class ValidationError extends Error {
//   constructor(message) {
//     super(message);
//     this.name = "ValidationError";
//   }
// }
//
// // Использование
// function readUser(json) {
//   let user = JSON.parse(json);
//
//   if (!user.age) {
//     throw new ValidationError("Нет поля: age");
//   }
//   if (!user.name) {
//     throw new ValidationError("Нет поля: name");
//   }
//
//   return user;
// }
//
// // Рабочий пример с try..catch
//
// try {
//   let user = readUser('{ "age": 25 }');
// } catch (err) {
//   if (err instanceof ValidationError) {
//     alert("Некорректные данные: " + err.message); // Некорректные данные: Нет поля: name
//   } else if (err instanceof SyntaxError) { // (*)
//     alert("JSON Ошибка Синтаксиса: " + err.message);
//   } else {
//     throw err; // неизвестная ошибка, пробросить исключение (**)
//   }
// }
// Блок try..catch в коде выше обрабатывает и нашу ValidationError, и встроенную SyntaxError из JSON.parse.
//
// Обратите внимание, как мы используем instanceof для проверки конкретного типа ошибки в строке (*).
//
// Мы можем также проверить тип, используя err.name:
//
// // ...
// // вместо (err instanceof SyntaxError)
// } else if (err.name == "SyntaxError") { // (*)
// // ...
// Версия с instanceof гораздо лучше, потому что в будущем мы собираемся расширить ValidationError, сделав его подтипы, такие как PropertyRequiredError. И проверка instanceof продолжит работать для новых наследованных классов. Так что это на будущее.
//
// Также важно, что если catch встречает неизвестную ошибку, то он пробрасывает её в строке (**). Блокcatch знает, только как обрабатывать ошибки валидации и синтаксические ошибки, а другие виды ошибок (из-за опечаток в коде и другие непонятные) он должен выпустить наружу.
//
// Дальнейшее наследование
// Класс ValidationError является слишком общим. Много что может пойти не так. Свойство может отсутствовать или иметь неверный формат (например, строка как значение возраста age). Поэтому для отсутствующих свойств сделаем более конкретный класс PropertyRequiredError. Он будет нести дополнительную информацию о свойстве, которое отсутствует.
//
// class ValidationError extends Error {
//   constructor(message) {
//     super(message);
//     this.name = "ValidationError";
//   }
// }
//
// class PropertyRequiredError extends ValidationError {
//   constructor(property) {
//     super("Нет свойства: " + property);
//     this.name = "PropertyRequiredError";
//     this.property = property;
//   }
// }
//
// // Применение
// function readUser(json) {
//   let user = JSON.parse(json);
//
//   if (!user.age) {
//     throw new PropertyRequiredError("age");
//   }
//   if (!user.name) {
//     throw new PropertyRequiredError("name");
//   }
//
//   return user;
// }
//
// // Рабочий пример с try..catch
//
// try {
//   let user = readUser('{ "age": 25 }');
// } catch (err) {
//   if (err instanceof ValidationError) {
//     alert("Неверные данные: " + err.message); // Неверные данные: Нет свойства: name
//     alert(err.name); // PropertyRequiredError
//     alert(err.property); // name
//   } else if (err instanceof SyntaxError) {
//     alert("Ошибка синтаксиса JSON: " + err.message);
//   } else {
//     throw err; // неизвестная ошибка, повторно выбросит исключение
//   }
// }
// Новый класс PropertyRequiredError очень просто использовать: необходимо указать только имя свойства new PropertyRequiredError(property). Сообщение для пользователя message генерируется конструктором.
//
// Обратите внимание, что свойство this.name в конструкторе PropertyRequiredError снова присвоено вручную. Правда, немного утомительно – присваивать this.name = <class name> в каждом классе пользовательской ошибки. Можно этого избежать, если сделать наш собственный «базовый» класс ошибки, который будет ставить this.name = this.constructor.name. И затем наследовать все ошибки уже от него.
//
// Давайте назовём его MyError.
//
// Вот упрощённый код с MyError и другими пользовательскими классами ошибок:
//
// class MyError extends Error {
//   constructor(message) {
//     super(message);
//     this.name = this.constructor.name;
//   }
// }
//
// class ValidationError extends MyError { }
//
// class PropertyRequiredError extends ValidationError {
//   constructor(property) {
//     super("Нет свойства: " + property);
//     this.property = property;
//   }
// }
//
// // name корректное
// alert( new PropertyRequiredError("field").name ); // PropertyRequiredError
// Теперь пользовательские ошибки стали намного короче, особенно ValidationError, так как мы избавились от строки "this.name = ..." в конструкторе.
//
// Обёртывание исключений
// Назначение функции readUser в приведённом выше коде – это «чтение данных пользователя». В процессе могут возникнуть различные виды ошибок. Сейчас у нас есть SyntaxError и ValidationError, но в будущем функция readUser может расшириться и, возможно, генерировать другие виды ошибок.
//
// Код, который вызывает readUser, должен обрабатывать эти ошибки.
//
// Сейчас в нём используются проверки if в блоке catch, которые проверяют класс и обрабатывают известные ошибки и пробрасывают дальше неизвестные. Но если функция readUser генерирует несколько видов ошибок, то мы должны спросить себя: действительно ли мы хотим проверять все типы ошибок поодиночке во всех местах в коде, где вызывается readUser?
//
// Часто ответ «Нет»: внешний код хочет быть на один уровень выше всего этого. Он хочет иметь какую-то обобщённую ошибку чтения данных. Почему именно это произошло – часто не имеет значения (об этом говорится в сообщении об ошибке). Или даже лучше, если есть способ получить подробности об ошибке, но только если нам это нужно.
//
// Итак, давайте создадим новый класс ReadError для представления таких ошибок. Если ошибка возникает внутри readUser, мы её перехватим и сгенерируем ReadError. Мы также сохраним ссылку на исходную ошибку в свойстве cause. Тогда внешний код должен будет только проверить наличие ReadError.
//
// Этот код определяет ошибку ReadError и демонстрирует её использование в readUserи try..catch:
//
// class ReadError extends Error {
//   constructor(message, cause) {
//     super(message);
//     this.cause = cause;
//     this.name = 'ReadError';
//   }
// }
//
// class ValidationError extends Error { /*...*/ }
// class PropertyRequiredError extends ValidationError { /* ... */ }
//
// function validateUser(user) {
//   if (!user.age) {
//     throw new PropertyRequiredError("age");
//   }
//
//   if (!user.name) {
//     throw new PropertyRequiredError("name");
//   }
// }
//
// function readUser(json) {
//   let user;
//
//   try {
//     user = JSON.parse(json);
//   } catch (err) {
//     if (err instanceof SyntaxError) {
//       throw new ReadError("Синтаксическая ошибка", err);
//     } else {
//       throw err;
//     }
//   }
//
//   try {
//     validateUser(user);
//   } catch (err) {
//     if (err instanceof ValidationError) {
//       throw new ReadError("Ошибка валидации", err);
//     } else {
//       throw err;
//     }
//   }
//
// }
//
// try {
//   readUser('{bad json}');
// } catch (e) {
//   if (e instanceof ReadError) {
//     alert(e);
//     // Исходная ошибка: SyntaxError:Unexpected token b in JSON at position 1
//     alert("Исходная ошибка: " + e.cause);
//   } else {
//     throw e;
//   }
// }
// В приведённом выше коде readUser работает так, как описано – функция распознаёт синтаксические ошибки и ошибки валидации и выдаёт вместо них ошибки ReadError (неизвестные ошибки, как обычно, пробрасываются).
//
// Внешний код проверяет только instanceof ReadError. Не нужно перечислять все возможные типы ошибок
//
// Этот подход называется «обёртывание исключений», потому что мы берём «исключения низкого уровня» и «оборачиваем» их в ReadError, который является более абстрактным и более удобным для использования в вызывающем коде. Такой подход широко используется в объектно-ориентированном программировании.
//
// Итого
// Мы можем наследовать свои классы ошибок от Error и других встроенных классов ошибок, но нужно позаботиться о свойстве name и не забыть вызвать super.
// Мы можем использовать instanceof для проверки типа ошибок. Это также работает с наследованием. Но иногда у нас объект ошибки, возникшей в сторонней библиотеке, и нет простого способа получить класс. Тогда для проверки типа ошибки можно использовать свойство name.
// Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как err.cause в примерах выше, но это не обязательно.
// Задачи








//Промисы, async/await
// 9 августа 2023 г.
// Введение: колбэки
// В примерах мы будем использовать браузерные методы
// Для демонстрации использования колбэков, промисов и других абстрактных понятий мы будем использовать некоторые браузерные методы: в частности, загрузку скриптов и выполнение простых манипуляций с документом.
//
// Если вы не знакомы с этими методами, и их использование в примерах вызывает у вас недоумение, возможно, вам стоит прочитать несколько глав из следующей части учебника.
//
// Тем не менее, мы все равно попытаемся максимально доходчиво всё разъяснить. Ничего особо сложного в плане браузера не будет.
//
// Многие действия в JavaScript асинхронные.
//
// Например, рассмотрим функцию loadScript(src):
//
// function loadScript(src) {
//   let script = document.createElement('script');
//   script.src = src;
//   document.head.append(script);
// }
// Эта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция <script src="…">, браузер загрузит скрипт и выполнит его.
//
// Вот пример использования этой функции:
//
// // загрузит и выполнит скрипт
// loadScript('/my/script.js');
// Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.
//
// Если после вызова loadScript(…) есть какой-то код, то он не будет ждать, пока скрипт загрузится.
//
// loadScript('/my/script.js');
// // код, написанный после вызова функции loadScript,
// // не будет дожидаться полной загрузки скрипта
// // ...
// Мы хотели бы использовать новый скрипт, как только он будет загружен. Скажем, он объявляет новую функцию, которую мы хотим выполнить.
//
// Но если мы просто вызовем эту функцию после loadScript(…), у нас ничего не выйдет:
//
// loadScript('/my/script.js'); // в скрипте есть "function newFunction() {…}"
//
// newFunction(); // такой функции не существует!
// Действительно, ведь у браузера не было времени загрузить скрипт. Сейчас функция loadScript никак не позволяет отследить момент загрузки. Скрипт загружается, а потом выполняется. Но нам нужно точно знать, когда это произойдёт, чтобы использовать функции и переменные из этого скрипта.
//
// Давайте передадим функцию callback вторым аргументом в loadScript, чтобы вызвать её, когда скрипт загрузится:
//
// function loadScript(src, callback) {
//   let script = document.createElement('script');
//   script.src = src;
//   script.onload = () => callback(script);
//   document.head.append(script);
// }
// Событие onload описано в статье Загрузка ресурсов: onload и onerror, оно в основном выполняет функцию после загрузки и выполнения скрипта.
//
// Теперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:
//
// loadScript('/my/script.js', function() {
//   // эта функция вызовется после того, как загрузится скрипт
//   newFunction(); // теперь всё работает
//   ...
// });
// Смысл такой: вторым аргументом передаётся функция (обычно анонимная), которая выполняется по завершении действия.
//
// Возьмём для примера реальный скрипт с библиотекой функций:
//
// function loadScript(src, callback) {
//   let script = document.createElement('script');
//   script.src = src;
//   script.onload = () => callback(script);
//   document.head.append(script);
// }
//
// loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
//   alert(`Здорово, скрипт ${script.src} загрузился`);
//   alert( _ ); // функция, объявленная в загруженном скрипте
// });
// Такое написание называют асинхронным программированием с использованием колбэков. В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия.
//
// Мы поступили похожим образом в loadScript, но это, конечно, распространённый подход.
//
// Колбэк в колбэке
// Как нам загрузить два скрипта один за другим: сначала первый, а за ним второй?
//
// Первое, что приходит в голову, вызвать loadScript ещё раз уже внутри колбэка, вот так:
//
// loadScript('/my/script.js', function(script) {
//
//   alert(`Здорово, скрипт ${script.src} загрузился, загрузим ещё один`);
//
//   loadScript('/my/script2.js', function(script) {
//     alert(`Здорово, второй скрипт загрузился`);
//   });
//
// });
// Когда внешняя функция loadScript выполнится, вызовется та, что внутри колбэка.
//
// А что если нам нужно загрузить ещё один скрипт?..
//
// loadScript('/my/script.js', function(script) {
//
//   loadScript('/my/script2.js', function(script) {
//
//     loadScript('/my/script3.js', function(script) {
//       // ...и так далее, пока все скрипты не будут загружены
//     });
//
//   })
//
// });
// Каждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдёт, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.
//
// Перехват ошибок
// В примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось? Колбэк должен уметь реагировать на возможные проблемы.
//
// Ниже улучшенная версия loadScript, которая умеет отслеживать ошибки загрузки:
//
// function loadScript(src, callback) {
//   let script = document.createElement('script');
//   script.src = src;
//
//   script.onload = () => callback(null, script);
//   script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));
//
//   document.head.append(script);
// }
// Мы вызываем callback(null, script) в случае успешной загрузки и callback(error), если загрузить скрипт не удалось.
//
// Живой пример:
//
// loadScript('/my/script.js', function(error, script) {
//   if (error) {
//     // обрабатываем ошибку
//   } else {
//     // скрипт успешно загружен
//   }
// });
// Опять же, подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).
//
// Правила таковы:
//
// Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
// Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
// Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.
//
// Адская пирамида вызовов
// На первый взгляд это рабочий способ написания асинхронного кода. Так и есть. Для одного или двух вложенных вызовов всё выглядит нормально.
//
// Но для нескольких асинхронных действий, которые нужно выполнить друг за другом, код выглядит вот так:
//
// loadScript('1.js', function(error, script) {
//
//   if (error) {
//     handleError(error);
//   } else {
//     // ...
//     loadScript('2.js', function(error, script) {
//       if (error) {
//         handleError(error);
//       } else {
//         // ...
//         loadScript('3.js', function(error, script) {
//           if (error) {
//             handleError(error);
//           } else {
//             // ...и так далее, пока все скрипты не будут загружены (*)
//           }
//         });
//
//       }
//     })
//   }
// });
// В примере выше:
//
// Мы загружаем 1.js. Продолжаем, если нет ошибок.
// Мы загружаем 2.js. Продолжаем, если нет ошибок.
// Мы загружаем 3.js. Продолжаем, если нет ошибок. И так далее (*).
// Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо ... у нас код, содержащий другие цепочки вызовов, условия и т.д.
//
// Иногда это называют «адом колбэков» или «адской пирамидой колбэков».
//
//
// Пирамида вложенных вызовов растёт вправо с каждым асинхронным действием. В итоге вы сами будете путаться, где что есть.
//
// Такой подход к написанию кода не приветствуется.
//
// Мы можем попытаться решить эту проблему, изолируя каждое действие в отдельную функцию, вот так:
//
// loadScript('1.js', step1);
//
// function step1(error, script) {
//   if (error) {
//     handleError(error);
//   } else {
//     // ...
//     loadScript('2.js', step2);
//   }
// }
//
// function step2(error, script) {
//   if (error) {
//     handleError(error);
//   } else {
//     // ...
//     loadScript('3.js', step3);
//   }
// }
//
// function step3(error, script) {
//   if (error) {
//     handleError(error);
//   } else {
//     // ...и так далее, пока все скрипты не будут загружены (*)
//   }
// };
// Заметили? Этот код делает всё то же самое, но вложенность отсутствует, потому что все действия вынесены в отдельные функции.
//
// Код абсолютно рабочий, но кажется разорванным на куски. Его трудно читать, вы наверняка заметили это. Приходится прыгать глазами между кусками кода, когда пытаешься его прочесть. Это неудобно, особенно, если читатель не знаком с кодом и не знает, что за чем следует.
//
// Кроме того, все функции step* одноразовые, и созданы лишь только, чтобы избавиться от «адской пирамиды вызовов». Никто не будет их переиспользовать где-либо ещё. Таким образом, мы, кроме всего прочего, засоряем пространство имён.
//
// Нужно найти способ получше.
//
// К счастью, такие способы существуют. Один из лучших — использовать промисы, о которых рассказано в следующей главе.












//Промисы
// Представьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем сингле.
//
// Чтобы получить передышку, вы обещаете разослать им сингл, когда он будет выпущен. Вы даёте фанатам список, в который они могут записаться. Они могут оставить там свой e-mail, чтобы получить песню, как только она выйдет. И даже больше: если что-то пойдёт не так, например, в студии будет пожар и песню выпустить не выйдет, они также получат уведомление об этом.
//
// Все счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты больше не беспокоятся, что пропустят новый сингл.
//
// Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:
//
// Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. В нашей аналогии это – «певец».
// Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
// Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
// Аналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее простого списка подписок: он обладает дополнительными возможностями и ограничениями. Но для начала и такая аналогия хороша.
//
// Синтаксис создания Promise:
//
// let promise = new Promise(function(resolve, reject) {
//   // функция-исполнитель (executor)
//   // "певец"
// });
// Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».
//
// Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.
//
// Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
//
// resolve(value) — если работа завершилась успешно, с результатом value.
// reject(error) — если произошла ошибка, error – объект ошибки.
// Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.
//
// У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
//
// state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
// result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
// Так что исполнитель по итогу переводит promise в одно из двух состояний:
//
//
// Позже мы рассмотрим, как «фанаты» узнают об этих изменениях.
//
// Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):
//
// let promise = new Promise(function(resolve, reject) {
//   // эта функция выполнится автоматически, при вызове new Promise
//
//   // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
//   setTimeout(() => resolve("done"), 1000);
// });
// Мы можем наблюдать две вещи, запустив код выше:
//
// Функция-исполнитель запускается сразу же при вызове new Promise.
// Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.
// Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат:
//
//
// Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
//
// А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
//
// let promise = new Promise(function(resolve, reject) {
//   // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
//   setTimeout(() => reject(new Error("Whoops!")), 1000);
// });
//
// Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.
//
// Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».
//
// Может быть что-то одно: либо результат, либо ошибка
// Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
//
// Все последующие вызовы resolve и reject будут проигнорированы:
//
// let promise = new Promise(function(resolve, reject) {
//   resolve("done");
//
//   reject(new Error("…")); // игнорируется
//   setTimeout(() => resolve("…")); // игнорируется
// });
// Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.
//
// Также заметим, что функция resolve/reject ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.
//
// Вызывайте reject с объектом Error
// В случае, если что-то пошло не так, мы должны вызвать reject. Это можно сделать с аргументом любого типа (как и resolve), но рекомендуется использовать объект Error (или унаследованный от него). Почему так? Скоро нам станет понятно.
//
// Вызов resolve/reject сразу
// Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть через какое-то время. Но это не обязательно, resolve или reject могут быть вызваны сразу:
//
// let promise = new Promise(function(resolve, reject) {
//   // задача, не требующая времени
//   resolve(123); // мгновенно выдаст результат: 123
// });
// Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.
//
// Такая ситуация нормальна. Мы сразу получим успешно завершённый Promise.
//
// Свойства state и result – внутренние
// Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally, про них речь пойдёт дальше.
//
// Потребители: then, catch
// Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.
//
// then
// Наиболее важный и фундаментальный метод – .then.
//
// Синтаксис:
//
// promise.then(
//   function(result) { /* обработает успешное выполнение */ },
//   function(error) { /* обработает ошибку */ }
// );
// Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
//
// Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
//
// Например, вот реакция на успешно выполненный промис:
//
// let promise = new Promise(function(resolve, reject) {
//   setTimeout(() => resolve("done!"), 1000);
// });
//
// // resolve запустит первую функцию, переданную в .then
// promise.then(
//   result => alert(result), // выведет "done!" через одну секунду
//   error => alert(error) // не будет запущена
// );
// Выполнилась первая функция.
//
// А в случае ошибки в промисе – выполнится вторая:
//
// let promise = new Promise(function(resolve, reject) {
//   setTimeout(() => reject(new Error("Whoops!")), 1000);
// });
//
// // reject запустит вторую функцию, переданную в .then
// promise.then(
//   result => alert(result), // не будет запущена
//   error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
// );
// Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
//
// let promise = new Promise(resolve => {
//   setTimeout(() => resolve("done!"), 1000);
// });
//
// promise.then(alert); // выведет "done!" спустя одну секунду
// catch
// Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:
//
// let promise = new Promise((resolve, reject) => {
//   setTimeout(() => reject(new Error("Ошибка!")), 1000);
// });
//
// // .catch(f) это то же самое, что promise.then(null, f)
// promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
// Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).
//
// Очистка: finally
// По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.
//
// Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
//
// Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
//
// Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.
//
// Думайте об этом как о завершении вечеринки. Независимо от того, была ли вечеринка хорошей или плохой, сколько на ней было друзей, нам все равно нужно (или, по крайней мере, мы должны) сделать уборку после нее.
//
// Код может выглядеть следующим образом:
//
// new Promise((resolve, reject) => {
//   /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
// })
//   // выполнится, когда промис завершится, независимо от того, успешно или нет
//   .finally(() => остановить индикатор загрузки)
//   // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
//   .then(result => показать результат, err => показать ошибку)
// Обратите внимание, что finally(f) – это не совсем псевдоним then(f,f), как можно было подумать.
//
// Есть важные различия:
//
// Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
//
// Пожалуйста, взгляните на приведенный выше пример: как вы можете видеть, обработчик finally не имеет аргументов, а результат promise обрабатывается в следующем обработчике.
//
// Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
//
// Например, здесь результат проходит через finally к then:
//
// new Promise((resolve, reject) => {
//   setTimeout(() => resolve("value"), 2000);
// })
//   .finally(() => alert("Промис завершён")) // срабатывает первым
//   .then(result => alert(result)); // <-- .then показывает "value"
// Как вы можете видеть, значение возвращаемое первым промисом, передается через finally к следующему then.
//
// Это очень удобно, потому что finally не предназначен для обработки результата промиса. Как уже было сказано, это место для проведения общей очистки, независимо от того, каков был результат.
//
// А здесь ошибка из промиса проходит через finally к catch:
//
// new Promise((resolve, reject) => {
//   throw new Error("error");
// })
//   .finally(() => alert("Промис завершён")) // срабатывает первым
//   .catch(err => alert(err));  // <-- .catch показывает ошибку
// Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.
//
// Единственным исключением из этого правила является случай, когда обработчик finally выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.
//
// Подведем итог:
//
// Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
// Если обработчик finally возвращает что-то, это игнорируется.
// Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.
// Эти функции полезны и заставляют все работать правильно, если мы используем finally так, как предполагается: для общих процедур очистки.
//
// На завершённых промисах обработчики запускаются сразу
// Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его.
//
// Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.
//
// В таком случае эти обработчики просто запускаются немедленно:
//
// // при создании промиса он сразу переводится в состояние "успешно завершён"
// let promise = new Promise(resolve => resolve("готово!"));
//
// promise.then(alert); // готово! (выведется сразу)
// Пример: loadScript
// Теперь рассмотрим несколько практических примеров того, как промисы могут облегчить нам написание асинхронного кода.
//
// У нас есть функция loadScript для загрузки скрипта из предыдущей главы.
//
// Давайте вспомним, как выглядел вариант с колбэками:
//
// function loadScript(src, callback) {
//   let script = document.createElement('script');
//   script.src = src;
//
//   script.onload = () => callback(null, script);
//   script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));
//
//   document.head.append(script);
// }
// Теперь перепишем её, используя Promise.
//
// Новой функции loadScript более не нужен аргумент callback. Вместо этого она будет создавать и возвращать объект Promise, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя .then:
//
// function loadScript(src) {
//   return new Promise(function(resolve, reject) {
//     let script = document.createElement('script');
//     script.src = src;
//
//     script.onload = () => resolve(script);
//     script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));
//
//     document.head.append(script);
//   });
// }
// Применение:
//
// let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");
//
// promise.then(
//   script => alert(`${script.src} загружен!`),
//   error => alert(`Ошибка: ${error.message}`)
// );
//
// promise.then(script => alert('Ещё один обработчик...'));
// Сразу заметно несколько преимуществ перед подходом с использованием колбэков:
//
// Промисы	Колбэки
// Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем loadScript(script), и затем (.then) мы пишем, что делать с результатом.	У нас должна быть функцияcallback на момент вызова loadScript(script, callback). Другими словами, нам нужно знать что делать с результатом до того, как вызовется loadScript.
// Мы можем вызывать .then у Promise столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующей главе: Цепочка промисов.	Колбэк может быть только один.
// Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это далеко не всё. Мы узнаем ещё много полезного в последующих главах.














//Цепочка промисов
// Давайте вернёмся к ситуации из главы Введение: колбэки: у нас есть последовательность асинхронных задач, которые должны быть выполнены одна за другой. Например, речь может идти о загрузке скриптов. Как же грамотно реализовать это в коде?
//
// Промисы предоставляют несколько способов решения подобной задачи.
//
// В этой главе мы разберём цепочку промисов.
//
// Она выглядит вот так:
//
// new Promise(function(resolve, reject) {
//
//   setTimeout(() => resolve(1), 1000); // (*)
//
// }).then(function(result) { // (**)
//
//   alert(result); // 1
//   return result * 2;
//
// }).then(function(result) { // (***)
//
//   alert(result); // 2
//   return result * 2;
//
// }).then(function(result) {
//
//   alert(result); // 4
//   return result * 2;
//
// });
// Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.
//
// Поток выполнения такой:
//
// Начальный промис успешно выполняется через 1 секунду (*),
// Затем вызывается обработчик в .then (**).
// Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
// …и так далее.
// В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.
//
//
// Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
//
// Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий .then.
//
// Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.
//
// Например:
//
// let promise = new Promise(function(resolve, reject) {
//   setTimeout(() => resolve(1), 1000);
// });
//
// promise.then(function(result) {
//   alert(result); // 1
//   return result * 2;
// });
//
// promise.then(function(result) {
//   alert(result); // 1
//   return result * 2;
// });
//
// promise.then(function(result) {
//   alert(result); // 1
//   return result * 2;
// });
// Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют независимо.
//
// Вот картина происходящего (сравните это с изображением цепочки промисов выше):
//
//
// Все обработчики .then на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса. Таким образом, в коде выше все alert показывают одно и то же: 1.
//
// На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда чаще.
//
// Возвращаем промисы
// Обработчик handler, переданный в .then(handler), может вернуть промис.
//
// В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.
//
// Например:
//
// new Promise(function(resolve, reject) {
//
//   setTimeout(() => resolve(1), 1000);
//
// }).then(function(result) {
//
//   alert(result); // 1
//
//   return new Promise((resolve, reject) => { // (*)
//     setTimeout(() => resolve(result * 2), 1000);
//   });
//
// }).then(function(result) { // (**)
//
//   alert(result); // 2
//
//   return new Promise((resolve, reject) => {
//     setTimeout(() => resolve(result * 2), 1000);
//   });
//
// }).then(function(result) {
//
//   alert(result); // 4
//
// });
// Здесь первый .then показывает 1 и возвращает новый промис new Promise(…) в строке (*). Через одну секунду этот промис успешно выполняется, и его результат (аргумент в resolve, то есть result * 2) передаётся обработчику в следующем .then. Он находится в строке (**), показывает2 и делает то же самое.
//
// Таким образом, как и в предыдущем примере, выводятся 1 → 2 → 4, но сейчас между вызовами alert существует пауза в 1 секунду.
//
// Возвращая промисы, мы можем строить цепочки из асинхронных действий.
//
// Пример: loadScript
// Давайте используем эту возможность вместе с промисифицированной функцией loadScript, созданной нами в предыдущей главе, чтобы загружать скрипты по очереди, последовательно:
//
// loadScript("/article/promise-chaining/one.js")
//   .then(function(script) {
//     return loadScript("/article/promise-chaining/two.js");
//   })
//   .then(function(script) {
//     return loadScript("/article/promise-chaining/three.js");
//   })
//   .then(function(script) {
//     // вызовем функции, объявленные в загружаемых скриптах,
//     // чтобы показать, что они действительно загрузились
//     one();
//     two();
//     three();
//   });
// Этот же код можно переписать немного компактнее, используя стрелочные функции:
//
// loadScript("/article/promise-chaining/one.js")
//   .then(script => loadScript("/article/promise-chaining/two.js"))
//   .then(script => loadScript("/article/promise-chaining/three.js"))
//   .then(script => {
//     // скрипты загружены, мы можем использовать объявленные в них функции
//     one();
//     two();
//     three();
//   });
// Здесь каждый вызов loadScript возвращает промис, и следующий обработчик в .then срабатывает, только когда этот промис завершается. Затем инициируется загрузка следующего скрипта и так далее. Таким образом, скрипты загружаются один за другим.
//
// Мы можем добавить и другие асинхронные действия в цепочку. Обратите внимание, что наш код всё ещё «плоский», он «растёт» вниз, а не вправо. Нет никаких признаков «адской пирамиды вызовов».
//
// Технически мы бы могли добавлять .then напрямую к каждому вызову loadScript, вот так:
//
// loadScript("/article/promise-chaining/one.js").then(script1 => {
//   loadScript("/article/promise-chaining/two.js").then(script2 => {
//     loadScript("/article/promise-chaining/three.js").then(script3 => {
//       // эта функция имеет доступ к переменным script1, script2 и script3
//       one();
//       two();
//       three();
//     });
//   });
// });
// Этот код делает то же самое: последовательно загружает 3 скрипта. Но он «растёт вправо», так что возникает такая же проблема, как и с колбэками.
//
// Разработчики, которые не так давно начали использовать промисы, иногда не знают про цепочки и пишут код именно так, как показано выше. В целом, использование цепочек промисов предпочтительнее.
//
// Иногда всё же приемлемо добавлять .then напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости. В примере выше самая глубоко вложенная функция обратного вызова имеет доступ ко всем переменным script1, script2, script3. Но это скорее исключение, чем правило.
//
// Thenable
// Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты называют «thenable», и этот объект будет обработан как промис.
//
// Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут иметь свои наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод .then.
//
// Вот пример такого объекта:
//
// class Thenable {
//   constructor(num) {
//     this.num = num;
//   }
//   then(resolve, reject) {
//     alert(resolve); // function() { native code }
//     // будет успешно выполнено с аргументом this.num*2 через 1 секунду
//     setTimeout(() => resolve(this.num * 2), 1000); // (**)
//   }
// }
//
// new Promise(resolve => resolve(1))
//   .then(result => {
//     return new Thenable(result); // (*)
//   })
//   .then(alert); // показывает 2 через 1000мс
// JavaScript проверяет объект, возвращаемый из обработчика .then в строке (*): если у него имеется метод then, который можно вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции resolve и reject, вызов одной из которых потом ожидается. В примере выше происходит вызов resolve(2) через 1 секунду (**). Затем результат передаётся дальше по цепочке.
//
// Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.
//
// Более сложный пример: fetch
// Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.
//
// Мы будем использовать метод fetch, чтобы подгрузить информацию о пользователях с удалённого сервера. Этот метод имеет много опциональных параметров, разобранных в соответствующих разделах, но базовый синтаксис весьма прост:
//
// let promise = fetch(url);
// Этот код запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект response после того, как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.
//
// Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется, когда данные полностью загружены с удалённого сервера, и возвращает эти данные.
//
// Код ниже запрашивает файл user.json и загружает его содержимое с сервера:
//
// fetch('/article/promise-chaining/user.json')
//   // .then в коде ниже выполняется, когда удалённый сервер отвечает
//   .then(function(response) {
//     // response.text() возвращает новый промис,
//     // который выполняется и возвращает полный ответ сервера,
//     // когда он загрузится
//     return response.text();
//   })
//   .then(function(text) {
//     // ...и здесь содержимое полученного файла
//     alert(text); // {"name": "iliakan", isAdmin: true}
//   });
// Есть также метод response.json(), который читает данные в формате JSON. Он больше подходит для нашего примера, так что давайте использовать его.
//
// Мы также применим стрелочные функции для более компактной записи кода:
//
// // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
// fetch('/article/promise-chaining/user.json')
//   .then(response => response.json())
//   .then(user => alert(user.name)); // iliakan, получили имя пользователя
// Теперь давайте что-нибудь сделаем с полученными данными о пользователе.
//
// Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя и показать его аватар:
//
// // Запрашиваем user.json
// fetch('/article/promise-chaining/user.json')
//   // Загружаем данные в формате json
//   .then(response => response.json())
//   // Делаем запрос к GitHub
//   .then(user => fetch(`https://api.github.com/users/${user.name}`))
//   // Загружаем ответ в формате json
//   .then(response => response.json())
//   // Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
//   .then(githubUser => {
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     img.className = "promise-avatar-example";
//     document.body.append(img);
//
//     setTimeout(() => img.remove(), 3000); // (*)
//   });
// Код работает, детали реализации отражены в комментариях. Однако в нём есть одна потенциальная проблема, с которой часто сталкиваются новички.
//
// Посмотрите на строку (*): как мы можем предпринять какие-то действия после того, как аватар был показан и удалён? Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё. Сейчас это невозможно.
//
// Чтобы сделать наш код расширяемым, нам нужно возвращать ещё один промис, который выполняется после того, как завершается показ аватара.
//
// Примерно так:
//
// fetch('/article/promise-chaining/user.json')
//   .then(response => response.json())
//   .then(user => fetch(`https://api.github.com/users/${user.name}`))
//   .then(response => response.json())
//   .then(githubUser => new Promise(function(resolve, reject) { // (*)
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     img.className = "promise-avatar-example";
//     document.body.append(img);
//
//     setTimeout(() => {
//       img.remove();
//       resolve(githubUser); // (**)
//     }, 3000);
//   }))
//   // срабатывает через 3 секунды
//   .then(githubUser => alert(`Закончили показ ${githubUser.name}`));
// То есть, обработчик .then в строке (*) будет возвращать new Promise, который перейдёт в состояние «выполнен» только после того, как в setTimeout (**) будет вызвана resolve(githubUser).
//
// Соответственно, следующий по цепочке .then будет ждать этого.
//
// Как правило, все асинхронные действия должны возвращать промис.
//
// Это позволяет планировать после него какие-то дополнительные действия. Даже если эта возможность не нужна прямо сейчас, она может понадобиться в будущем.
//
// И, наконец, давайте разобьём написанный код на отдельные функции, пригодные для повторного использования:
//
// function loadJson(url) {
//   return fetch(url)
//     .then(response => response.json());
// }
//
// function loadGithubUser(name) {
//   return fetch(`https://api.github.com/users/${name}`)
//     .then(response => response.json());
// }
//
// function showAvatar(githubUser) {
//   return new Promise(function(resolve, reject) {
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     img.className = "promise-avatar-example";
//     document.body.append(img);
//
//     setTimeout(() => {
//       img.remove();
//       resolve(githubUser);
//     }, 3000);
//   });
// }
//
// // Используем их:
// loadJson('/article/promise-chaining/user.json')
//   .then(user => loadGithubUser(user.name))
//   .then(showAvatar)
//   .then(githubUser => alert(`Показ аватара ${githubUser.name} завершён`));
//   // ...
// Итого
// Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.
//
// Вот полная картина происходящего:
//
//
// Задачи









//Промисы: обработка ошибок
// Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.
//
// Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует), и .catch перехватывает ошибку:
//
// fetch('https://no-such-server.blabla') // ошибка
//   .then(response => response.json())
//   .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
// Как видно, .catch не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких .then
//
// Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:
//
// fetch('/article/promise-chaining/user.json')
//   .then(response => response.json())
//   .then(user => fetch(`https://api.github.com/users/${user.name}`))
//   .then(response => response.json())
//   .then(githubUser => new Promise((resolve, reject) => {
//     let img = document.createElement('img');
//     img.src = githubUser.avatar_url;
//     img.className = "promise-avatar-example";
//     document.body.append(img);
//
//     setTimeout(() => {
//       img.remove();
//       resolve(githubUser);
//     }, 3000);
//   }))
//   .catch(error => alert(error.message));
// Если все в порядке, то такой .catch вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.
//
// Неявный try…catch
// Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.
//
// Например, этот код:
//
// new Promise((resolve, reject) => {
//   throw new Error("Ошибка!");
// }).catch(alert); // Error: Ошибка!
// …Работает так же, как и этот:
//
// new Promise((resolve, reject) => {
//   reject(new Error("Ошибка!"));
// }).catch(alert); // Error: Ошибка!
// "Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.
//
// Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (throw) из обработчика (.then), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.
//
// Пример:
//
// new Promise((resolve, reject) => {
//   resolve("ок");
// }).then((result) => {
//   throw new Error("Ошибка!"); // генерируем ошибку
// }).catch(alert); // Error: Ошибка!
// Это происходит для всех ошибок, не только для тех, которые вызваны оператором throw. Например, программная ошибка:
//
// new Promise((resolve, reject) => {
//   resolve("ок");
// }).then((result) => {
//   blabla(); // нет такой функции
// }).catch(alert); // ReferenceError: blabla is not defined
// Финальный .catch перехватывает как промисы, в которых вызван reject, так и случайные ошибки в обработчиках.
//
// Пробрасывание ошибок
// Как мы уже заметили, .catch ведёт себя как try..catch. Мы можем иметь столько обработчиков .then, сколько мы хотим, и затем использовать один .catch в конце, чтобы перехватить ошибки из всех обработчиков.
//
// В обычном try..catch мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.
//
// Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then.
//
// В примере ниже .catch успешно обрабатывает ошибку:
//
// // the execution: catch -> then
// new Promise((resolve, reject) => {
//
//   throw new Error("Ошибка!");
//
// }).catch(function(error) {
//
//   alert("Ошибка обработана, продолжить работу");
//
// }).then(() => alert("Управление перейдёт в следующий then"));
// Здесь блок .catch завершается нормально. Поэтому вызывается следующий успешный обработчик .then.
//
// В примере ниже мы видим другую ситуацию с блоком .catch. Обработчик (*) перехватывает ошибку и не может обработать её (например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:
//
// // the execution: catch -> catch -> then
// new Promise((resolve, reject) => {
//
//   throw new Error("Ошибка!");
//
// }).catch(function(error) { // (*)
//
//   if (error instanceof URIError) {
//     // обрабатываем ошибку
//   } else {
//     alert("Не могу обработать ошибку");
//
//     throw error; // пробрасывает эту или другую ошибку в следующий catch
//   }
//
// }).then(function() {
//   /* не выполнится */
// }).catch(error => { // (**)
//
//   alert(`Неизвестная ошибка: ${error}`);
//   // ничего не возвращаем => выполнение продолжается в нормальном режиме
//
// });
// Управление переходит от первого блока .catch (*) к следующему (**), вниз по цепочке.
//
// Необработанные ошибки
// Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить .catch в конец цепочки, как здесь:
//
// new Promise(function() {
//   noSuchFunction(); // Ошибка (нет такой функции)
// })
//   .then(() => {
//     // обработчики .then, один или более
//   }); // без .catch в самом конце!
// В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.
//
// На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.
//
// Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.
//
// JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.
//
// В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:
//
// window.addEventListener('unhandledrejection', function(event) {
//   // объект события имеет два специальных свойства:
//   alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
//   alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
// });
//
// new Promise(function() {
//   throw new Error("Ошибка!");
// }); // нет обработчика ошибок
// Это событие является частью стандарта HTML.
//
// Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, и соответствующий объект event содержит информацию об ошибке.
//
// Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.
//
// В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.
//
// Итого
// .catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.
// .then также перехватывает ошибки таким же образом, если задан второй аргумент (который является обработчиком ошибок).
// Необходимо размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).
// Можно и совсем не использовать .catch, если нет нормального способа восстановиться после ошибки.
// В любом случае нам следует использовать обработчик события unhandledrejection (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».




















//Promise API
// В классе Promise есть 6 статических методов. Давайте познакомимся с ними.
//
// Promise.all
// Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.
//
// Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.
//
// Для этого как раз и пригодится Promise.all.
//
// Синтаксис:
//
// let promise = Promise.all(iterable);
// Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.
//
// Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
//
// Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:
//
// Promise.all([
//   new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
//   new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
//   new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
// ]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// // каждый промис даёт элемент массива
// Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.
//
// Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернуть получившийся массив в Promise.all.
//
// Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:
//
// let urls = [
//   'https://api.github.com/users/iliakan',
//   'https://api.github.com/users/remy',
//   'https://api.github.com/users/jeresig'
// ];
//
// // Преобразуем каждый URL в промис, возвращённый fetch
// let requests = urls.map(url => fetch(url));
//
// // Promise.all будет ожидать выполнения всех промисов
// Promise.all(requests)
//   .then(responses => responses.forEach(
//     response => alert(`${response.url}: ${response.status}`)
//   ));
// А вот пример побольше, с получением информации о пользователях GitHub по их логинам из массива (мы могли бы получать массив товаров по их идентификаторам, логика та же):
//
// let names = ['iliakan', 'remy', 'jeresig'];
//
// let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));
//
// Promise.all(requests)
//   .then(responses => {
//     // все промисы успешно завершены
//     for(let response of responses) {
//       alert(`${response.url}: ${response.status}`); // покажет 200 для каждой ссылки
//     }
//
//     return responses;
//   })
//   // преобразовать массив ответов response в response.json(),
//   // чтобы прочитать содержимое каждого
//   .then(responses => Promise.all(responses.map(r => r.json())))
//   // все JSON-ответы обработаны, users - массив с результатами
//   .then(users => users.forEach(user => alert(user.name)));
// Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.
//
// Например:
//
// Promise.all([
//   new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
//   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
//   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// ]).catch(alert); // Error: Ошибка!
// Здесь второй промис завершится с ошибкой через 2 секунды. Это приведёт к немедленной ошибке в Promise.all, так что выполнится .catch: ошибка этого промиса становится ошибкой всего Promise.all.
//
// В случае ошибки, остальные результаты игнорируются
// Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.
//
// Например, если сделано несколько вызовов fetch, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но Promise.all за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.
//
// Promise.all ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». В главе Fetch: прерывание запроса мы рассмотрим AbortController, который помогает с этим, но он не является частью Promise API.
//
// Promise.all(iterable) разрешает передавать не-промисы в iterable (перебираемом объекте)
// Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».
//
// Например, здесь результат: [1, 2, 3]
//
// Promise.all([
//   new Promise((resolve, reject) => {
//     setTimeout(() => resolve(1), 1000)
//   }),
//   2,
//   3
// ]).then(alert); // 1, 2, 3
// Таким образом, мы можем передавать уже готовые значения, которые не являются промисами, в Promise.all, иногда это бывает удобно.
//
// Promise.allSettled
// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.
// Синтаксис:
//
// let promise = Promise.allSettled(iterable);
// Promise.all завершается с ошибкой, если она возникает в любом из переданных промисов. Это подходит для ситуаций «всё или ничего», когда нам нужны все результаты для продолжения:
//
// Promise.all([
//   fetch('/template.html'),
//   fetch('/style.css'),
//   fetch('/data.json')
// ]).then(render); // методу render нужны результаты всех fetch
// Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет
//
// {status:"fulfilled", value:результат} для успешных завершений,
// {status:"rejected", reason:ошибка} для ошибок.
// Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.
//
// Используем для этого Promise.allSettled:
//
// let urls = [
//   'https://api.github.com/users/iliakan',
//   'https://api.github.com/users/remy',
//   'https://no-such-url'
// ];
//
// Promise.allSettled(urls.map(url => fetch(url)))
//   .then(results => { // (*)
//     results.forEach((result, num) => {
//       if (result.status == "fulfilled") {
//         alert(`${urls[num]}: ${result.value.status}`);
//       }
//       if (result.status == "rejected") {
//         alert(`${urls[num]}: ${result.reason}`);
//       }
//     });
//   });
// Массив results в строке (*) будет таким:
//
// [
//   {status: 'fulfilled', value: ...объект ответа...},
//   {status: 'fulfilled', value: ...объект ответа...},
//   {status: 'rejected', reason: ...объект ошибки...}
// ]
// То есть, для каждого промиса у нас есть его статус и значение/ошибка.
//
// Полифил
// Если браузер не поддерживает Promise.allSettled, для него легко сделать полифил:
//
// if(!Promise.allSettled) {
//   Promise.allSettled = function(promises) {
//     return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
//       status: 'fulfilled',
//       value: value
//     }), error => ({
//       status: 'rejected',
//       reason: error
//     }))));
//   };
// }
// В этом коде promises.map берёт аргументы, превращает их в промисы (на всякий случай) и добавляет каждому обработчик .then.
//
// Этот обработчик превращает успешный результат value в {state:'fulfilled', value: value}, а ошибку error в {state:'rejected', reason: error}. Это как раз и есть формат результатов Promise.allSettled.
//
// Затем мы можем использовать Promise.allSettled, чтобы получить результаты всех промисов, даже если при выполнении какого-то возникнет ошибка.
//
// Promise.race
// Метод очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
//
// Синтаксис:
//
// let promise = Promise.race(iterable);
// Например, тут результат будет 1:
//
// Promise.race([
//   new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
//   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
//   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// ]).then(alert); // 1
// Быстрее всех выполнился первый промис, он и дал результат. После этого остальные промисы игнорируются.
//
// Promise.any
// Метод очень похож на Promise.race, но ждёт только первый успешно выполненный промис, из которого берёт результат.
//
// Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.
//
// Синтаксис:
//
// let promise = Promise.any(iterable);
// Например, здесь, результатом будет 1:
//
// Promise.any([
//   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
//   new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
//   new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
// ]).then(alert); // 1
// Первый промис в этом примере был самым быстрым, но он был отклонён, поэтому результатом стал второй. После того, как первый успешно выполненный промис «выиграет гонку», все дальнейшие результаты будут проигнорированы.
//
// Вот пример, в котором все промисы отклоняются:
//
// Promise.any([
//   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
//   new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ещё одна ошибка!")), 2000))
// ]).catch(error => {
//   console.log(error.constructor.name); // AggregateError
//   console.log(error.errors[0]); // Error: Ошибка!
//   console.log(error.errors[1]); // Error: Ещё одна ошибка!
// });
// Как вы можете видеть, объекты ошибок для отклонённых промисов доступны в свойстве errors объекта AggregateError.
//
// Promise.resolve/reject
// Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы рассмотрим его чуть позже) делает их, в общем-то, не нужными.
//
// Мы рассмотрим их здесь для полноты картины, а также для тех, кто по каким-то причинам не может использовать async/await.
//
// Promise.resolve
// Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
// То же самое, что:
//
// let promise = new Promise(resolve => resolve(value));
// Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.
//
// Например, функция loadCached ниже загружает URL и запоминает (кеширует) его содержимое. При будущих вызовах с тем же URL он тут же читает предыдущее содержимое из кеша, но использует Promise.resolve, чтобы сделать из него промис, для того, чтобы возвращаемое значение всегда было промисом:
//
// let cache = new Map();
//
// function loadCached(url) {
//   if (cache.has(url)) {
//     return Promise.resolve(cache.get(url)); // (*)
//   }
//
//   return fetch(url)
//     .then(response => response.text())
//     .then(text => {
//       cache.set(url,text);
//       return text;
//     });
// }
// Мы можем писать loadCached(url).then(…), потому что функция loadCached всегда возвращает промис. Мы всегда можем использовать .then после loadCached. Это и есть цель использования Promise.resolve в строке (*).
//
// Promise.reject
// Promise.reject(error) создаёт промис, завершённый с ошибкой error.
// То же самое, что:
//
// let promise = new Promise((resolve, reject) => reject(error));
// На практике этот метод почти никогда не используется.
//
// Итого
// Мы ознакомились с шестью статическими методами класса Promise:
//
// Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
// Promise.allSettled(promises) (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
// status: "fulfilled", если выполнен успешно или "rejected", если ошибка,
// value – результат, если успешно или reason – ошибка, если нет.
// Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
// Promise.any(promises) (добавлен недавно) – ожидает первый успешно выполненный промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, AggregateError становится ошибкой Promise.any.
// Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
// Promise.reject(error) – возвращает промис с ошибкой error.
// Из всех перечисленных методов, самый часто используемый – это, пожалуй, Promise.all.










//Промисификация
// Промисификация – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.
//
// Такие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл «промисифицировать» их.
//
// Например, у нас есть loadScript(src, callback) из главы Введение: колбэки.
//
// function loadScript(src, callback) {
//   let script = document.createElement('script');
//   script.src = src;
//
//   script.onload = () => callback(null, script);
//   script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));
//
//   document.head.append(script);
// }
//
// // использование:
// // loadScript('path/script.js', (err, script) => {...})
// Давайте промисифицируем её. Новая функция loadScriptPromise(src) будет делать то же самое, но будет принимать только src (не callback) и возвращать промис.
//
// let loadScriptPromise = function(src) {
//   return new Promise((resolve, reject) => {
//     loadScript(src, (err, script) => {
//       if (err) reject(err)
//       else resolve(script);
//     });
//   })
// }
//
// // использование:
// // loadScriptPromise('path/script.js').then(...)
// Теперь loadScriptPromise хорошо вписывается в код, основанный на промисах.
//
// Как видно, она передаёт всю работу исходной функции loadScript, предоставляя ей колбэк, по вызову которого происходит resolve/reject промиса.
//
// На практике нам, скорее всего, понадобится промисифицировать не одну функцию, поэтому имеет смысл сделать для этого специальную «функцию-помощник».
//
// Мы назовём её promisify(f) – она принимает функцию для промисификации f и возвращает функцию-обёртку.
//
// Эта функция-обёртка делает то же самое, что и код выше: возвращает промис и передаёт вызов оригинальной f, отслеживая результат в своём колбэке:
//
// function promisify(f) {
//   return function (...args) { // возвращает функцию-обёртку
//     return new Promise((resolve, reject) => {
//       function callback(err, result) { // наш специальный колбэк для f
//         if (err) {
//           reject(err);
//         } else {
//           resolve(result);
//         }
//       }
//
//       args.push(callback); // добавляем колбэк в конец аргументов f
//
//       f.call(this, ...args); // вызываем оригинальную функцию
//     });
//   };
// };
//
// // использование:
// let loadScriptPromise = promisify(loadScript);
// loadScriptPromise(...).then(...);
// Здесь мы предполагаем, что исходная функция ожидает колбэк с двумя аргументами (err, result). Это то, с чем мы чаще всего сталкиваемся. Тогда наш колбэк – в правильном формате, и promisify отлично работает для такого случая.
//
// Но что, если исходная f ожидает колбэк с большим количеством аргументов callback(err, res1, res2, ...)?
//
// Ниже описана улучшенная функция promisify: при вызове promisify(f, true) результатом промиса будет массив результатов [res1, res2, ...]:
//
// // promisify(f, true), чтобы получить массив результатов
// function promisify(f, manyArgs = false) {
//   return function (...args) {
//     return new Promise((resolve, reject) => {
//       function callback(err, ...results) { // наш специальный колбэк для f
//         if (err) {
//           reject(err);
//         } else {
//           // делаем resolve для всех results колбэка, если задано manyArgs
//           resolve(manyArgs ? results : results[0]);
//         }
//       }
//
//       args.push(callback);
//
//       f.call(this, ...args);
//     });
//   };
// };
//
// // использование:
// f = promisify(f, true);
// f(...).then(arrayOfResults => ..., err => ...)
// Для более экзотических форматов колбэка, например без err: callback(result), мы можем промисифицировать функции без помощника, «вручную».
//
// Также существуют модули с более гибкой промисификацией, например, es6-promisify или встроенная функция util.promisify в Node.js.
//
// На заметку:
// Промисификация – это отличный подход, особенно, если вы будете использовать async/await (см. следующую главу), но она не является тотальной заменой любых колбэков.
//
// Помните, промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.
//
// Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.







//Микрозадачи
// Обработчики промисов .then/.catch/.finally всегда асинхронны.
//
// Даже когда промис сразу же выполнен, код в строках ниже .then/.catch/.finally будет запущен до этих обработчиков.
//
// Вот демо:
//
// let promise = Promise.resolve();
//
// promise.then(() => alert("промис выполнен"));
//
// alert("код выполнен"); // этот alert показывается первым
// Если вы запустите его, сначала вы увидите код выполнен, а потом промис выполнен.
//
// Это странно, потому что промис определённо был выполнен с самого начала.
//
// Почему .then срабатывает позже? Что происходит?
//
// Очередь микрозадач
// Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» (термин V8).
//
// Как сказано в спецификации:
//
// Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
// Выполнение задачи происходит только в том случае, если ничего больше не запущено.
// Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.
//
// Вот почему сообщение «код выполнен» в примере выше будет показано первым.
//
//
// Обработчики промисов всегда проходят через эту внутреннюю очередь.
//
// Если есть цепочка с несколькими .then/catch/finally, то каждый из них выполняется асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.
//
// Но что если порядок имеет значение для нас? Как мы можем вывести код выполнен после промис выполнен?
//
// Легко, используя .then:
//
// Promise.resolve()
//   .then(() => alert("промис выполнен!"))
//   .then(() => alert("код выполнен"));
// Теперь порядок стал таким, как было задумано.
//
// Необработанные ошибки
// Помните «необработанные ошибки» из главы Промисы: обработка ошибок?
//
// Теперь мы можем описать, как именно JavaScript понимает, что ошибка не обработана.
//
// "Необработанная ошибка" возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.
//
// Обычно, если мы ожидаем ошибку, мы добавляем .catch в конец цепочки промисов, чтобы обработать её:
//
// let promise = Promise.reject(new Error("Ошибка в промисе!"));
// promise.catch(err => alert('поймана!'));
//
// // не запустится, ошибка обработана
// window.addEventListener('unhandledrejection', event => {
//   alert(event.reason);
// });
// …Но если мы забудем добавить .catch, то, когда очередь микрозадач опустеет, движок сгенерирует событие:
//
// let promise = Promise.reject(new Error("Ошибка в промисе!"));
//
// // Ошибка в промисе!
// window.addEventListener('unhandledrejection', event => alert(event.reason));
// А что, если мы поймаем ошибку, но позже? Вот так:
//
// let promise = Promise.reject(new Error("Ошибка в промисе!"));
//
// setTimeout(() => promise.catch(err => alert('поймана')), 1000);
//
// // Ошибка в промисе!
// window.addEventListener('unhandledrejection', event => alert(event.reason));
// Теперь, при запуске, мы сначала увидим «Ошибка в промисе!», а затем «поймана».
//
// Если бы мы не знали про очередь микрозадач, то могли бы удивиться: «Почему сработал обработчик unhandledrejection? Мы же поймали ошибку!».
//
// Но теперь мы понимаем, что событие unhandledrejection возникает, когда очередь микрозадач завершена: движок проверяет все промисы и, если какой-либо из них в состоянии «rejected», то генерируется это событие.
//
// В примере выше .catch, добавленный в setTimeout, также срабатывает, но позже, уже после возникновения unhandledrejection, так что это ни на что не влияет.
//
// Итого
// Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин v8).
//
// Таким образом, обработчики .then/catch/finally вызываются после выполнения текущего кода.
//
// Если нам нужно гарантировать выполнение какого-то кода после .then/catch/finally, то лучше всего добавить его вызов в цепочку .then.
//
// В большинстве движков JavaScript, включая браузеры и Node.js, микрозадачи тесно связаны с так называемым «событийным циклом» и «макрозадачами». Так как они не связаны напрямую с промисами, то рассматриваются в другой части учебника, в главе Событийный цикл: микрозадачи и макрозадачи.
//
// Проводим курсы по JavaScript и фреймворкам.









//Async/await
// Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.
//
// Асинхронные функции
// Начнём с ключевого слова async. Оно ставится перед функцией, вот так:
//
// async function f() {
//   return 1;
// }
// У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.
//
// Например, эта функция возвратит выполненный промис с результатом 1:
//
// async function f() {
//   return 1;
// }
//
// f().then(alert); // 1
// Можно и явно вернуть промис, результат будет одинаковым:
//
// async function f() {
//   return Promise.resolve(1);
// }
//
// f().then(alert); // 1
// Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.
//
// Await
// Синтаксис:
//
// // работает только внутри async–функций
// let value = await promise;
// Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.
//
// В этом примере промис успешно выполнится через 1 секунду:
//
// async function f() {
//
//   let promise = new Promise((resolve, reject) => {
//     setTimeout(() => resolve("готово!"), 1000)
//   });
//
//   let result = await promise; // будет ждать, пока промис не выполнится (*)
//
//   alert(result); // "готово!"
// }
//
// f();
// В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».
//
// Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.
//
// По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.
//
// await нельзя использовать в обычных функциях
// Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку:
//
// function f() {
//   let promise = Promise.resolve(1);
//   let result = await promise; // SyntaxError
// }
// Ошибки не будет, если мы укажем ключевое слово async перед объявлением функции. Как было сказано раньше, await можно использовать только внутри async–функций.
//
// Давайте перепишем пример showAvatar() из раздела Цепочка промисов с помощью async/await:
//
// Нам нужно заменить вызовы .then на await.
// И добавить ключевое слово async перед объявлением функции.
// async function showAvatar() {
//
//   // запрашиваем JSON с данными пользователя
//   let response = await fetch('/article/promise-chaining/user.json');
//   let user = await response.json();
//
//   // запрашиваем информацию об этом пользователе из github
//   let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
//   let githubUser = await githubResponse.json();
//
//   // отображаем аватар пользователя
//   let img = document.createElement('img');
//   img.src = githubUser.avatar_url;
//   img.className = "promise-avatar-example";
//   document.body.append(img);
//
//   // ждём 3 секунды и затем скрываем аватар
//   await new Promise((resolve, reject) => setTimeout(resolve, 3000));
//
//   img.remove();
//
//   return githubUser;
// }
//
// showAvatar();
// Получилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.
//
// await нельзя использовать на верхнем уровне вложенности
// Программисты, узнав об await, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что await работает только внутри async–функций, так сделать не получится:
//
// // SyntaxError на верхнем уровне вложенности
// let response = await fetch('/article/promise-chaining/user.json');
// let user = await response.json();
// Можно обернуть этот код в анонимную async–функцию, тогда всё заработает:
//
// (async () => {
//   let response = await fetch('/article/promise-chaining/user.json');
//   let user = await response.json();
//   ...
// })();
// await работает с «thenable»–объектами
// Как и promise.then, await позволяет работать с промис–совместимыми объектами. Идея в том, что если у объекта можно вызвать метод then, этого достаточно, чтобы использовать его с await.
//
// В примере ниже, экземпляры класса Thenable будут работать вместе с await:
//
// class Thenable {
//   constructor(num) {
//     this.num = num;
//   }
//   then(resolve, reject) {
//     alert(resolve);
//     // выполнить resolve со значением this.num * 2 через 1000мс
//     setTimeout(() => resolve(this.num * 2), 1000); // (*)
//   }
// };
//
// async function f() {
//   // код будет ждать 1 секунду,
//   // после чего значение result станет равным 2
//   let result = await new Thenable(1);
//   alert(result);
// }
//
// f();
// Когда await получает объект с .then, не являющийся промисом, JavaScript автоматически запускает этот метод, передавая ему аргументы – встроенные функции resolve и reject. Затем await приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана (в примере это строка (*)). После чего выполнение кода продолжится с результатом resolve или reject соответственно.
//
// Асинхронные методы классов
// Для объявления асинхронного метода достаточно написать async перед именем:
//
// class Waiter {
//   async wait() {
//     return await Promise.resolve(1);
//   }
// }
//
// new Waiter()
//   .wait()
//   .then(alert); // 1
// Как и в случае с асинхронными функциями, такой метод гарантированно возвращает промис, и в его теле можно использовать await.
//
// Обработка ошибок
// Когда промис завершается успешно, await promise возвращает результат. Когда завершается с ошибкой – будет выброшено исключение. Как если бы на этом месте находилось выражение throw.
//
// Такой код:
//
// async function f() {
//   await Promise.reject(new Error("Упс!"));
// }
// Делает то же самое, что и такой:
//
// async function f() {
//   throw new Error("Упс!");
// }
// Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае будет задержка, а затем await выбросит исключение.
//
// Такие ошибки можно ловить, используя try..catch, как с обычным throw:
//
// async function f() {
//
//   try {
//     let response = await fetch('http://no-such-url');
//   } catch(err) {
//     alert(err); // TypeError: failed to fetch
//   }
// }
//
// f();
// В случае ошибки выполнение try прерывается и управление прыгает в начало блока catch. Блоком try можно обернуть несколько строк:
//
// async function f() {
//
//   try {
//     let response = await fetch('/no-user-here');
//     let user = await response.json();
//   } catch(err) {
//     // перехватит любую ошибку в блоке try: и в fetch, и в response.json
//     alert(err);
//   }
// }
//
// f();
// Если у нас нет try..catch, асинхронная функция будет возвращать завершившийся с ошибкой промис (в состоянии rejected). В этом случае мы можем использовать метод .catch промиса, чтобы обработать ошибку:
//
// async function f() {
//   let response = await fetch('http://no-such-url');
// }
//
// // f() вернёт промис в состоянии rejected
// f().catch(alert); // TypeError: failed to fetch // (*)
// Если забыть добавить .catch, то будет сгенерирована ошибка «Uncaught promise error» и информация об этом будет выведена в консоль. Такие ошибки можно поймать глобальным обработчиком, о чём подробно написано в разделе Промисы: обработка ошибок.
//
// async/await и promise.then/catch
// При работе с async/await, .then используется нечасто, так как await автоматически ожидает завершения выполнения промиса. В этом случае обычно (но не всегда) гораздо удобнее перехватывать ошибки, используя try..catch, нежели чем .catch.
//
// Но на верхнем уровне вложенности (вне async–функций) await использовать нельзя, поэтому .then/catch для обработки финального результата или ошибок – обычная практика.
//
// Так сделано в строке (*) в примере выше.
//
// async/await отлично работает с Promise.all
// Когда необходимо подождать несколько промисов одновременно, можно обернуть их в Promise.all, и затем await:
//
// // await будет ждать массив с результатами выполнения всех промисов
// let results = await Promise.all([
//   fetch(url1),
//   fetch(url2),
//   ...
// ]);
// В случае ошибки она будет передаваться как обычно: от завершившегося с ошибкой промиса к Promise.all. А после будет сгенерировано исключение, которое можно отловить, обернув выражение в try..catch.
//
// Итого
// Ключевое слово async перед объявлением функции:
//
// Обязывает её всегда возвращать промис.
// Позволяет использовать await в теле этой функции.
// Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:
//
// Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
// Иначе вернётся результат промиса.
// Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.
//
// Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

















//Генераторы
// Обычные функции возвращают только одно-единственное значение (или ничего).
//
// Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.
//
// Функция-генератор
// Для объявления генератора используется специальная синтаксическая конструкция: function*, которая называется «функция-генератор».
//
// Выглядит она так:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   return 3;
// }
// Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.
//
// Вот, посмотрите:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   return 3;
// }
//
// // "функция-генератор" создаёт объект "генератор"
// let generator = generateSequence();
// alert(generator); // [object Generator]
// Выполнение кода функции ещё не началось:
//
//
// Основным методом генератора является next(). При вызове он запускает выполнение кода до ближайшей инструкции yield <значение> (значение может отсутствовать, в этом случае оно предполагается равным undefined). По достижении yield выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:
//
// Результатом метода next() всегда является объект с двумя свойствами:
//
// value: значение из yield.
// done: true, если выполнение функции завершено, иначе false.
// Например, здесь мы создаём генератор и получаем первое из возвращаемых им значений:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   return 3;
// }
//
// let generator = generateSequence();
//
// let one = generator.next();
//
// alert(JSON.stringify(one)); // {value: 1, done: false}
// На данный момент мы получили только первое значение, выполнение функции остановлено на второй строке:
//
//
// Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield:
//
// let two = generator.next();
//
// alert(JSON.stringify(two)); // {value: 2, done: false}
//
// И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
//
// let three = generator.next();
//
// alert(JSON.stringify(three)); // {value: 3, done: true}
//
// Сейчас генератор полностью выполнен. Мы можем увидеть это по свойству done:true и обработать value:3 как окончательный результат.
//
// Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true}.
//
// function* f(…) или function *f(…)?
// Нет разницы, оба синтаксиса корректны.
//
// Но обычно предпочтителен первый вариант, так как звёздочка относится к типу объявляемой сущности (function* – «функция-генератор»), а не к её названию, так что резонно расположить её у слова function.
//
// Перебор генераторов
// Как вы, наверное, уже догадались по наличию метода next(), генераторы являются перебираемыми объектами.
//
// Возвращаемые ими значения можно перебирать через for..of:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   return 3;
// }
//
// let generator = generateSequence();
//
// for(let value of generator) {
//   alert(value); // 1, затем 2
// }
// Выглядит гораздо красивее, чем использование .next().value, верно?
//
// …Но обратите внимание: пример выше выводит значение 1, затем 2. Значение 3 выведено не будет!
//
// Это из-за того, что перебор через for..of игнорирует последнее значение, при котором done: true. Поэтому, если мы хотим, чтобы были все значения при переборе через for..of, то надо возвращать их через yield:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   yield 3;
// }
//
// let generator = generateSequence();
//
// for(let value of generator) {
//   alert(value); // 1, затем 2, затем 3
// }
// Так как генераторы являются перебираемыми объектами, мы можем использовать всю связанную с ними функциональность, например оператор расширения ...:
//
// function* generateSequence() {
//   yield 1;
//   yield 2;
//   yield 3;
// }
//
// let sequence = [0, ...generateSequence()];
//
// alert(sequence); // 0, 1, 2, 3
// В коде выше ...generateSequence() превращает перебираемый объект-генератор в массив элементов (подробнее ознакомиться с оператором расширения можно в главе Остаточные параметры и оператор расширения)
//
// Использование генераторов для перебираемых объектов
// Некоторое время назад, в главе Перебираемые объекты, мы создали перебираемый объект range, который возвращает значения from..to.
//
// Давайте вспомним код:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   // for..of range вызывает этот метод один раз в самом начале
//   [Symbol.iterator]() {
//     // ...он возвращает перебираемый объект:
//     // далее for..of работает только с этим объектом, запрашивая следующие значения
//     return {
//       current: this.from,
//       last: this.to,
//
//       // next() вызывается при каждой итерации цикла for..of
//       next() {
//         // нужно вернуть значение как объект {done:.., value :...}
//         if (this.current <= this.last) {
//           return { done: false, value: this.current++ };
//         } else {
//           return { done: true };
//         }
//       }
//     };
//   }
// };
//
// // при переборе объекта range будут выведены числа от range.from до range.to
// alert([...range]); // 1,2,3,4,5
// Мы можем использовать функцию-генератор для итерации, указав её в Symbol.iterator.
//
// Вот тот же range, но с гораздо более компактным итератором:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   *[Symbol.iterator]() { // краткая запись для [Symbol.iterator]: function*()
//     for(let value = this.from; value <= this.to; value++) {
//       yield value;
//     }
//   }
// };
//
// alert( [...range] ); // 1,2,3,4,5
// Это работает, потому что range[Symbol.iterator]() теперь возвращает генератор, и его методы – в точности то, что ожидает for..of:
//
// у него есть метод .next()
// который возвращает значения в виде {value: ..., done: true/false}
// Это не совпадение, конечно. Генераторы были добавлены в язык JavaScript, в частности, с целью упростить создание перебираемых объектов.
//
// Вариант с генератором намного короче, чем исходный вариант перебираемого range, и сохраняет те же функциональные возможности.
//
// Генераторы могут генерировать бесконечно
// В примерах выше мы генерировали конечные последовательности, но мы также можем сделать генератор, который будет возвращать значения бесконечно. Например, бесконечная последовательность псевдослучайных чисел.
//
// Конечно, нам потребуется break (или return) в цикле for..of по такому генератору, иначе цикл будет продолжаться бесконечно, и скрипт «зависнет».
//
// Композиция генераторов
// Композиция генераторов – это особенная возможность генераторов, которая позволяет прозрачно «встраивать» генераторы друг в друга.
//
// Например, у нас есть функция для генерации последовательности чисел:
//
// function* generateSequence(start, end) {
//   for (let i = start; i <= end; i++) yield i;
// }
// Мы хотели бы использовать её при генерации более сложной последовательности:
//
// сначала цифры 0..9 (с кодами символов 48…57)
// за которыми следуют буквы в верхнем регистре A..Z (коды символов 65…90)
// за которыми следуют буквы алфавита a..z (коды символов 97…122)
// Мы можем использовать такую последовательность для генерации паролей, выбирать символы из неё (может быть, ещё добавить символы пунктуации), но сначала её нужно сгенерировать.
//
// В обычной функции, чтобы объединить результаты из нескольких других функций, мы вызываем их, сохраняем промежуточные результаты, а затем в конце их объединяем.
//
// Для генераторов есть особый синтаксис yield*, который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).
//
// Вот генератор с композицией:
//
// function* generateSequence(start, end) {
//   for (let i = start; i <= end; i++) yield i;
// }
//
// function* generatePasswordCodes() {
//
//   // 0..9
//   yield* generateSequence(48, 57);
//
//   // A..Z
//   yield* generateSequence(65, 90);
//
//   // a..z
//   yield* generateSequence(97, 122);
//
// }
//
// let str = '';
//
// for(let code of generatePasswordCodes()) {
//   str += String.fromCharCode(code);
// }
//
// alert(str); // 0..9A..Za..z
// Директива yield* делегирует выполнение другому генератору. Этот термин означает, что yield* gen перебирает генератор gen и прозрачно направляет его вывод наружу. Как если бы значения были сгенерированы внешним генератором.
//
// Результат – такой же, как если бы мы встроили код из вложенных генераторов:
//
// function* generateSequence(start, end) {
//   for (let i = start; i <= end; i++) yield i;
// }
//
// function* generateAlphaNum() {
//
//   // yield* generateSequence(48, 57);
//   for (let i = 48; i <= 57; i++) yield i;
//
//   // yield* generateSequence(65, 90);
//   for (let i = 65; i <= 90; i++) yield i;
//
//   // yield* generateSequence(97, 122);
//   for (let i = 97; i <= 122; i++) yield i;
//
// }
//
// let str = '';
//
// for(let code of generateAlphaNum()) {
//   str += String.fromCharCode(code);
// }
//
// alert(str); // 0..9a..zA..Z
// Композиция генераторов – естественный способ вставлять вывод одного генератора в поток другого. Она не использует дополнительную память для хранения промежуточных результатов.
//
// yield – дорога в обе стороны
// До этого момента генераторы сильно напоминали перебираемые объекты, со специальным синтаксисом для генерации значений. Но на самом деле они намного мощнее и гибче.
//
// Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.
//
// Чтобы это сделать, нам нужно вызвать generator.next(arg) с аргументом. Этот аргумент становится результатом yield.
//
// Продемонстрируем это на примере:
//
// function* gen() {
//   // Передаём вопрос во внешний код и ожидаем ответа
//   let result = yield "2 + 2 = ?"; // (*)
//
//   alert(result);
// }
//
// let generator = gen();
//
// let question = generator.next().value; // <-- yield возвращает значение
//
// generator.next(4); // --> передаём результат в генератор
//
// Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат первого yield "2+2=?". На этой точке генератор приостанавливает выполнение.
// Затем, как показано на картинке выше, результат yield переходит во внешний код в переменную question.
// При generator.next(4) выполнение генератора возобновляется, а 4 выходит из присваивания как результат: let result = 4.
// Обратите внимание, что внешний код не обязан немедленно вызывать next(4). Ему может потребоваться время. Это не проблема, генератор подождёт.
//
// Например:
//
// // возобновить генератор через некоторое время
// setTimeout(() => generator.next(4), 1000);
// Как видно, в отличие от обычных функций, генератор может обмениваться результатами с вызывающим кодом, передавая значения в next/yield.
//
// Чтобы сделать происходящее более очевидным, вот ещё один пример с большим количеством вызовов:
//
// function* gen() {
//   let ask1 = yield "2 + 2 = ?";
//
//   alert(ask1); // 4
//
//   let ask2 = yield "3 * 3 = ?"
//
//   alert(ask2); // 9
// }
//
// let generator = gen();
//
// alert( generator.next().value ); // "2 + 2 = ?"
//
// alert( generator.next(4).value ); // "3 * 3 = ?"
//
// alert( generator.next(9).done ); // true
// Картинка выполнения:
//
//
// Первый .next() начинает выполнение… Оно доходит до первого yield.
// Результат возвращается во внешний код.
// Второй .next(4) передаёт 4 обратно в генератор как результат первого yield и возобновляет выполнение.
// …Оно доходит до второго yield, который станет результатом .next(4).
// Третий next(9) передаёт 9 в генератор как результат второго yield и возобновляет выполнение, которое завершается окончанием функции, так что done: true.
// Получается такой «пинг-понг»: каждый next(value) передаёт в генератор значение, которое становится результатом текущего yield, возобновляет выполнение и получает выражение из следующего yield.
//
// generator.throw
// Как мы видели в примерах выше, внешний код может передавать значение в генератор как результат yield.
//
// …Но можно передать не только результат, но и инициировать ошибку. Это естественно, так как ошибка является своего рода результатом.
//
// Для того, чтобы передать ошибку в yield, нам нужно вызвать generator.throw(err). В таком случае исключение err возникнет на строке с yield.
//
// Например, здесь yield "2 + 2 = ?" приведёт к ошибке:
//
// function* gen() {
//   try {
//     let result = yield "2 + 2 = ?"; // (1)
//
//     alert("Выполнение программы не дойдёт до этой строки, потому что выше возникнет исключение");
//   } catch(e) {
//     alert(e); // покажет ошибку
//   }
// }
//
// let generator = gen();
//
// let question = generator.next().value;
//
// generator.throw(new Error("Ответ не найден в моей базе данных")); // (2)
// Ошибка, которая проброшена в генератор на строке (2), приводит к исключению на строке (1) с yield. В примере выше try..catch перехватывает её и отображает.
//
// Если мы не хотим перехватывать её, то она, как и любое обычное исключение, «вывалится» из генератора во внешний код.
//
// Текущая строка вызывающего кода – это строка с generator.throw, отмечена (2). Таким образом, мы можем отловить её во внешнем коде, как здесь:
//
// function* generate() {
//   let result = yield "2 + 2 = ?"; // Ошибка в этой строке
// }
//
// let generator = generate();
//
// let question = generator.next().value;
//
// try {
//   generator.throw(new Error("Ответ не найден в моей базе данных"));
// } catch(e) {
//   alert(e); // покажет ошибку
// }
// Если же ошибка и там не перехвачена, то дальше – как обычно, она выпадает наружу и, если не перехвачена, «повалит» скрипт.
//
// Итого
// Генераторы создаются при помощи функций-генераторов function* f(…) {…}.
// Внутри генераторов и только внутри них существует оператор yield.
// Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.
// В современном JavaScript генераторы используются редко. Но иногда они оказываются полезными, потому что способность функции обмениваться данными с вызывающим кодом во время выполнения совершенно уникальна. И, конечно, для создания перебираемых объектов.
//
// Также, в следующей главе мы будем изучать асинхронные генераторы, которые используются, чтобы читать потоки асинхронно сгенерированных данных (например, постранично загружаемые из сети) в цикле for await ... of.
//
// В веб-программировании мы часто работаем с потоками данных, так что это ещё один важный случай использования.















//Асинхронные итераторы и генераторы
// Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда мы загружаем что-то по частям по сети. Асинхронные генераторы делают такой перебор ещё удобнее.
//
// Давайте сначала рассмотрим простой пример, чтобы понять синтаксис, а затем – реальный практический.
//
// Асинхронные итераторы
// Асинхронные итераторы похожи на обычные итераторы, но имеют некоторые синтаксические отличия.
//
// «Обычный» перебираемый объект, как подробно рассказано в главе Перебираемые объекты, выглядит примерно так:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   // for..of вызывает этот метод один раз в самом начале
//   [Symbol.iterator]() {
//     // ...возвращает объект-итератор:
//     // далее for..of работает только с этим объектом, запрашивая следующее значение вызовом next()
//     return {
//       current: this.from,
//       last: this.to,
//
//       // next() вызывается на каждой итерации цикла for..of
//       next() { // (2)
//         // должен возвращать значение в виде объекта {done:.., value :...}
//         if (this.current <= this.last) {
//           return { done: false, value: this.current++ };
//         } else {
//           return { done: true };
//         }
//       }
//     };
//   }
// };
//
// for(let value of range) {
//   alert(value); // 1, потом 2, потом 3, потом 4, потом 5
// }
// Если нужно, пожалуйста, ознакомьтесь с главой про итераторы, где обычные итераторы разбираются подробно.
//
// Чтобы сделать объект итерируемым асинхронно:
//
// Используется Symbol.asyncIterator вместо Symbol.iterator.
// next() должен возвращать промис.
// Чтобы перебрать такой объект, используется цикл for await (let item of iterable).
// Давайте создадим итерируемый объект range, как и в предыдущем примере, но теперь он будет возвращать значения асинхронно, по одному в секунду:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   // for await..of вызывает этот метод один раз в самом начале
//   [Symbol.asyncIterator]() { // (1)
//     // ...возвращает объект-итератор:
//     // далее for await..of работает только с этим объектом,
//     // запрашивая у него следующие значения вызовом next()
//     return {
//       current: this.from,
//       last: this.to,
//
//       // next() вызывается на каждой итерации цикла for await..of
//       async next() { // (2)
//         // должен возвращать значение как объект {done:.., value :...}
//         // (автоматически оборачивается в промис с помощью async)
//
//         // можно использовать await внутри для асинхронности:
//         await new Promise(resolve => setTimeout(resolve, 1000)); // (3)
//
//         if (this.current <= this.last) {
//           return { done: false, value: this.current++ };
//         } else {
//           return { done: true };
//         }
//       }
//     };
//   }
// };
//
// (async () => {
//
//   for await (let value of range) { // (4)
//     alert(value); // 1,2,3,4,5
//   }
//
// })()
// Как видим, структура похожа на обычные итераторы:
//
// Чтобы сделать объект асинхронно итерируемым, он должен иметь метод Symbol.asyncIterator (1).
// Этот метод должен возвращать объект с методом next(), который в свою очередь возвращает промис (2).
// Метод next() не обязательно должен быть async, он может быть обычным методом, возвращающим промис, но async позволяет использовать await, так что это удобно. Здесь мы просто делаем паузу на одну секунду (3).
// Для итерации мы используем for await (let value of range) (4), добавляя «await» после «for». Он вызовет range[Symbol.asyncIterator]() один раз, а затем его метод next() для получения значений.
// Вот небольшая шпаргалка:
//
// Итераторы	Асинхронные итераторы
// Метод для создания итерируемого объекта	Symbol.iterator	Symbol.asyncIterator
// next() возвращает	любое значение	промис
// для цикла используйте	for..of	for await..of
// Оператор расширения ... не работает асинхронно
// Функции, которые требуют обычных синхронных итераторов, не работают с асинхронными.
//
// Например, оператор расширения (три точки ...) не будет работать:
//
// alert( [...range] ); // Ошибка, нет Symbol.iterator
// Это естественно, так как он ожидает Symbol.iterator, как и for..of без await. Ему не подходит Symbol.asyncIterator.
//
// Асинхронные генераторы
// Как мы уже знаем, в JavaScript есть генераторы, и они являются перебираемыми.
//
// Давайте вспомним генератор последовательности из главы Генераторы. Он генерирует последовательность значений от start до end:
//
// function* generateSequence(start, end) {
//   for (let i = start; i <= end; i++) {
//     yield i;
//   }
// }
//
// for(let value of generateSequence(1, 5)) {
//   alert(value); // 1, потом 2, потом 3, потом 4, потом 5
// }
// В обычных генераторах мы не можем использовать await. Все значения должны поступать синхронно: в for..of нет места для задержки, это синхронная конструкция.
//
// Но что если нам нужно использовать await в теле генератора? Для выполнения сетевых запросов, например.
//
// Нет проблем, просто добавьте в начале async, например, вот так:
//
// async function* generateSequence(start, end) {
//
//   for (let i = start; i <= end; i++) {
//
//     // ура, можно использовать await!
//     await new Promise(resolve => setTimeout(resolve, 1000));
//
//     yield i;
//   }
//
// }
//
// (async () => {
//
//   let generator = generateSequence(1, 5);
//   for await (let value of generator) {
//     alert(value); // 1, потом 2, потом 3, потом 4, потом 5
//   }
//
// })();
// Теперь у нас есть асинхронный генератор, который можно перебирать с помощью for await ... of.
//
// Это действительно очень просто. Мы добавляем ключевое слово async, и внутри генератора теперь можно использовать await, а также промисы и другие асинхронные функции.
//
// С технической точки зрения, ещё одно отличие асинхронного генератора заключается в том, что его метод generator.next() теперь тоже асинхронный и возвращает промисы.
//
// Из обычного генератора мы можем получить значения при помощи result = generator.next(). Для асинхронного нужно добавить await, вот так:
//
// result = await generator.next(); // result = {value: ..., done: true/false}
// Асинхронно перебираемые объекты
// Как мы уже знаем, чтобы сделать объект перебираемым, нужно добавить к нему Symbol.iterator.
//
// let range = {
//   from: 1,
//   to: 5,
//   [Symbol.iterator]() {
//     return <объект с next, чтобы сделать range перебираемым>
//   }
// }
// Обычная практика для Symbol.iterator – возвращать генератор, а не простой объект с next, как в предыдущем примере.
//
// Давайте вспомним пример из главы Генераторы:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   *[Symbol.iterator]() { // сокращение для [Symbol.iterator]: function*()
//     for(let value = this.from; value <= this.to; value++) {
//       yield value;
//     }
//   }
// };
//
// for(let value of range) {
//   alert(value); // 1, потом 2, потом 3, потом 4, потом 5
// }
// Здесь созданный объект range является перебираемым, а генератор *[Symbol.iterator] реализует логику для перечисления значений.
//
// Если хотим добавить асинхронные действия в генератор, нужно заменить Symbol.iterator на асинхронный Symbol.asyncIterator:
//
// let range = {
//   from: 1,
//   to: 5,
//
//   async *[Symbol.asyncIterator]() { // то же, что и [Symbol.asyncIterator]: async function*()
//     for(let value = this.from; value <= this.to; value++) {
//
//       // пауза между значениями, ожидание
//       await new Promise(resolve => setTimeout(resolve, 1000));
//
//       yield value;
//     }
//   }
// };
//
// (async () => {
//
//   for await (let value of range) {
//     alert(value); // 1, потом 2, потом 3, потом 4, потом 5
//   }
//
// })();
// Теперь значения поступают с задержкой в одну секунду между ними.
//
// Пример из реальной практики
// До сих пор мы видели простые примеры, чтобы просто получить базовое представление. Теперь давайте рассмотрим реальную ситуацию.
//
// Есть много онлайн-сервисов, которые предоставляют данные постранично. Например, когда нам нужен список пользователей, запрос возвращает предопределённое количество (например, 100) пользователей – «одну страницу», и URL следующей страницы.
//
// Этот подход очень распространён, и речь не только о пользователях, а о чём угодно. Например, GitHub позволяет получать коммиты таким образом, с разбивкой по страницам:
//
// Нужно сделать запрос на URL в виде https://api.github.com/repos/<repo>/commits.
// В ответ придёт JSON с 30 коммитами, а также со ссылкой на следующую страницу в заголовке Link.
// Затем можно использовать эту ссылку для следующего запроса, чтобы получить дополнительную порцию коммитов, и так далее.
// Но нам бы, конечно же, хотелось вместо этого сложного взаимодействия иметь просто объект с коммитами, которые можно перебирать, вот так:
//
// let repo = 'javascript-tutorial/en.javascript.info'; // репозиторий на GitHub, откуда брать коммиты
//
// for await (let commit of fetchCommits(repo)) {
//   // обработка коммитов
// }
// Мы бы хотели сделать функцию fetchCommits(repo), которая будет получать коммиты, делая запросы всякий раз, когда это необходимо. И пусть она сама разбирается со всем, что касается нумерации страниц, для нас это будет просто for await..of.
//
// С асинхронными генераторами это довольно легко реализовать:
//
// async function* fetchCommits(repo) {
//   let url = `https://api.github.com/repos/${repo}/commits`;
//
//   while (url) {
//     const response = await fetch(url, { // (1)
//       headers: {'User-Agent': 'Our script'}, // GitHub требует заголовок user-agent
//     });
//
//     const body = await response.json(); // (2) ответ в формате JSON (массив коммитов)
//
//     // (3) Ссылка на следующую страницу находится в заголовках, извлекаем её
//     let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
//     nextPage = nextPage && nextPage[1];
//
//     url = nextPage;
//
//     for(let commit of body) { // (4) вернуть коммиты один за другим, до окончания страницы
//       yield commit;
//     }
//   }
// }
// Мы используем метод fetch браузера для загрузки с удалённого URL. Он позволяет при необходимости добавлять авторизацию и другие заголовки, здесь GitHub требует User-Agent.
// Результат fetch обрабатывается как JSON, это опять-таки метод, присущий fetch.
// Нужно получить URL следующей страницы из заголовка ответа Link. Он имеет специальный формат, поэтому мы используем регулярное выражение. URL следующей страницы может выглядеть как https://api.github.com/repositories/93253246/commits?page=2, он генерируется самим GitHub.
// Затем мы выдаём все полученные коммиты, а когда они закончатся – сработает следующая итерация while(url), которая сделает ещё один запрос.
// Пример использования (показывает авторов коммитов в консоли):
//
// (async () => {
//
//   let count = 0;
//
//   for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {
//
//     console.log(commit.author.login);
//
//     if (++count == 100) { // остановимся на 100 коммитах
//       break;
//     }
//   }
//
// })();
// Это именно то, что мы хотели. Внутренняя механика постраничных запросов снаружи не видна. Для нас это просто асинхронный генератор, который возвращает коммиты.
//
// Итого
// Обычные итераторы и генераторы прекрасно работают с данными, которые не требуют времени для их создания или получения.
//
// Когда мы ожидаем, что данные будут поступать асинхронно, с задержками, можно использовать их асинхронные аналоги и for await..of вместоfor..of.
//
// Синтаксические различия между асинхронными и обычными итераторами:
//
// Перебираемый объект	Асинхронно перебираемый
// Метод для получения итератора	Symbol.iterator	Symbol.asyncIterator
// next() возвращает	{value:…, done: true/false}	промис, который завершается с {value:…, done: true/false}
// Синтаксические различия между асинхронными и обычными генераторами:
//
// Генераторы	Асинхронные генераторы
// Объявление	function*	async function*
// generator.next() возвращает	{value:…, done: true/false}	промис, который завершается с {value:…, done: true/false}
// В веб-разработке мы часто встречаемся с потоками данных, когда они поступают по частям. Например, загрузка или выгрузка большого файла.
//
// Мы можем использовать асинхронные генераторы для обработки таких данных. Также заметим, что в некоторых окружениях, например, браузерах, есть и другое API, называемое Streams (потоки), который предоставляет специальные интерфейсы для работы с такими потоками данных, их преобразования и передачи из одного потока в другой (например, загрузка из одного источника и сразу отправка в другое место).















//Модули, введение
// По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». Модуль обычно содержит класс или библиотеку с функциями.
//
// Долгое время в JavaScript отсутствовал синтаксис модулей на уровне языка. Это не было проблемой, потому что первые скрипты были маленькими и простыми. В модулях не было необходимости.
//
// Но со временем скрипты становились всё более и более сложными, поэтому сообщество придумало несколько вариантов организации кода в модули. Появились библиотеки для динамической подгрузки модулей.
//
// Например:
//
// AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
// CommonJS – модульная система, созданная для сервера Node.js.
// UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.
// Теперь все они постепенно становятся частью истории, хотя их и можно найти в старых скриптах.
//
// Система модулей на уровне языка появилась в стандарте JavaScript в 2015 году и постепенно эволюционировала. На данный момент она поддерживается большинством браузеров и Node.js. Далее мы будем изучать именно её.
//
// Что такое модуль?
// Модуль – это просто файл. Один скрипт – это один модуль.
//
// Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
//
// export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
// import позволяет импортировать функциональность из других модулей.
// Например, если у нас есть файл sayHi.js, который экспортирует функцию:
//
// // 📁 sayHi.js
// export function sayHi(user) {
//   alert(`Hello, ${user}!`);
// }
// …Тогда другой файл может импортировать её и использовать:
//
// // 📁 main.js
// import {sayHi} from './sayHi.js';
//
// alert(sayHi); // function...
// sayHi('John'); // Hello, John!
// Директива import загружает модуль по пути ./sayHi.js относительно текущего файла и записывает экспортированную функцию sayHi в соответствующую переменную.
//
// Давайте запустим пример в браузере.
//
// Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута <script type="module">.
//
// Вот так:
//
// Результатsay.jsindex.html
// <!doctype html>
// <script type="module">
//   import {sayHi} from './say.js';
//
//   document.body.innerHTML = sayHi('John');
// </script>
// Браузер автоматически загрузит и запустит импортированный модуль (и те, которые он импортирует, если надо), а затем запустит скрипт.
//
// Модули не работают локально. Только через HTTP(s)
// Если вы попытаетесь открыть веб-страницу локально, через протокол file://, вы обнаружите, что директивы import/export не работают. Для тестирования модулей используйте локальный веб-сервер, например, static-server или используйте возможности «живого сервера» вашего редактора, например, расширение Live Server для VS Code.
//
// Основные возможности модулей
// Чем отличаются модули от «обычных» скриптов?
//
// Есть основные возможности и особенности, работающие как в браузере, так и в серверном JavaScript.
//
// Всегда «use strict»
// В модулях всегда используется режим use strict. Например, присваивание к необъявленной переменной вызовет ошибку.
//
// <script type="module">
//   a = 5; // ошибка
// </script>
// Своя область видимости переменных
// Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
//
// В следующем примере импортированы 2 скрипта, и hello.js пытается использовать переменную user, объявленную в user.js. В итоге ошибка:
//
// Результатhello.jsuser.jsindex.html
// <!doctype html>
// <script type="module" src="user.js"></script>
// <script type="module" src="hello.js"></script>
// Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.
//
// Так что нам надо импортировать user.js в hello.js и взять из него нужную функциональность, вместо того чтобы полагаться на глобальные переменные.
//
// Правильный вариант:
//
// Результатhello.jsuser.jsindex.html
// import {user} from './user.js';
//
// document.body.innerHTML = user; // John
// В браузере также существует независимая область видимости для каждого скрипта <script type="module">:
//
// <script type="module">
//   // Переменная доступна только в этом модуле
//   let user = "John";
// </script>
//
// <script type="module">
//   alert(user); // Error: user is not defined
// </script>
// Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.
//
// Код в модуле выполняется только один раз при импорте
// Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
//
// Это очень важно для понимания работы модулей. Давайте посмотрим примеры.
//
// Во-первых, если при запуске модуля возникают побочные эффекты, например выдаётся сообщение, то импорт модуля в нескольких местах покажет его только один раз – при первом импорте:
//
// // 📁 alert.js
// alert("Модуль выполнен!");
// // Импорт одного и того же модуля в разных файлах
//
// // 📁 1.js
// import `./alert.js`; // Модуль выполнен!
//
// // 📁 2.js
// import `./alert.js`; // (ничего не покажет)
// На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.
//
// Теперь более продвинутый пример.
//
// Давайте представим, что модуль экспортирует объект:
//
// // 📁 admin.js
// export let admin = {
//   name: "John"
// };
// Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект admin будет создан и в дальнейшем будет передан всем импортёрам.
//
// Все импортёры получат один-единственный объект admin:
//
// // 📁 1.js
// import {admin} from './admin.js';
// admin.name = "Pete";
//
// // 📁 2.js
// import {admin} from './admin.js';
// alert(admin.name); // Pete
//
// // Оба файла, 1.js и 2.js, импортируют один и тот же объект
// // Изменения, сделанные в 1.js, будут видны в 2.js
// Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте admin, то другие модули тоже увидят эти изменения.
//
// Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.
//
// Например, модуль admin.js предоставляет определённую функциональность, но ожидает передачи учётных данных в объект admin извне:
//
// // 📁 admin.js
// export let admin = { };
//
// export function sayHi() {
//   alert(`Ready to serve, ${admin.name}!`);
// }
// В init.js, первом скрипте нашего приложения, мы установим admin.name. Тогда все это увидят, включая вызовы, сделанные из самого admin.js:
//
// // 📁 init.js
// import {admin} from './admin.js';
// admin.name = "Pete";
// Другой модуль тоже увидит admin.name:
//
// // 📁 other.js
// import {admin, sayHi} from './admin.js';
//
// alert(admin.name); // Pete
//
// sayHi(); // Ready to serve, Pete!
// import.meta
// Объект import.meta содержит информацию о текущем модуле.
//
// Содержимое зависит от окружения. В браузере он содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML:
//
// <script type="module">
//   alert(import.meta.url); // ссылка на html страницу для встроенного скрипта
// </script>
// В модуле «this» не определён
// Это незначительная особенность, но для полноты картины нам нужно упомянуть об этом.
//
// В модуле на верхнем уровне this не определён (undefined).
//
// Сравним с не-модульными скриптами, там this – глобальный объект:
//
// <script>
//   alert(this); // window
// </script>
//
// <script type="module">
//   alert(this); // undefined
// </script>
// Особенности в браузерах
// Есть и несколько других, именно браузерных особенностей скриптов с type="module" по сравнению с обычными скриптами.
//
// Если вы читаете материал в первый раз или, если не собираетесь использовать модули в браузерах, то сейчас можете пропустить эту секцию.
//
// Модули являются отложенными (deferred)
// Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer (описан в главе Скрипты: async, defer). Это верно и для внешних и встроенных скриптов-модулей.
//
// Другими словами:
//
// загрузка внешних модулей, таких как <script type="module" src="...">, не блокирует обработку HTML.
// модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.
// сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
// Как побочный эффект, модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.
//
// Например:
//
// <script type="module">
//   alert(typeof button); // object: скрипт может 'видеть' кнопку под ним
//   // так как модули являются отложенными, то скрипт начнёт выполнятся только после полной загрузки страницы
// </script>
//
// Сравните с обычным скриптом ниже:
//
// <script>
//   alert(typeof button); // Ошибка: кнопка не определена, скрипт не видит элементы под ним
//   // обычные скрипты запускаются сразу, не дожидаясь полной загрузки страницы
// </script>
//
// <button id="button">Кнопка</button>
// Пожалуйста, обратите внимание: второй скрипт выполнится раньше, чем первый! Поэтому мы увидим сначала undefined, а потом object.
//
// Это потому, что модули начинают выполняться после полной загрузки страницы. Обычные скрипты запускаются сразу же, поэтому сообщение из обычного скрипта мы видим первым.
//
// При использовании модулей нам стоит иметь в виду, что HTML-страница будет показана браузером до того, как выполнятся модули и JavaScript-приложение будет готово к работе. Некоторые функции могут ещё не работать. Нам следует разместить «индикатор загрузки» или что-то ещё, чтобы не смутить этим посетителя.
//
// Атрибут async работает во встроенных скриптах
// Для не-модульных скриптов атрибут async работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ.
//
// Для модулей атрибут async работает на любых скриптах.
//
// Например, в скрипте ниже есть async, поэтому он выполнится сразу после загрузки, не ожидая других скриптов.
//
// Скрипт выполнит импорт (загрузит ./analytics.js) и сразу запустится, когда будет готов, даже если HTML документ ещё не будет загружен, или если другие скрипты ещё загружаются.
//
// Это очень полезно, когда модуль ни с чем не связан, например для счётчиков, рекламы, обработчиков событий.
//
// <!-- загружаются зависимости (analytics.js) и скрипт запускается -->
// <!-- модуль не ожидает загрузки документа или других тэгов <script> -->
// <script async type="module">
//   import {counter} from './analytics.js';
//
//   counter.count();
// </script>
// Внешние скрипты
// Внешние скрипты с атрибутом type="module" имеют два отличия:
//
// Внешние скрипты с одинаковым атрибутом src запускаются только один раз:
//
// <!-- скрипт my.js загрузится и будет выполнен только один раз -->
// <script type="module" src="my.js"></script>
// <script type="module" src="my.js"></script>
// Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.
//
// <!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->
// <!-- иначе, скрипт не выполнится -->
// <script type="module" src="http://another-site.com/their.js"></script>
// Это обеспечивает лучшую безопасность по умолчанию.
//
// Не допускаются «голые» модули
// В браузере import должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (bare). Они не разрешены в import.
//
// Например, этот import неправильный:
//
// import {sayHi} from 'sayHi'; // Ошибка, "голый" модуль
// // путь должен быть, например './sayHi.js' или абсолютный
// Другие окружения, например Node.js, допускают использование «голых» модулей, без путей, так как в них есть свои правила, как работать с такими модулями и где их искать. Но браузеры пока не поддерживают «голые» модули.
//
// Совместимость, «nomodule»
// Старые браузеры не понимают атрибут type="module". Скрипты с неизвестным атрибутом type просто игнорируются. Мы можем сделать для них «резервный» скрипт при помощи атрибута nomodule:
//
// <script type="module">
//   alert("Работает в современных браузерах");
// </script>
//
// <script nomodule>
//   alert("Современные браузеры понимают оба атрибута - и type=module, и nomodule, поэтому пропускают этот тег script")
//   alert("Старые браузеры игнорируют скрипты с неизвестным атрибутом type=module, но выполняют этот.");
// </script>
// Инструменты сборки
// В реальной жизни модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например Webpack и после выкладываем код на рабочий сервер.
//
// Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например CSS/HTML-модули.
//
// Сборщик делает следующее:
//
// Берёт «основной» модуль, который мы собираемся поместить в <script type="module"> в HTML.
// Анализирует зависимости (импорты, импорты импортов и так далее)
// Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный import функцией импорта от сборщика, чтобы всё работало. «Специальные» типы модулей, такие как HTML/CSS тоже поддерживаются.
// В процессе могут происходить и другие трансформации и оптимизации кода:
// Недостижимый код удаляется.
// Неиспользуемые экспорты удаляются («tree-shaking»).
// Специфические операторы для разработки, такие как console и debugger, удаляются.
// Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью Babel.
// Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).
// Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют import/export на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута type="module", как обычный скрипт:
//
// <!-- Предположим, что мы собрали bundle.js, используя например утилиту Webpack -->
// <script src="bundle.js"></script>
// Хотя и «как есть» модули тоже можно использовать, а сборщик настроить позже при необходимости.
//
// Итого
// Подводя итог, основные понятия:
//
// Модуль – это файл. Чтобы работал import/export, нужно для браузеров указывать атрибут <script type="module">. У модулей есть ряд особенностей:
// Отложенное (deferred) выполнение по умолчанию.
// Атрибут async работает во встроенных скриптах.
// Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
// Дублирующиеся внешние скрипты игнорируются.
// У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
// В модулях всегда включена директива use strict.
// Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.
// Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.
//
// В реальной жизни часто используется сборщик Webpack, чтобы объединить модули: для производительности и других «плюшек».
//
// В следующей главе мы увидим больше примеров и вариантов импорта/экспорта.









//Экспорт и импорт
// Директивы экспорт и импорт имеют несколько вариантов вызова.
//
// В предыдущей главе мы видели простое использование, давайте теперь посмотрим больше примеров.
//
// Экспорт до объявления
// Мы можем пометить любое объявление как экспортируемое, разместив export перед ним, будь то переменная, функция или класс.
//
// Например, все следующие экспорты допустимы:
//
// // экспорт массива
// export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
//
// // экспорт константы
// export const MODULES_BECAME_STANDARD_YEAR = 2015;
//
// // экспорт класса
// export class User {
//   constructor(name) {
//     this.name = name;
//   }
// }
// Не ставится точка с запятой после экспорта класса/функции
// Обратите внимание, что export перед классом или функцией не делает их функциональным выражением. Это всё также объявление функции, хотя и экспортируемое.
//
// Большинство руководств по стилю кода в JavaScript не рекомендуют ставить точку с запятой после объявлений функций или классов.
//
// Поэтому в конце export class и export function не нужна точка с запятой:
//
// export function sayHi(user) {
//   alert(`Hello, ${user}!`);
// }  // без ; в конце
// Экспорт отдельно от объявления
// Также можно написать export отдельно.
//
// Здесь мы сначала объявляем, а затем экспортируем:
//
// // 📁 say.js
// function sayHi(user) {
//   alert(`Hello, ${user}!`);
// }
//
// function sayBye(user) {
//   alert(`Bye, ${user}!`);
// }
//
// export {sayHi, sayBye}; // список экспортируемых переменных
// …Или, технически, мы также можем расположить export выше функций.
//
// Импорт *
// Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так:
//
// // 📁 main.js
// import {sayHi, sayBye} from './say.js';
//
// sayHi('John'); // Hello, John!
// sayBye('John'); // Bye, John!
// Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например:
//
// // 📁 main.js
// import * as say from './say.js';
//
// say.sayHi('John');
// say.sayBye('John');
// На первый взгляд «импортировать всё» выглядит очень удобно, не надо писать лишнего, зачем нам вообще может понадобиться явно перечислять список того, что нужно импортировать?
//
// Для этого есть несколько причин.
//
// Современные инструменты сборки (webpack и другие) собирают модули вместе и оптимизируют их, ускоряя загрузку и удаляя неиспользуемый код.
//
// Предположим, мы добавили в наш проект стороннюю библиотеку say.js с множеством функций:
//
// // 📁 say.js
// export function sayHi() { ... }
// export function sayBye() { ... }
// export function becomeSilent() { ... }
// Теперь, если из этой библиотеки в проекте мы используем только одну функцию:
//
// // 📁 main.js
// import {sayHi} from './say.js';
// …Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
//
// Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: sayHi() вместо say.sayHi().
//
// Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.
//
// Импорт «как»
// Мы также можем использовать as, чтобы импортировать под другими именами.
//
// Например, для краткости импортируем sayHi в локальную переменную hi, а sayBye импортируем как bye:
//
// // 📁 main.js
// import {sayHi as hi, sayBye as bye} from './say.js';
//
// hi('John'); // Hello, John!
// bye('John'); // Bye, John!
// Экспортировать «как»
// Аналогичный синтаксис существует и для export.
//
// Давайте экспортируем функции, как hi и bye:
//
// // 📁 say.js
// ...
// export {sayHi as hi, sayBye as bye};
// Теперь hi и bye – официальные имена для внешнего кода, их нужно использовать при импорте:
//
// // 📁 main.js
// import * as say from './say.js';
//
// say.hi('John'); // Hello, John!
// say.bye('John'); // Bye, John!
// Экспорт по умолчанию
// На практике модули встречаются в основном одного из двух типов:
//
// Модуль, содержащий библиотеку или набор функций, как say.js выше.
// Модуль, который объявляет что-то одно, например модуль user.js экспортирует только class User.
// По большей части, удобнее второй подход, когда каждая «вещь» находится в своём собственном модуле.
//
// Естественно, требуется много файлов, если для всего делать отдельный модуль, но это не проблема. Так даже удобнее: навигация по проекту становится проще, особенно, если у файлов хорошие имена, и они структурированы по папкам.
//
// Модули предоставляют специальный синтаксис export default («экспорт по умолчанию») для второго подхода.
//
// Ставим export default перед тем, что нужно экспортировать:
//
// // 📁 user.js
// export default class User { // просто добавьте "default"
//   constructor(name) {
//     this.name = name;
//   }
// }
// Заметим, в файле может быть не более одного export default.
//
// …И потом импортируем без фигурных скобок:
//
// // 📁 main.js
// import User from './user.js'; // не {User}, просто User
//
// new User('John');
// Импорты без фигурных скобок выглядят красивее. Обычная ошибка начинающих: забывать про фигурные скобки. Запомним: фигурные скобки необходимы в случае именованных экспортов, для export default они не нужны.
//
// Именованный экспорт	Экспорт по умолчанию
// export class User {...}	export default class User {...}
// import {User} from ...	import User from ...
// Технически в одном модуле может быть как экспорт по умолчанию, так и именованные экспорты, но на практике обычно их не смешивают. То есть, в модуле находятся либо именованные экспорты, либо один экспорт по умолчанию.
//
// Так как в файле может быть максимум один export default, то экспортируемая сущность не обязана иметь имя.
//
// Например, всё это – полностью корректные экспорты по умолчанию:
//
// export default class { // у класса нет имени
//   constructor() { ... }
// }
// export default function(user) { // у функции нет имени
//   alert(`Hello, ${user}!`);
// }
// // экспортируем значение, не создавая переменную
// export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
// Это нормально, потому что может быть только один export default на файл, так что import без фигурных скобок всегда знает, что импортировать.
//
// Без default такой экспорт выдал бы ошибку:
//
// export class { // Ошибка! (необходимо имя, если это не экспорт по умолчанию)
//   constructor() {}
// }
// Имя «default»
// В некоторых ситуациях для обозначения экспорта по умолчанию в качестве имени используется default.
//
// Например, чтобы экспортировать функцию отдельно от её объявления:
//
// function sayHi(user) {
//   alert(`Hello, ${user}!`);
// }
//
// // то же самое, как если бы мы добавили "export default" перед функцией
// export {sayHi as default};
// Или, ещё ситуация, давайте представим следующее: модуль user.js экспортирует одну сущность «по умолчанию» и несколько именованных (редкий, но возможный случай):
//
// // 📁 user.js
// export default class User {
//   constructor(name) {
//     this.name = name;
//   }
// }
//
// export function sayHi(user) {
//   alert(`Hello, ${user}!`);
// }
// Вот как импортировать экспорт по умолчанию вместе с именованным экспортом:
//
// // 📁 main.js
// import {default as User, sayHi} from './user.js';
//
// new User('John');
// И, наконец, если мы импортируем всё как объект import *, тогда его свойство default – как раз и будет экспортом по умолчанию:
//
// // 📁 main.js
// import * as user from './user.js';
//
// let User = user.default; // экспорт по умолчанию
// new User('John');
// Довод против экспортов по умолчанию
// Именованные экспорты «включают в себя» своё имя. Эта информация является частью модуля, говорит нам, что именно экспортируется.
//
// Именованные экспорты вынуждают нас использовать правильное имя при импорте:
//
// import {User} from './user.js';
// // import {MyUser} не сработает, должно быть именно имя {User}
// …В то время как для экспорта по умолчанию мы выбираем любое имя при импорте:
//
// import User from './user.js'; // сработает
// import MyUser from './user.js'; // тоже сработает
// // можно импортировать с любым именем, и это будет работать
// Так что члены команды могут использовать разные имена для импорта одной и той же вещи, и это не очень хорошо.
//
// Обычно, чтобы избежать этого и соблюсти единообразие кода, есть правило: имена импортируемых переменных должны соответствовать именам файлов. Вот так:
//
// import User from './user.js';
// import LoginForm from './loginForm.js';
// import func from '/path/to/func.js';
// ...
// Тем не менее, в некоторых командах это считают серьёзным доводом против экспортов по умолчанию и предпочитают использовать именованные экспорты везде. Даже если экспортируется только одна вещь, она всё равно экспортируется с именем, без использования default.
//
// Это также немного упрощает реэкспорт (смотрите ниже).
//
// Реэкспорт
// Синтаксис «реэкспорта» export ... from ... позволяет импортировать что-то и тут же экспортировать, возможно под другим именем, вот так:
//
// export {sayHi} from './say.js'; // реэкспортировать sayHi
//
// export {default as User} from './user.js'; // реэкспортировать default
// Зачем это нужно? Рассмотрим практический пример использования.
//
// Представим, что мы пишем «пакет»: папку со множеством модулей, из которой часть функциональности экспортируется наружу (инструменты вроде NPM позволяют нам публиковать и распространять такие пакеты), а многие модули – просто вспомогательные, для внутреннего использования в других модулях пакета.
//
// Структура файлов может быть такой:
//
// auth/
//     index.js
//     user.js
//     helpers.js
//     tests/
//         login.js
//     providers/
//         github.js
//         facebook.js
//         ...
// Мы бы хотели сделать функциональность нашего пакета доступной через единую точку входа: «главный файл» auth/index.js. Чтобы можно было использовать её следующим образом:
//
// import {login, logout} from 'auth/index.js'
// Идея в том, что внешние разработчики, которые будут использовать наш пакет, не должны разбираться с его внутренней структурой, рыться в файлах внутри нашего пакета. Всё, что нужно, мы экспортируем в auth/index.js, а остальное скрываем от любопытных взглядов.
//
// Так как нужная функциональность может быть разбросана по модулям нашего пакета, мы можем импортировать их в auth/index.js и тут же экспортировать наружу.
//
// // 📁 auth/index.js
//
// // импортировать login/logout и тут же экспортировать
// import {login, logout} from './helpers.js';
// export {login, logout};
//
// // импортировать экспорт по умолчанию как User и тут же экспортировать
// import User from './user.js';
// export {User};
// ...
// Теперь пользователи нашего пакета могут писать import {login} from "auth/index.js".
//
// Запись export ... from ...– это просто более короткий вариант такого импорта-экспорта:
//
// // 📁 auth/index.js
//
// // импортировать login/logout и тут же экспортировать
// export {login, logout} from './helpers.js';
//
// // импортировать экспорт по умолчанию как User и тут же экспортировать
// export {default as User} from './user.js';
// ...
// Реэкспорт экспорта по умолчанию
// При реэкспорте экспорт по умолчанию нужно обрабатывать особым образом.
//
// Например, у нас есть user.js, из которого мы хотим реэкспортировать класс User:
//
// // 📁 user.js
// export default class User {
//   // ...
// }
// export User from './user.js' не будет работать. Казалось бы, что такого? Но возникнет синтаксическая ошибка!
//
// Чтобы реэкспортировать экспорт по умолчанию, мы должны написать export {default as User}, как в примере выше. Такая вот особенность синтаксиса.
//
// export * from './user.js' реэкспортирует только именованные экспорты, исключая экспорт по умолчанию.
//
// Если мы хотим реэкспортировать и именованные экспорты и экспорт по умолчанию, то понадобятся две инструкции:
//
// export * from './user.js'; // для реэкспорта именованных экспортов
// export {default} from './user.js'; // для реэкспорта по умолчанию
// Такое особое поведение реэкспорта с экспортом по умолчанию – одна из причин того, почему некоторые разработчики их не любят.
//
// Итого
// Вот все варианты export, которые мы разобрали в этой и предыдущей главах.
//
// Вы можете проверить себя, читая их и вспоминая, что они означают:
//
// Перед объявлением класса/функции/…:
// export [default] class/function/variable ...
// Отдельный экспорт:
// export {x [as y], ...}.
// Реэкспорт:
// export {x [as y], ...} from "module"
// export * from "module" (не реэкспортирует export default).
// export {default [as y]} from "module" (реэкспортирует только export default).
// Импорт:
//
// Именованные экспорты из модуля:
// import {x [as y], ...} from "module"
// Импорт по умолчанию:
// import x from "module"
// import {default as x} from "module"
// Всё сразу:
// import * as obj from "module"
// Только подключить модуль (его код запустится), но не присваивать его переменной:
// import "module"
// Мы можем поставить import/export в начало или в конец скрипта, это не имеет значения.
//
// То есть, технически, такая запись вполне корректна:
//
// sayHi();
//
// // ...
//
// import {sayHi} from './say.js'; // импорт в конце файла
// На практике импорты, чаще всего, располагаются в начале файла. Но это только для большего удобства.
//
// Обратите внимание, что инструкции import/export не работают внутри {...}.
//
// Условный импорт, такой как ниже, работать не будет:
//
// if (something) {
//   import {sayHi} from "./say.js"; // Ошибка: импорт должен быть на верхнем уровне
// }
// …Но что, если нам в самом деле нужно импортировать что-либо в зависимости от условий? Или в определённое время? Например, загрузить модуль, только когда он станет нужен?
//
// Мы рассмотрим динамические импорты в следующей главе.













//Динамические импорты
// Инструкции экспорта и импорта, которые мы рассматривали в предыдущей главе, называются «статическими». Синтаксис у них весьма простой и строгий.
//
// Во-первых, мы не можем динамически задавать никакие из параметров import.
//
// Путь к модулю должен быть строковым примитивом и не может быть вызовом функции. Вот так работать не будет:
//
// import ... from getModuleName(); // Ошибка, должна быть строка
// Во-вторых, мы не можем делать импорт в зависимости от условий или в процессе выполнения.
//
// if(...) {
//   import ...; // Ошибка, запрещено
// }
//
// {
//   import ...; // Ошибка, мы не можем ставить импорт в блок
// }
// Всё это следствие того, что цель директив import/export – задать костяк структуры кода. Благодаря им она может быть проанализирована, модули могут быть собраны в один файл специальными инструментами, а неиспользуемые экспорты удалены. Это возможно только благодаря тому, что всё статично.
//
// Но как мы можем импортировать модуль динамически, по запросу?
//
// Выражение import()
// Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
//
// Использовать его мы можем динамически в любом месте кода, например, так:
//
// let modulePath = prompt("Какой модуль загружать?");
//
// import(modulePath)
//   .then(obj => <объект модуля>)
//   .catch(err => <ошибка загрузки, например если нет такого модуля>)
// Или если внутри асинхронной функции, то можно let module = await import(modulePath).
//
// Например, если у нас есть такой модуль say.js:
//
// // 📁 say.js
// export function hi() {
//   alert(`Привет`);
// }
//
// export function bye() {
//   alert(`Пока`);
// }
// …То динамический импорт может выглядеть так:
//
// let {hi, bye} = await import('./say.js');
//
// hi();
// bye();
// А если в say.js указан экспорт по умолчанию:
//
// // 📁 say.js
// export default function() {
//   alert("Module loaded (export default)!");
// }
// …То для доступа к нему нам следует взять свойство default объекта модуля:
//
// let obj = await import('./say.js');
// let say = obj.default;
// // или, одной строкой: let {default: say} = await import('./say.js');
//
// say();
// Вот полный пример:
//
// Результатsay.jsindex.html
// <!doctype html>
// <script>
//   async function load() {
//     let say = await import('./say.js');
//     say.hi(); // Привет!
//     say.bye(); // Пока!
//     say.default(); // Модуль загружен (экспорт по умолчанию)!
//   }
// </script>
// <button onclick="load()">Нажми меня</button>
// На заметку:
// Динамический импорт работает в обычных скриптах, он не требует указания script type="module".
//
// На заметку:
// Хотя import() и выглядит похоже на вызов функции, на самом деле это специальный синтаксис, так же, как, например, super().
//
// Так что мы не можем скопировать import в другую переменную или вызвать при помощи .call/apply. Это не функция.





//Proxy и Reflect
// Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие. Далее мы будем называть такие объекты «прокси».
//
// Прокси используются во многих библиотеках и некоторых браузерных фреймворках. В этой главе мы увидим много случаев применения прокси в решении реальных задач.
//
// Синтаксис:
//
// let proxy = new Proxy(target, handler);
// target – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
// handler – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка get – для чтения свойства из target, ловушка set – для записи свойства в target и так далее.
// При операциях над proxy, если в handler имеется соответствующая «ловушка», то она срабатывает, и прокси имеет возможность по-своему обработать её, иначе операция будет совершена над оригинальным объектом target.
//
// В качестве начального примера создадим прокси без всяких ловушек:
//
// let target = {};
// let proxy = new Proxy(target, {}); // пустой handler
//
// proxy.test = 5; // записываем в прокси (1)
// alert(target.test); // 5, свойство появилось в target!
//
// alert(proxy.test); // 5, мы также можем прочитать его из прокси (2)
//
// for(let key in proxy) alert(key); // test, итерация работает (3)
// Так как нет ловушек, то все операции на proxy применяются к оригинальному объекту target.
//
// Запись свойства proxy.test= устанавливает значение на target.
// Чтение свойства proxy.test возвращает значение из target.
// Итерация по proxy возвращает значения из target.
// Как мы видим, без ловушек proxy является прозрачной обёрткой над target.
//
//
// Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на target.
//
// Чтобы активировать другие его возможности, добавим ловушки.
//
// Что именно мы можем ими перехватить?
//
// Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять. Например, [[Get]] – внутренний метод для чтения свойства, [[Set]] – для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к ним по имени.
//
// Ловушки как раз перехватывают вызовы этих внутренних методов. Полный список методов, которые можно перехватывать, перечислен в спецификации Proxy, а также в таблице ниже.
//
// Для каждого внутреннего метода в этой таблице указана ловушка, то есть имя метода, который мы можем добавить в параметр handler при создании new Proxy, чтобы перехватывать данную операцию:
//
// Внутренний метод	Ловушка	Что вызывает
// [[Get]]	get	чтение свойства
// [[Set]]	set	запись свойства
// [[HasProperty]]	has	оператор in
// [[Delete]]	deleteProperty	оператор delete
// [[Call]]	apply	вызов функции
// [[Construct]]	construct	оператор new
// [[GetPrototypeOf]]	getPrototypeOf	Object.getPrototypeOf
// [[SetPrototypeOf]]	setPrototypeOf	Object.setPrototypeOf
// [[IsExtensible]]	isExtensible	Object.isExtensible
// [[PreventExtensions]]	preventExtensions	Object.preventExtensions
// [[DefineOwnProperty]]	defineProperty	Object.defineProperty, Object.defineProperties
// [[GetOwnProperty]]	getOwnPropertyDescriptor	Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries
// [[OwnPropertyKeys]]	ownKeys	Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries
// Инварианты
// JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.
//
// Большинство из них касаются возвращаемых значений:
//
// Метод [[Set]] должен возвращать true, если значение было успешно записано, иначе false.
// Метод [[Delete]] должен возвращать true, если значение было успешно удалено, иначе false.
// …и так далее, мы увидим больше в примерах ниже.
// Есть и другие инварианты, например:
//
// Метод [[GetPrototypeOf]], применённый к прокси, должен возвращать то же значение, что и метод [[GetPrototypeOf]], применённый к оригинальному объекту. Другими словами, чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.
// Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия.
//
// Инварианты гарантируют корректное и последовательное поведение конструкций и методов языка. Полный список инвариантов можно найти в спецификации, хотя скорее всего вы не нарушите эти условия, если только не соберётесь делать что-то совсем уж странное.
//
// Теперь давайте посмотрим, как это всё работает, на реальных примерах.
//
// Значение по умолчанию с ловушкой «get»
// Чаще всего используются ловушки на чтение/запись свойств.
//
// Чтобы перехватить операцию чтения, handler должен иметь метод get(target, property, receiver).
//
// Он срабатывает при попытке прочитать свойство объекта, с аргументами:
//
// target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
// property – имя свойства,
// receiver – если свойство объекта является геттером, то receiver – это объект, который будет использован как this при его вызове. Обычно это сам объект прокси (или наследующий от него объект). Прямо сейчас нам не понадобится этот аргумент, подробнее разберём его позже.
// Давайте применим ловушку get, чтобы реализовать «значения по умолчанию» для свойств объекта.
//
// Например, сделаем числовой массив, так чтобы при чтении из него несуществующего элемента возвращался 0.
//
// Обычно при чтении из массива несуществующего свойства возвращается undefined, но мы обернём обычный массив в прокси, который перехватывает операцию чтения свойства из массива и возвращает 0, если такого элемента нет:
//
// let numbers = [0, 1, 2];
//
// numbers = new Proxy(numbers, {
//   get(target, prop) {
//     if (prop in target) {
//       return target[prop];
//     } else {
//       return 0; // значение по умолчанию
//     }
//   }
// });
//
// alert( numbers[1] ); // 1
// alert( numbers[123] ); // 0 (нет такого элемента)
// Как видно, это очень легко сделать при помощи ловушки get.
//
// Мы можем использовать Proxy для реализации любой логики возврата значений по умолчанию.
//
// Представим, что у нас есть объект-словарь с фразами на английском и их переводом на испанский:
//
// let dictionary = {
//   'Hello': 'Hola',
//   'Bye': 'Adiós'
// };
//
// alert( dictionary['Hello'] ); // Hola
// alert( dictionary['Welcome'] ); // undefined
// Сейчас, если фразы в dictionary нет, при чтении возвращается undefined. Но на практике оставлять фразы непереведёнными лучше, чем использовать undefined. Поэтому давайте сделаем так, чтобы при отсутствии перевода возвращалась оригинальная фраза на английском вместо undefined.
//
// Чтобы достичь этого, обернём dictionary в прокси, перехватывающий операцию чтения:
//
// let dictionary = {
//   'Hello': 'Hola',
//   'Bye': 'Adiós'
// };
//
// dictionary = new Proxy(dictionary, {
//   get(target, phrase) { // перехватываем чтение свойства в dictionary
//     if (phrase in target) { // если перевод для фразы есть в словаре
//       return target[phrase]; // возвращаем его
//     } else {
//       // иначе возвращаем непереведённую фразу
//       return phrase;
//     }
//   }
// });
//
// // Запросим перевод произвольного выражения в словаре!
// // В худшем случае оно не будет переведено
// alert( dictionary['Hello'] ); // Hola
// alert( dictionary['Welcome to Proxy']); // Welcome to Proxy (нет перевода)
// Прокси следует использовать везде вместо target
// Пожалуйста, обратите внимание: прокси перезаписывает переменную:
//
// dictionary = new Proxy(dictionary, ...);
// Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться.
//
// Валидация с ловушкой «set»
// Допустим, мы хотим сделать массив исключительно для чисел. Если в него добавляется значение иного типа, то это должно приводить к ошибке.
//
// Ловушка set срабатывает, когда происходит запись свойства.
//
// set(target, property, value, receiver):
//
// target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
// property – имя свойства,
// value – значение свойства,
// receiver – аналогично ловушке get, этот аргумент имеет значение, только если свойство – сеттер.
// Ловушка set должна вернуть true, если запись прошла успешно, и false в противном случае (будет сгенерирована ошибка TypeError).
//
// Давайте применим её для проверки новых значений:
//
// let numbers = [];
//
// numbers = new Proxy(numbers, { // (*)
//   set(target, prop, val) { // для перехвата записи свойства
//     if (typeof val == 'number') {
//       target[prop] = val;
//       return true;
//     } else {
//       return false;
//     }
//   }
// });
//
// numbers.push(1); // добавилось успешно
// numbers.push(2); // добавилось успешно
// alert("Длина: " + numbers.length); // 2
//
// numbers.push("тест"); // TypeError (ловушка set на прокси вернула false)
//
// alert("Интерпретатор никогда не доходит до этой строки (из-за ошибки в строке выше)");
// Обратите внимание, что встроенная функциональность массива по-прежнему работает! Значения добавляются методом push. Свойство length при этом увеличивается. Наш прокси ничего не ломает.
//
// Нам не нужно переопределять методы массива push и unshift и другие, чтобы добавлять туда проверку на тип, так как внутри себя они используют операцию [[Set]], которая перехватывается прокси.
//
// Таким образом, код остаётся чистым и прозрачным.
//
// Не забывайте вернуть true
// Как сказано ранее, нужно соблюдать инварианты.
//
// Для set реализация ловушки должна возвращать true в случае успешной записи свойства.
//
// Если забыть это сделать или возвратить любое ложное значение, это приведёт к ошибке TypeError.
//
// Перебор при помощи «ownKeys» и «getOwnPropertyDescriptor»
// Object.keys, цикл for..in и большинство других методов, которые работают со списком свойств объекта, используют внутренний метод [[OwnPropertyKeys]] (перехватываемый ловушкой ownKeys) для их получения.
//
// Такие методы различаются в деталях:
//
// Object.getOwnPropertyNames(obj) возвращает не-символьные ключи.
// Object.getOwnPropertySymbols(obj) возвращает символьные ключи.
// Object.keys/values() возвращает не-символьные ключи/значения с флагом enumerable (подробнее про флаги свойств было в главе Флаги и дескрипторы свойств).
// for..in перебирает не-символьные ключи с флагом enumerable, а также ключи прототипов.
// …Но все они начинают с этого списка.
//
// В примере ниже мы используем ловушку ownKeys, чтобы цикл for..in по объекту, равно как Object.keys и Object.values пропускали свойства, начинающиеся с подчёркивания _:
//
// let user = {
//   name: "Вася",
//   age: 30,
//   _password: "***"
// };
//
// user = new Proxy(user, {
//   ownKeys(target) {
//     return Object.keys(target).filter(key => !key.startsWith('_'));
//   }
// });
//
// // ownKeys исключил _password
// for(let key in user) alert(key); // name, затем: age
//
// // аналогичный эффект для этих методов:
// alert( Object.keys(user) ); // name,age
// alert( Object.values(user) ); // Вася,30
// Как видно, работает.
//
// Впрочем, если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то Object.keys его не выдаст:
//
// let user = { };
//
// user = new Proxy(user, {
//   ownKeys(target) {
//     return ['a', 'b', 'c'];
//   }
// });
//
// alert( Object.keys(user) ); // <пусто>
// Почему? Причина проста: Object.keys возвращает только свойства с флагом enumerable. Для того, чтобы определить, есть ли этот флаг, он для каждого свойства вызывает внутренний метод [[GetOwnProperty]], который получает его дескриптор. А в данном случае свойство отсутствует, его дескриптор пуст, флага enumerable нет, поэтому оно пропускается.
//
// Чтобы Object.keys возвращал свойство, нужно либо чтобы свойство в объекте физически было, причём с флагом enumerable, либо перехватить вызовы [[GetOwnProperty]] (это делает ловушка getOwnPropertyDescriptor), и там вернуть дескриптор с enumerable: true.
//
// Вот так будет работать:
//
// let user = { };
//
// user = new Proxy(user, {
//   ownKeys(target) { // вызывается 1 раз для получения списка свойств
//     return ['a', 'b', 'c'];
//   },
//
//   getOwnPropertyDescriptor(target, prop) { // вызывается для каждого свойства
//     return {
//       enumerable: true,
//       configurable: true
//       /* ...другие флаги, возможно, "value: ..." */
//     };
//   }
//
// });
//
// alert( Object.keys(user) ); // a, b, c
// Ещё раз заметим, что получение дескриптора нужно перехватывать только если свойство отсутствует в самом объекте.
//
// Защищённые свойства с ловушкой «deleteProperty» и другими
// Существует широко распространённое соглашение о том, что свойства и методы, название которых начинается с символа подчёркивания _, следует считать внутренними. К ним не следует обращаться снаружи объекта.
//
// Однако технически это всё равно возможно:
//
// let user = {
//   name: "Вася",
//   _password: "secret"
// };
//
// alert(user._password); // secret
// Давайте применим прокси, чтобы защитить свойства, начинающиеся на _, от доступа извне.
//
// Нам будут нужны следующие ловушки:
//
// get – для того, чтобы сгенерировать ошибку при чтении такого свойства,
// set – для того, чтобы сгенерировать ошибку при записи,
// deleteProperty – для того, чтобы сгенерировать ошибку при удалении,
// ownKeys – для того, чтобы исключить такие свойства из for..in и методов типа Object.keys.
// Вот соответствующий код:
//
// let user = {
//   name: "Вася",
//   _password: "***"
// };
//
// user = new Proxy(user, {
//   get(target, prop) {
//     if (prop.startsWith('_')) {
//       throw new Error("Отказано в доступе");
//     } else {
//       let value = target[prop];
//       return (typeof value === 'function') ? value.bind(target) : value; // (*)
//     }
//   },
//   set(target, prop, val) { // перехватываем запись свойства
//     if (prop.startsWith('_')) {
//       throw new Error("Отказано в доступе");
//     } else {
//       target[prop] = val;
//       return true;
//     }
//   },
//   deleteProperty(target, prop) { // перехватываем удаление свойства
//     if (prop.startsWith('_')) {
//       throw new Error("Отказано в доступе");
//     } else {
//       delete target[prop];
//       return true;
//     }
//   },
//   ownKeys(target) { // перехватываем попытку итерации
//     return Object.keys(target).filter(key => !key.startsWith('_'));
//   }
// });
//
// // "get" не позволяет прочитать _password
// try {
//   alert(user._password); // Error: Отказано в доступе
// } catch(e) { alert(e.message); }
//
// // "set" не позволяет записать _password
// try {
//   user._password = "test"; // Error: Отказано в доступе
// } catch(e) { alert(e.message); }
//
// // "deleteProperty" не позволяет удалить _password
// try {
//   delete user._password; // Error: Отказано в доступе
// } catch(e) { alert(e.message); }
//
// // "ownKeys" исключает _password из списка видимых для итерации свойств
// for(let key in user) alert(key); // name
// Обратите внимание на важную деталь в ловушке get на строке (*):
//
// get(target, prop) {
//   // ...
//   let value = target[prop];
//   return (typeof value === 'function') ? value.bind(target) : value; // (*)
// }
// Зачем для функции вызывать value.bind(target)?
//
// Всё дело в том, что метод самого объекта, например user.checkPassword(), должен иметь доступ к свойству _password:
//
// user = {
//   // ...
//   checkPassword(value) {
//     // метод объекта должен иметь доступ на чтение _password
//     return value === this._password;
//   }
// }
// Вызов user.checkPassword() получает проксированный объект user в качестве this (объект перед точкой становится this), так что когда такой вызов обращается к this._password, ловушка get вступает в действие (она срабатывает при любом чтении свойства), и выбрасывается ошибка.
//
// Поэтому мы привязываем контекст к методам объекта – оригинальный объект target в строке (*). Тогда их дальнейшие вызовы будут использовать target в качестве this, без всяких ловушек.
//
// Такое решение обычно работает, но не является идеальным, поскольку метод может передать оригинальный объект куда-то ещё, и возможна путаница: где изначальный объект, а где – проксированный.
//
// К тому же, объект может проксироваться несколько раз (для добавления различных возможностей), и если передавать методу исходный, то могут быть неожиданности.
//
// Так что везде использовать такой прокси не стоит.
//
// Приватные свойства в классах
// Современные интерпретаторы JavaScript поддерживают приватные свойства в классах. Названия таких свойств должны начинаться с символа #. Они подробно описаны в главе Приватные и защищённые методы и свойства. Для них не нужны подобные прокси.
//
// Впрочем, приватные свойства имеют свои недостатки. В частности, они не наследуются.
//
// «В диапазоне» с ловушкой «has»
// Давайте посмотрим ещё примеры.
//
// Предположим, у нас есть объект range, описывающий диапазон:
//
// let range = {
//   start: 1,
//   end: 10
// };
// Мы бы хотели использовать оператор in, чтобы проверить, что некоторое число находится в указанном диапазоне.
//
// Ловушка has перехватывает вызовы in.
//
// has(target, property)
//
// target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
// property – имя свойства
// Вот демо:
//
// let range = {
//   start: 1,
//   end: 10
// };
//
// range = new Proxy(range, {
//   has(target, prop) {
//     return prop >= target.start && prop <= target.end
//   }
// });
//
// alert(5 in range); // true
// alert(50 in range); // false
// Отлично выглядит, не правда ли? И очень просто в реализации.
//
// Оборачиваем функции: «apply»
// Мы можем оборачивать в прокси и функции.
//
// Ловушка apply(target, thisArg, args) активируется при вызове прокси как функции:
//
// target – это оригинальный объект (как мы помним, функция – это объект в языке JavaScript),
// thisArg – это контекст this.
// args – список аргументов.
// Например, давайте вспомним декоратор delay(f, ms), созданный нами в главе Декораторы и переадресация вызова, call/apply.
//
// Тогда мы обошлись без создания прокси. Вызов delay(f, ms) возвращал функцию, которая передавала вызовы f после ms миллисекунд.
//
// Вот предыдущая реализация, на основе функции:
//
// function delay(f, ms) {
//   // возвращает обёртку, которая вызывает функцию f через таймаут
//   return function() { // (*)
//     setTimeout(() => f.apply(this, arguments), ms);
//   };
// }
//
// function sayHi(user) {
//   alert(`Привет, ${user}!`);
// }
//
// // после обёртки вызовы sayHi будут срабатывать с задержкой в 3 секунды
// sayHi = delay(sayHi, 3000);
//
// sayHi("Вася"); // Привет, Вася! (через 3 секунды)
// Как мы уже видели, это в целом работает. Функция-обёртка в строке (*) вызывает нужную функцию с указанной задержкой.
//
// Но наша функция-обёртка не перенаправляет операции чтения/записи свойства и другие. После обёртывания доступ к свойствам оригинальной функции, таким как name, length, и другим, будет потерян.
//
// function delay(f, ms) {
//   return function() {
//     setTimeout(() => f.apply(this, arguments), ms);
//   };
// }
//
// function sayHi(user) {
//   alert(`Привет, ${user}!`);
// }
//
// alert(sayHi.length); // 1 (в функции length - это число аргументов в её объявлении)
//
// sayHi = delay(sayHi, 3000);
//
// alert(sayHi.length); // 0 (в объявлении функции-обёртки ноль аргументов)
// Прокси куда более мощные в этом смысле, поскольку они перенаправляют всё к оригинальному объекту.
//
// Давайте используем прокси вместо функции-обёртки:
//
// function delay(f, ms) {
//   return new Proxy(f, {
//     apply(target, thisArg, args) {
//       setTimeout(() => target.apply(thisArg, args), ms);
//     }
//   });
// }
//
// function sayHi(user) {
//   alert(`Привет, ${user}!`);
// }
//
// sayHi = delay(sayHi, 3000);
//
// alert(sayHi.length); // 1 (*) прокси перенаправляет чтение свойства length на исходную функцию
//
// sayHi("Вася"); // Привет, Вася! (через 3 секунды)
// Результат такой же, но сейчас не только вызовы, но и другие операции на прокси перенаправляются к оригинальной функции. Таким образом, операция чтения свойства sayHi.length возвращает корректное значение в строке (*) после проксирования.
//
// Мы получили лучшую обёртку.
//
// Существуют и другие ловушки: полный список есть в начале этой главы. Использовать их можно по аналогии с вышеописанными.
//
// Reflect
// Reflect – встроенный объект, упрощающий создание прокси.
//
// Ранее мы говорили о том, что внутренние методы, такие как [[Get]], [[Set]] и другие, существуют только в спецификации, что к ним нельзя обратиться напрямую.
//
// Объект Reflect делает это возможным. Его методы – минимальные обёртки вокруг внутренних методов.
//
// Вот примеры операций и вызовы Reflect, которые делают то же самое:
//
// Операция	Вызов Reflect	Внутренний метод
// obj[prop]	Reflect.get(obj, prop)	[[Get]]
// obj[prop] = value	Reflect.set(obj, prop, value)	[[Set]]
// delete obj[prop]	Reflect.deleteProperty(obj, prop)	[[Delete]]
// new F(value)	Reflect.construct(F, value)	[[Construct]]
// …	…	…
// Например:
//
// let user = {};
//
// Reflect.set(user, 'name', 'Вася');
//
// alert(user.name); // Вася
// В частности, Reflect позволяет вызвать операторы (new, delete…) как функции (Reflect.construct, Reflect.deleteProperty, …). Это интересная возможность, но здесь нам важно другое.
//
// Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.
//
// Поэтому мы можем использовать Reflect, чтобы перенаправить операцию на исходный объект.
//
// В этом примере обе ловушки get и set прозрачно (как будто их нет) перенаправляют операции чтения и записи на объект, при этом выводя сообщение:
//
// let user = {
//   name: "Вася",
// };
//
// user = new Proxy(user, {
//   get(target, prop, receiver) {
//     alert(`GET ${prop}`);
//     return Reflect.get(target, prop, receiver); // (1)
//   },
//   set(target, prop, val, receiver) {
//     alert(`SET ${prop}=${val}`);
//     return Reflect.set(target, prop, val, receiver); // (2)
//   }
// });
//
// let name = user.name; // выводит "GET name"
// user.name = "Петя"; // выводит "SET name=Петя"
// Здесь:
//
// Reflect.get читает свойство объекта.
// Reflect.set записывает свойство и возвращает true при успехе, иначе false.
// То есть, всё очень просто – если ловушка хочет перенаправить вызов на объект, то достаточно вызвать Reflect.<метод> с теми же аргументами.
//
// В большинстве случаев мы можем сделать всё то же самое и без Reflect, например, чтение свойства Reflect.get(target, prop, receiver) можно заменить на target[prop]. Но некоторые нюансы легко упустить.
//
// Прокси для геттера
// Рассмотрим конкретный пример, демонстрирующий, чем лучше Reflect.get, и заодно разберёмся, зачем в get/set нужен третий аргумент receiver, мы его ранее не использовали.
//
// Допустим, у нас есть объект user со свойством _name и геттером для него.
//
// Сделаем вокруг user прокси:
//
// let user = {
//   _name: "Гость",
//   get name() {
//     return this._name;
//   }
// };
//
// let userProxy = new Proxy(user, {
//   get(target, prop, receiver) {
//     return target[prop];
//   }
// });
//
// alert(userProxy.name); // Гость
// Ловушка get здесь «прозрачная», она возвращает свойство исходного объекта и больше ничего не делает. Для нашего примера этого вполне достаточно.
//
// Казалось бы, всё в порядке. Но давайте немного усложним пример.
//
// Если мы унаследуем от проксированного user объект admin, то мы увидим, что он ведёт себя некорректно:
//
// let user = {
//   _name: "Гость",
//   get name() {
//     return this._name;
//   }
// };
//
// let userProxy = new Proxy(user, {
//   get(target, prop, receiver) {
//     return target[prop]; // (*) target = user
//   }
// });
//
// let admin = {
//   __proto__: userProxy,
//   _name: "Админ"
// };
//
// // Ожидается: Админ
// alert(admin.name); // выводится Гость (?!?)
// Обращение к свойству admin.name должно возвращать строку "Админ", а выводит "Гость"!
//
// В чём дело? Может быть, мы делаем что-то не так с наследованием?
//
// Но если убрать прокси, то всё будет работать как ожидается.
//
// На самом деле, проблема в прокси, в строке (*).
//
// При чтении admin.name, так как в объекте admin нет свойства name, оно ищется в прототипе.
//
// Прототипом является прокси userProxy.
//
// При чтении из прокси свойства name срабатывает ловушка get и возвращает его из исходного объекта как target[prop] в строке (*).
//
// Вызов target[prop], если prop – это геттер, запускает его код в контексте this=target. Поэтому результатом является this._name из исходного объекта target, то есть из user.
//
// Именно для исправления таких ситуаций нужен receiver, третий аргумент ловушки get. В нём хранится ссылка на правильный контекст this, который нужно передать геттеру. В данном случае это admin.
//
// Как передать геттеру контекст? Для обычной функции мы могли бы использовать call/apply, но это же геттер, его не вызывают, просто читают значение.
//
// Это может сделать Reflect.get. Всё будет работать верно, если использовать его.
//
// Вот исправленный вариант:
//
// let user = {
//   _name: "Гость",
//   get name() {
//     return this._name;
//   }
// };
//
// let userProxy = new Proxy(user, {
//   get(target, prop, receiver) { // receiver = admin
//     return Reflect.get(target, prop, receiver); // (*)
//   }
// });
//
//
// let admin = {
//   __proto__: userProxy,
//   _name: "Админ"
// };
//
// alert(admin.name); // Админ
// Сейчас receiver, содержащий ссылку на корректный this (то есть на admin), передаётся геттеру посредством Reflect.get в строке (*).
//
// Можно переписать ловушку и короче:
//
// get(target, prop, receiver) {
//   return Reflect.get(...arguments);
// }
// Методы в Reflect имеют те же названия, что и соответствующие ловушки, и принимают такие же аргументы. Это было специально задумано при разработке спецификации JavaScript.
//
// Так что return Reflect... даёт простую и безопасную возможность перенаправить операцию на оригинальный объект и при этом предохраняет нас от возможных ошибок, связанных с этим действием.
//
// Ограничения прокси
// Прокси – уникальное средство для настройки поведения объектов на самом низком уровне. Но они не идеальны, есть некоторые ограничения.
//
// Встроенные объекты: внутренние слоты
// Многие встроенные объекты, например Map, Set, Date, Promise и другие используют так называемые «внутренние слоты».
//
// Это как свойства, но только для внутреннего использования в самой спецификациии. Например, Map хранит элементы во внутреннем слоте [[MapData]]. Встроенные методы обращаются к слотам напрямую, не через [[Get]]/[[Set]]. Таким образом, прокси не может перехватить их.
//
// Почему это имеет значение? Они же всё равно внутренние!
//
// Есть один нюанс. Если встроенный объект проксируется, то в прокси не будет этих «внутренних слотов», так что попытка вызвать на таком прокси встроенный метод приведёт к ошибке.
//
// Пример:
//
// let map = new Map();
//
// let proxy = new Proxy(map, {});
//
// proxy.set('test', 1); // будет ошибка
// Внутри себя объект типа Map хранит все данные во внутреннем слоте [[MapData]]. Прокси не имеет такого слота. Встроенный метод Map.prototype.set пытается получить доступ к своему внутреннему свойству this.[[MapData]], но так как this=proxy, то не может его найти и завершается с ошибкой.
//
// К счастью, есть способ исправить это:
//
// let map = new Map();
//
// let proxy = new Proxy(map, {
//   get(target, prop, receiver) {
//     let value = Reflect.get(...arguments);
//     return typeof value == 'function' ? value.bind(target) : value;
//   }
// });
//
// proxy.set('test', 1);
// alert(proxy.get('test')); // 1 (работает!)
// Сейчас всё сработало, потому что get привязывает свойства-функции, такие как map.set, к оригинальному объекту map. Таким образом, когда реализация метода set попытается получить доступ к внутреннему слоту this.[[MapData]], то всё пройдёт благополучно.
//
// Объект Array не использует внутренние слоты
// Важным исключением является встроенный объект Array: он не использует внутренние слоты. Так сложилось исторически, ведь массивы были добавлены в язык очень давно.
//
// То есть описанная выше проблема не возникает при проксировании массивов.
//
// Приватные поля
// Нечто похожее происходит и с приватными полями классов.
//
// Например, метод getName() осуществляет доступ к приватному полю #name, после проксирования он перестаёт работать:
//
// class User {
//   #name = "Гость";
//
//   getName() {
//     return this.#name;
//   }
// }
//
// let user = new User();
//
// user = new Proxy(user, {});
//
// alert(user.getName()); // Ошибка
// Причина всё та же: приватные поля реализованы с использованием внутренних слотов. JavaScript не использует [[Get]]/[[Set]] при доступе к ним.
//
// В вызове getName() значением this является проксированный user, в котором нет внутреннего слота с приватными полями.
//
// Решением, как и в предыдущем случае, является привязка контекста к методу:
//
// class User {
//   #name = "Гость";
//
//   getName() {
//     return this.#name;
//   }
// }
//
// let user = new User();
//
// user = new Proxy(user, {
//   get(target, prop, receiver) {
//     let value = Reflect.get(...arguments);
//     return typeof value == 'function' ? value.bind(target) : value;
//   }
// });
//
// alert(user.getName()); // Гость
// Однако, такое решение имеет ряд недостатков, о которых уже говорилось: методу передаётся оригинальный объект, который может быть передан куда-то ещё, и это может поломать всю функциональность проксирования.
//
// Прокси != оригинальный объект
// Прокси и объект, который проксируется, являются двумя разными объектами. Это естественно, не правда ли?
//
// Если мы используем оригинальный объект как ключ, а затем проксируем его, то прокси не будет найден:
//
// let allUsers = new Set();
//
// class User {
//   constructor(name) {
//     this.name = name;
//     allUsers.add(this);
//   }
// }
//
// let user = new User("Вася");
//
// alert(allUsers.has(user)); // true
//
// user = new Proxy(user, {});
//
// alert(allUsers.has(user)); // false
// Как мы видим, после проксирования не получается найти объект user внутри множества allUsers, потому что прокси – это другой объект.
//
// Прокси не перехватывают проверку на строгое равенство ===
// Прокси способны перехватывать много операторов, например new (ловушка construct), in (ловушка has), delete (ловушка deleteProperty) и так далее.
//
// Но нет способа перехватить проверку на строгое равенство. Объект строго равен только самому себе, и никаким другим значениям.
//
// Так что все операции и встроенные классы, которые используют строгую проверку объектов на равенство, отличат прокси от изначального объекта. Прозрачной замены в данном случае не произойдёт.
//
// Отключаемые прокси
// Отключаемый (revocable) прокси – это прокси, который может быть отключён вызовом специальной функции.
//
// Допустим, у нас есть какой-то ресурс, и мы бы хотели иметь возможность закрыть к нему доступ в любой момент.
//
// Для того, чтобы решить поставленную задачу, мы можем использовать отключаемый прокси, без ловушек. Такой прокси будет передавать все операции на проксируемый объект, и у нас будет возможность в любой момент отключить это.
//
// Синтаксис:
//
// let {proxy, revoke} = Proxy.revocable(target, handler)
// Вызов возвращает объект с proxy и функцией revoke, которая отключает его.
//
// Вот пример:
//
// let object = {
//   data: "Важные данные"
// };
//
// let {proxy, revoke} = Proxy.revocable(object, {});
//
// // передаём прокси куда-нибудь вместо оригинального объекта...
// alert(proxy.data); // Важные данные
//
// // позже в коде
// revoke();
//
// // прокси больше не работает (отключён)
// alert(proxy.data); // Ошибка
// Вызов revoke() удаляет все внутренние ссылки на оригинальный объект из прокси, так что между ними больше нет связи, и оригинальный объект теперь может быть очищен сборщиком мусора.
//
// Мы можем хранить функцию revoke в WeakMap, чтобы легко найти её по объекту прокси:
//
// let revokes = new WeakMap();
//
// let object = {
//   data: "Важные данные"
// };
//
// let {proxy, revoke} = Proxy.revocable(object, {});
//
// revokes.set(proxy, revoke);
//
// // ..позже в коде..
// revoke = revokes.get(proxy);
// revoke();
//
// alert(proxy.data); // Ошибка (прокси отключён)
// Преимущество такого подхода в том, что мы не должны таскать функцию revoke повсюду. Мы получаем её при необходимости из revokes по объекту прокси.
//
// Мы использовали WeakMap вместо Map, чтобы не блокировать сборку мусора. Если прокси объект становится недостижимым (то есть на него больше нет ссылок), то WeakMap позволяет сборщику мусора удалить его из памяти вместе с соответствующей функцией revoke, которая в этом случае больше не нужна.
//
// Ссылки
// Спецификация: Proxy, Reflect.
// MDN: Proxy, Reflect.
// Итого
// Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их.
//
// Проксировать можно любой объект, включая классы и функции.
//
// Синтаксис:
//
// let proxy = new Proxy(target, {
//   /* ловушки */
// });
// …Затем обычно используют прокси везде вместо оригинального объекта target. Прокси не имеет собственных свойств или методов. Он просто перехватывает операцию, если имеется соответствующая ловушка, а иначе перенаправляет её сразу на объект target.
//
// Мы можем перехватывать:
//
// Чтение (get), запись (set), удаление (deleteProperty) свойства (даже несуществующего).
// Вызов функции (apply).
// Оператор new (ловушка construct).
// И многие другие операции (полный список приведён в начале статьи, а также в документации).
// Это позволяет нам создавать «виртуальные» свойства и методы, реализовывать значения по умолчанию, наблюдаемые объекты, функции-декораторы и многое другое.
//
// Мы также можем оборачивать один и тот же объект много раз в разные прокси, добавляя ему различные аспекты функциональности.
//
// Reflect API создано как дополнение к Proxy. Для любой ловушки из Proxy существует метод в Reflect с теми же аргументами. Нам следует использовать его, если нужно перенаправить вызов на оригинальный объект.
//
// Прокси имеют некоторые ограничения:
//
// Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать. Однако, ранее в этой главе был показан один способ, как обойти это ограничение.
// То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов. То есть вызовы проксированных методов должны иметь оригинальный объект в качестве this, чтобы получить к ним доступ.
// Проверка объектов на строгое равенство === не может быть перехвачена.
// Производительность: конкретные показатели зависят от интерпретатора, но в целом получение свойства с помощью простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение только для некоторых «особо нагруженных» объектов.












//Eval: выполнение строки кода
// Встроенная функция eval позволяет выполнять строку кода.
//
// Синтаксис:
//
// let result = eval(code);
// Например:
//
// let code = 'alert("Привет")';
// eval(code); // Привет
// Строка кода может быть большой, содержать переводы строк, объявления функций, переменные и т.п.
//
// Результатом eval будет результат выполнения последней инструкции.
//
// Например:
//
// let value = eval('1+1');
// alert(value); // 2
// let value = eval('let i = 0; ++i');
// alert(value); // 1
// Код в eval выполняется в текущем лексическом окружении, поэтому ему доступны внешние переменные:
//
// let a = 1;
//
// function f() {
//   let a = 2;
//
//   eval('alert(a)'); // 2
// }
//
// f();
// Значения внешних переменных можно изменять:
//
// let x = 5;
// eval("x = 10");
// alert(x); // 10, значение изменено
// В строгом режиме у eval имеется своё лексическое окружение. Поэтому функции и переменные, объявленные внутри eval, нельзя увидеть снаружи:
//
// // напоминание: режим 'use strict' включён по умолчанию во всех исполняемых примерах
//
// eval("let x = 5; function f() {}");
//
// alert(typeof x); // undefined (нет такой переменной)
// // функция f тоже невидима
// Без use strict у eval не будет отдельного лексического окружения, поэтому x и f будут видны из внешнего кода.
//
// Использование «eval»
// В современной разработке на JavaScript eval используется весьма редко. Есть даже известное выражение – «eval is evil» («eval – это зло»).
//
// Причина такого отношения достаточно проста: давным-давно JavaScript был не очень развитым языком, и многие вещи можно было сделать только с помощью eval. Но та эпоха закончилась более десяти лет назад.
//
// На данный момент нет никаких причин, чтобы продолжать использовать eval. Если кто-то всё ещё делает это, то очень вероятно, что они легко смогут заменить eval более современными конструкциями или JavaScript-модулями.
//
// Пожалуйста, имейте в виду, что код в eval способен получать доступ к внешним переменным, и это может иметь побочные эффекты.
//
// Минификаторы кода (инструменты, используемые для сжатия JS-кода перед тем, как отправить его конечным пользователям) заменяют локальные переменные на другие с более короткими именами для оптимизации. Обычно это безопасная манипуляция, но не тогда, когда в коде используется eval, так как код из eval может изменять значения локальных переменных. Поэтому минификаторы не трогают имена переменных, которые могут быть доступны из eval. Это ухудшает степень сжатия кода.
//
// Использование внутри eval локальных переменных из внешнего кода считается плохим решением, так как это усложняет задачу по поддержке такого кода.
//
// Существует два пути, как гарантированно избежать подобных проблем.
//
// Если код внутри eval не использует внешние переменные, то вызывайте его так – window.eval(...):
//
// В этом случае код выполняется в глобальной области видимости:
//
// let x = 1;
// {
//   let x = 5;
//   window.eval('alert(x)'); // 1 (глобальная переменная)
// }
// Если коду внутри eval нужны локальные переменные, поменяйте eval на new Function и передавайте необходимые данные как аргументы:
//
// let f = new Function('a', 'alert(a)');
//
// f(5); // 5
// Конструкция new Function объясняется в главе Синтаксис "new Function". Она создаёт функцию из строки в глобальной области видимости. Так что локальные переменные для неё невидимы, но всегда можно передать их как аргументы. Получается очень аккуратный код, как в примере выше.
//
// Итого
// Вызов eval(code) выполняет строку кода и возвращает результат последней инструкции.
//
// Это редко используется в современном JavaScript, так как в этом обычно нет необходимости.
// Возможен доступ к внешним локальным переменным. Это считается плохой практикой.
// Чтобы выполнить строку кода с помощью eval в глобальной области видимости, используйте window.eval(code).
// Или же, если ваш код нуждается в каких-то данных из внешней области видимости, то используйте new Function, передав эти данные в качестве аргументов.






//Каррирование
// Каррирование – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.
//
// Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
//
// Каррирование не вызывает функцию. Оно просто трансформирует её.
//
// Давайте сначала посмотрим на пример, чтобы лучше понять, о чём речь, а потом на практическое применение каррирования.
//
// Создадим вспомогательную функцию curry(f), которая выполняет каррирование функции f с двумя аргументами. Другими словами, curry(f) для функции f(a, b) трансформирует её в f(a)(b).
//
// function curry(f) { // curry(f) выполняет каррирование
//   return function(a) {
//     return function(b) {
//       return f(a, b);
//     };
//   };
// }
//
// // использование
// function sum(a, b) {
//   return a + b;
// }
//
// let curriedSum = curry(sum);
//
// alert( curriedSum(1)(2) ); // 3
// Как вы видите, реализация довольна проста: это две обёртки.
//
// Результат curry(func) – обёртка function(a).
// Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
// Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.
// Более продвинутые реализации каррирования, как например _.curry из библиотеки lodash, возвращают обёртку, которая позволяет запустить функцию как обычным образом, так и частично.
//
// function sum(a, b) {
//   return a + b;
// }
//
// let curriedSum = _.curry(sum); // используем _.curry из lodash
//
// alert( curriedSum(1, 2) ); // 3, можно вызывать как обычно
// alert( curriedSum(1)(2) ); // 3, а можно частично
// Каррирование? Зачем?
// Чтобы понять пользу от каррирования, нам определённо нужен пример из реальной жизни.
//
// Например, у нас есть функция логирования log(date, importance, message), которая форматирует и выводит информацию. В реальных проектах у таких функций есть много полезных возможностей, например, посылать логи по сети, здесь для простоты используем alert:
//
// function log(date, importance, message) {
//   alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
// }
// А теперь давайте применим к ней каррирование!
//
// log = _.curry(log);
// После этого log продолжает работать нормально:
//
// log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
// …Но также работает вариант с каррированием:
//
// log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
// Давайте сделаем удобную функцию для логов с текущим временем:
//
// // logNow будет частичным применением функции log с фиксированным первым аргументом
// let logNow = log(new Date());
//
// // используем её
// logNow("INFO", "message"); // [HH:mm] INFO message
// Теперь logNow – это log с фиксированным первым аргументом, иначе говоря, «частично применённая» или «частичная» функция.
//
// Мы можем пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:
//
// let debugNow = logNow("DEBUG");
//
// debugNow("message"); // [HH:mm] DEBUG message
// Итак:
//
// Мы ничего не потеряли после каррирования: log всё так же можно вызывать нормально.
// Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.
// Продвинутая реализация каррирования
// В случае, если вам интересны детали, вот «продвинутая» реализация каррирования для функций с множеством аргументов, которую мы могли бы использовать выше.
//
// Она очень короткая:
//
// function curry(func) {
//
//   return function curried(...args) {
//     if (args.length >= func.length) {
//       return func.apply(this, args);
//     } else {
//       return function(...args2) {
//         return curried.apply(this, args.concat(args2));
//       }
//     }
//   };
//
// }
// Примеры использования:
//
// function sum(a, b, c) {
//   return a + b + c;
// }
//
// let curriedSum = curry(sum);
//
// alert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально
// alert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента
// alert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов
// Новое curry выглядит сложновато, но на самом деле его легко понять.
//
// Результат вызова curry(func) – это обёртка curried, которая выглядит так:
//
// // func -- функция, которую мы трансформируем
// function curried(...args) {
//   if (args.length >= func.length) { // (1)
//     return func.apply(this, args);
//   } else {
//     return function pass(...args2) { // (2)
//       return curried.apply(this, args.concat(args2));
//     }
//   }
// };
// Когда мы запускаем её, есть две ветви выполнения if:
//
// Вызвать сейчас: если количество переданных аргументов args совпадает с количеством аргументов при объявлении функции (func.length) или больше, тогда вызов просто переходит к ней.
// Частичное применение: в противном случае func не вызывается сразу. Вместо этого, возвращается другая обёртка pass, которая снова применит curried, передав предыдущие аргументы вместе с новыми. Затем при новом вызове мы опять получим либо новое частичное применение (если аргументов недостаточно) либо, наконец, результат.
// Например, давайте посмотрим, что произойдёт в случае sum(a, b, c). У неё три аргумента, так что sum.length = 3.
//
// Для вызова curried(1)(2)(3):
//
// Первый вызов curried(1) запоминает 1 в своём лексическом окружении и возвращает обёртку pass.
// Обёртка pass вызывается с (2): она берёт предыдущие аргументы (1), объединяет их с тем, что получила сама (2) и вызывает curried(1, 2) со всеми ними. Так как число аргументов всё ещё меньше 3-х, curry возвращает pass.
// Обёртка pass вызывается снова с (3). Для следующего вызова pass(3) берёт предыдущие аргументы (1, 2) и добавляет к ним 3, делая вызов curried(1, 2, 3) – наконец 3 аргумента, и они передаются оригинальной функции.
// Если всё ещё не понятно, просто распишите последовательность вызовов на бумаге.
//
// Только функции с фиксированным количеством аргументов
// Для каррирования необходима функция с фиксированным количеством аргументов.
//
// Функцию, которая использует остаточные параметры, типа f(...args), так каррировать не получится.
//
// Немного больше, чем каррирование
// По определению, каррирование должно превращать sum(a, b, c) в sum(a)(b)(c).
//
// Но, как было описано, большинство реализаций каррирования в JavaScript более продвинуты: они также оставляют вариант вызова функции с несколькими аргументами.
//
// Итого
// Каррирование – это трансформация, которая превращает вызов f(a, b, c) в f(a)(b)(c). В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.
//
// Каррирование позволяет легко получать частичные функции. Как мы видели в примерах с логами: универсальная функция log(date, importance, message) после каррирования возвращает нам частично применённую функцию, когда вызывается с одним аргументом, как log(date) или двумя аргументами, как log(date, importance).








//Ссылочный тип
// Продвинутая возможность языка
// Эта статья охватывает продвинутую тему, чтобы лучше понять некоторые нестандартные случаи.
//
// Она несильно важна. Многие опытные разработчики прекрасно живут, даже не подозревая об этом. Читайте дальше, если хотите узнать, как все работает под капотом.
//
// Некоторые хитрые способы вызова метода приводят к потере значения this, например:
//
// let user = {
//   name: "Джон",
//   hi() { alert(this.name); },
//   bye() { alert("Пока"); }
// };
//
// user.hi(); // Джон (простой вызов метода работает хорошо)
//
// // теперь давайте попробуем вызывать user.hi или user.bye
// // в зависимости от имени пользователя user.name
// (user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
// В последней строчке кода используется условный оператор ?, который определяет, какой будет вызван метод (user.hi или user.bye) в зависимости от выполнения условия. В данном случае будет выбран user.hi.
//
// Затем метод тут же вызывается с помощью скобок (). Но вызов не работает как положено!
//
// Вы можете видеть, что при вызове будет ошибка, потому что значением "this" внутри функции становится undefined (полагаем, что у нас строгий режим).
//
// Так работает (доступ к методу объекта через точку):
//
// user.hi();
// Так уже не работает (вызываемый метод вычисляется):
//
// (user.name == "John" ? user.hi : user.bye)(); // Ошибка!
// Почему? Если мы хотим понять, почему так происходит, давайте разберёмся (заглянем под капот), как работает вызов методов (obj.method()).
//
// Ссылочный тип: объяснение
// Присмотревшись поближе, в выражении obj.method() можно заметить две операции:
//
// Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
// Затем скобки () вызывают этот метод (исполняется код метода).
// Итак, каким же образом информация о this передаётся из первой части во вторую?
//
// Если мы поместим эти операции в отдельные строки, то значение this, естественно, будет потеряно:
//
// let user = {
//   name: "John",
//   hi() { alert(this.name); }
// };
//
// // разделим получение метода объекта и его вызов в разных строках
// let hi = user.hi;
// hi(); // Ошибка, потому что значением this является undefined
// Здесь hi = user.hi сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.
//
// Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.
//
// Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.
//
// Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:
//
// base – это объект.
// name – это имя свойства объекта.
// strict – это режим исполнения. Является true, если действует строгий режим (use strict).
// Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:
//
// // значение ссылочного типа (Reference Type)
// (user, "hi", true)
// Когда скобки () применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный this (user в данном случае, по base).
//
// Ссылочный тип – исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки . до вызывающих скобок ().
//
// При любой другой операции, например, присваивании hi = user.hi, ссылочный тип заменяется на собственно значение user.hi (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без this.
//
// Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']() (они делают то же самое). Существуют различные способы решения этой проблемы: одним из таких является func.bind().
//
// Итого
// Ссылочный тип – это внутренний тип языка.
//
// Чтение свойства, например, с точкой . в obj.method() возвращает не точное значение свойства, а специальное значение «ссылочного типа», в котором хранится как значение свойства, так и объект, из которого оно было взято.
//
// Это нужно для последующего вызова метода (), чтобы получить объект и установить для него this.
//
// Для всех остальных операций ссылочный тип автоматически становится значением свойства (в нашем случае функцией).
//
// Вся механика скрыта от наших глаз. Это имеет значение только в особых случаях, например, когда метод динамически извлекается из объекта с использованием выражения.















//Побитовые операторы
// Побитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц). Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.
//
// Эта глава требует дополнительных знаний в программировании и не очень важная, при первом чтении вы можете пропустить её и вернуться потом, когда захотите понять, как побитовые операторы работают.
//
// Формат 32-битного целого числа со знаком
// Побитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении.
//
// Это представление называется «32-битное целое со знаком, старшим битом слева и дополнением до двойки».
//
// Разберём, как устроены числа внутри подробнее, это необходимо знать для битовых операций с ними.
//
// Что такое двоичная система счисления, вам, надеюсь, уже известно. При разборе побитовых операций мы будем обсуждать именно двоичное представление чисел, из 32 бит.
//
// Старший бит слева – это научное название для самого обычного порядка записи цифр (от большего разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.
//
// Примеры представления чисел в двоичной системе:
//
// a = 0;  // 00000000000000000000000000000000
// a = 1;  // 00000000000000000000000000000001
// a = 2;  // 00000000000000000000000000000010
// a = 3;  // 00000000000000000000000000000011
// a = 255;// 00000000000000000000000011111111
// Обратите внимание, каждое число состоит ровно из 32-битов.
//
// Дополнение до двойки – это название способа поддержки отрицательных чисел.
//
// Двоичный вид числа, обратного данному (например, 5 и -5) получается путём обращения всех битов с прибавлением 1.
//
// То есть, нули заменяются на единицы, единицы – на нули и к числу прибавляется 1. Получается внутреннее представление того же числа, но со знаком минус.
//
// Например, вот число 314:
//
// 00000000000000000000000100111010
// Чтобы получить -314, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:
//
// 11111111111111111111111011000101
// Второй шаг – к полученному двоичному числу прибавить единицу, обычным двоичным сложением: 11111111111111111111111011000101 + 1 = 11111111111111111111111011000110.
//
// Итак, мы получили:
//
// -314 = 11111111111111111111111011000110
// Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен 0 – число положительное, если 1 – число отрицательное. Поэтому этот бит называется знаковым битом.
//
// Список операторов
// В следующей таблице перечислены все побитовые операторы. Далее операторы разобраны более подробно.
//
// Оператор	Использование	Описание
// Побитовое И (AND)	a & b	Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
// Побитовое ИЛИ (OR)	a | b	Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
// Побитовое исключающее ИЛИ (XOR)	a ^ b	Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
// Побитовое НЕ (NOT)	~a	Заменяет каждый бит операнда на противоположный.
// Левый сдвиг	a << b	Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
// Правый сдвиг, переносящий знак	a >> b	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
// Правый сдвиг с заполнением нулями	a >>> b	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.
// Побитовые операторы работают следующим образом:
//
// Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.
// Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата.
// Получившаяся в результате последовательность бит интерпретируется как обычное число.
// Посмотрим, как работают операторы, на примерах.
//
// Вспомогательные функции parseInt, toString
// Для удобной работы с примерами в этой статье, если вы захотите протестировать что-то в консоли, пригодятся две функции.
//
// parseInt("11000", 2) – переводит строку с двоичной записью числа в число.
// n.toString(2) – получает для числа n запись в 2-ной системе в виде строки.
// Например:
//
// let access = parseInt("11000", 2); // получаем число из строки
//
// alert( access ); // 24, число с таким 2-ным представлением
//
// let access2 = access.toString(2); // обратно двоичную строку из числа
//
// alert( access2 ); // 11000
// Без них перевод в двоичную систему и обратно был бы куда менее удобен. Более подробно они разбираются в главе Числа.
//
// & (Побитовое И)
// Выполняет операцию И над каждой парой бит.
//
// Результат a & b равен единице только когда оба бита a и b равны единице.
//
// Таблица истинности для &:
//
// a	b	a & b
// 0	0	0
// 0	1	0
// 1	0	0
// 1	1	1
// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 & 9 (по осн. 10)
//   = 00000000000000000000000000001000 (по осн. 2)
//   = 8 (по осн. 10)
// | (Побитовое ИЛИ)
// Выполняет операцию ИЛИ над каждой парой бит. Результат a | b равен 1, если хотя бы один бит из a,b равен 1.
//
// Таблица истинности для |:
//
// a	b	a | b
// 0	0	0
// 0	1	1
// 1	0	1
// 1	1	1
// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 | 9 (по осн. 10)
//   = 00000000000000000000000000001111 (по осн. 2)
//   = 15 (по осн. 10)
// ^ (Исключающее ИЛИ)
// Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.
//
// a Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1.
//
// Таблица истинности для исключающего ИЛИ:
//
// a	b	a ^ b
// 0	0	0
// 0	1	1
// 1	0	1
// 1	1	0
// Как видно, оно даёт 1, если ЛИБО слева 1, ЛИБО справа 1, но не одновременно. Поэтому его и называют «исключающее ИЛИ».
//
// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 ^ 9 (по осн. 10)
//   = 00000000000000000000000000000111 (по осн. 2)
//   = 7 (по осн. 10)
// Исключающее ИЛИ в шифровании
// Исключающее или можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.
//
// Иначе говоря, верна формула: a ^ b ^ b == a.
//
// Пусть Вася хочет передать Пете секретную информацию data. Эта информация заранее превращена в число, например строка интерпретируется как последовательность кодов символов.
//
// Вася и Петя заранее договариваются о числовом ключе шифрования key.
//
// Алгоритм:
//
// Вася берёт двоичное представление data и делает операцию data ^ key. При необходимости data бьётся на части, равные по длине key, чтобы можно было провести побитовое ИЛИ ^ для каждой части. В JavaScript оператор ^ работает с 32-битными целыми числами, так что data нужно разбить на последовательность таких чисел.
// Результат data ^ key отправляется Пете, это шифровка.
// Например, пусть в data очередное число равно 9, а ключ key равен 1220461917.
//
// Данные: 9 в двоичном виде
// 00000000000000000000000000001001
//
// Ключ: 1220461917 в двоичном виде
// 01001000101111101100010101011101
//
// Результат операции 9 ^ key:
// 01001000101111101100010101010100
// Результат в 10-ной системе (шифровка):
// 1220461908
// Петя, получив очередное число шифровки 1220461908, применяет к нему такую же операцию ^ key.
// Результатом будет исходное число data.
// В нашем случае:
//
// Полученная шифровка в двоичной системе:
// 9 ^ key = 1220461908
// 01001000101111101100010101010100
//
// Ключ: 1220461917 в двоичном виде:
// 01001000101111101100010101011101
//
// Результат операции 1220461917 ^ key:
// 00000000000000000000000000001001
// Результат в 10-ной системе (исходное сообщение):
// 9
// Конечно, такое шифрование поддаётся частотному анализу и другим методам дешифровки, поэтому современные алгоритмы используют операцию XOR ^ как одну из важных частей более сложной многоступенчатой схемы.
//
// ~ (Побитовое НЕ)
// Производит операцию НЕ над каждым битом, заменяя его на обратный ему.
//
// Таблица истинности для НЕ:
//
// a	~a
// 0	1
// 1	0
// Пример:
//
//  9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
//                --------------------------------
// ~9 (по осн. 10)
//   = 11111111111111111111111111110110 (по осн. 2)
//   = -10 (по осн. 10)
// Из-за внутреннего представления отрицательных чисел получается так, что ~n == -(n+1).
//
// Например:
//
// alert( ~3 ); // -4
// alert( ~-1 ); // 0
// << (Битовый сдвиг влево)
// Операторы битового сдвига принимают два операнда. Первый – это число для сдвига, а второй – количество битов, которые нужно сдвинуть в первом операнде.
//
// Оператор << сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.
//
// Например, 9 << 2 даст 36:
//
// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 9 << 2 (по осн.10)
//   = 00000000000000000000000000100100 (по осн.2)
//   = 36 (по осн.10)
// Операция << 2 сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.
//
// Левый сдвиг почти равен умножению на 2
// Битовый сдвиг << N обычно имеет тот же эффект, что и умножение на два N раз, например:
//
// alert( 3 << 1 ); // 6, умножение на 2
// alert( 3 << 2 ); // 12, умножение на 2 два раза
// alert( 3 << 3 ); // 24, умножение на 2 три раза
// Конечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому верхний порог такого «умножения» ограничен:
//
// alert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит
// alert(10000000000 * 2); // 20000000000, обычное умножение
// >> (Правый битовый сдвиг, переносящий знак)
// Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия крайнего-левого бита.
//
// Знак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый бит имеет то же значение, что и в исходном числе.
//
// Поэтому он назван «переносящим знак».
//
// Например, 9 >> 2 даст 2:
//
// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 9 >> 2 (по осн.10)
//   = 00000000000000000000000000000010 (по осн.2)
//   = 2 (по осн.10)
// Операция >> 2 сдвинула вправо и отбросила два правых бита 01 и добавила слева две копии первого бита 00.
//
// Аналогично, -9 >> 2 даст -3:
//
// -9 (по осн.10)
//   = 11111111111111111111111111110111 (по осн.2)
//                    --------------------------------
// -9 >> 2 (по осн.10)
//   = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)
// Здесь операция >> 2 сдвинула вправо и отбросила два правых бита 11 и добавила слева две копии первого бита 11. , Знак числа сохранён, так как крайний-левый (знаковый) бит сохранил значение 1.
//
// Правый сдвиг почти равен целочисленному делению на 2
// Битовый сдвиг >> N обычно имеет тот же результат, что и целочисленное деление на два N раз:
//
// alert( 100 >> 1 ); // 50, деление на 2
// alert( 100 >> 2 ); // 25, деление на 2 два раза
// alert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата
// >>> (Правый сдвиг с заполнением нулями)
// Этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.
//
// Знаковый бит становится равным 0, поэтому результат всегда положителен.
//
// Для неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к. в обоих случаях слева добавятся нули.
//
// Для отрицательных чисел – результат работы разный. Например, -9 >>> 2 даст 1073741821, в отличие от -9 >> 2 (даёт -3):
//
// -9 (по осн.10)
//   = 11111111111111111111111111110111 (по осн.2)
//                     --------------------------------
// -9 >>> 2 (по осн.10)
//   = 00111111111111111111111111111101 (по осн.2)
//   = 1073741821 (по осн.10)
// Применение побитовых операторов
// Побитовые операторы используются редко, но всё же используются.
//
// Случаи применения побитовых операторов, которые мы здесь разберём, составляют большинство всех использований в JavaScript.
//
// Осторожно, приоритеты!
// В JavaScript побитовые операторы ^, &, | выполняются после сравнений ==.
//
// Например, в сравнении a == b^0 будет сначала выполнено сравнение a == b, а потом уже операция ^0, как будто стоят скобки (a == b)^0.
//
// Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: a == (b^0).
//
// Маска
// Для этого примера представим, что наш скрипт работает с пользователями.
//
// У них могут быть различные роли в проекте:
//
// Гость
// Редактор
// Админ
// Каждой роли соответствует ряд доступов к статьям и функциональности сайта.
//
// Например, Гость может лишь просматривать статьи сайта, а Редактор – ещё и редактировать их, и тому подобное.
//
// Что-то в таком духе:
//
// Пользователь	Просмотр статей	Изменение статей	Просмотр товаров	Изменение товаров	Управление правами
// Гость	Да	Нет	Да	Нет	Нет
// Редактор	Да	Да	Да	Да	Нет
// Админ	Да	Да	Да	Да	Да
// Если вместо «Да» поставить 1, а вместо «Нет» – 0, то каждый набор доступов описывается числом:
//
// Пользователь	Просмотр статей	Изменение статей	Просмотр товаров	Изменение товаров	Управление правами	В 10-ной системе
// Гость	1	0	1	0	0	= 20
// Редактор	1	1	1	1	0	= 30
// Админ	1	1	1	1	1	= 31
// В последней колонке находится десятичное число, которое получится, если прочитать строку доступов в двоичном виде.
//
// Например, доступ гостя 10100 = 20.
//
// Такая интерпретация доступов позволяет «упаковать» много информации в одно число. Это экономит память, а кроме этого – это удобно, поскольку в дополнение к экономии – по такому значению очень легко проверить, имеет ли посетитель заданную комбинацию доступов!
//
// Для этого посмотрим, как в 2-ной системе представляется каждый доступ в отдельности.
//
// Доступ, соответствующий только управлению правами: 00001 (=1) (все нули кроме 1 на позиции, соответствующей этому доступу).
// Доступ, соответствующий только изменению товаров: 00010 (=2).
// Доступ, соответствующий только просмотру товаров: 00100 (=4).
// Доступ, соответствующий только изменению статей: 01000 (=8).
// Доступ, соответствующий только просмотру статей: 10000 (=16).
// Доступ одновременно на просмотр и изменение статей – это двоичное число с 1 на соответствующих позициях, то есть access = 11000.
//
// Как правило, доступы задаются в виде констант:
//
// const ACCESS_ADMIN = 1;          // 00001
// const ACCESS_GOODS_EDIT = 2;   // 00010
// const ACCESS_GOODS_VIEW = 4;     // 00100
// const ACCESS_ARTICLE_EDIT = 8; // 01000
// const ACCESS_ARTICLE_VIEW = 16;  // 10000
// Из этих констант получить нужную комбинацию доступов можно при помощи операции |.
//
// const guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100
// const editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110
// const admin = editor | ACCESS_ADMIN; // 11111
// Теперь, чтобы понять, есть ли в доступе editor нужный доступ, например управление правами – достаточно применить к нему побитовый оператор И (&) с соответствующей константой.
//
// Ненулевой результат будет означать, что доступ есть:
//
// alert(editor & ACCESS_ADMIN); // 0, доступа нет
// alert(editor & ACCESS_ARTICLE_EDIT); // 8, доступ есть
// Такая проверка работает, потому что оператор И ставит 1 на те позиции результата, на которых в обоих операндах стоит 1.
//
// Можно проверить один из нескольких доступов.
//
// Например, проверим, есть ли права на просмотр ИЛИ изменение товаров. Соответствующие права задаются битом 1 на втором и третьем месте с конца, что даёт число 00110 (=6 в 10-ной системе).
//
// const check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT; // 6, 00110
//
// alert( admin & check ); // не 0, значит есть доступ к просмотру ИЛИ изменению
// Битовой маской называют как раз комбинацию двоичных значений (check в примере выше), которая используется для проверки и выборки единиц на нужных позициях.
//
// Маски могут быть весьма удобны.
//
// В частности, их используют в функциях, чтобы одним параметром передать несколько «флагов», т.е. однобитных значений.
//
// Пример вызова функции с маской:
//
// // найти пользователей с правами на изменение товаров или администраторов
// findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);
// Это довольно-таки коротко и элегантно, но, вместе с тем, применение масок налагает определённые ограничения. В частности, побитовые операторы в JavaScript работают только с 32-битными числами, а значит, к примеру, 33 доступа уже в число не упакуешь. Да и работа с двоичной системой счисления – как ни крути, менее удобна, чем с десятичной или с обычными логическими значениями true/false.
//
// Поэтому основная сфера применения масок – это быстрые вычисления, экономия памяти, низкоуровневые операции, связанные с рисованием из JavaScript (3d-графика), интеграция с некоторыми функциями ОС (для серверного JavaScript), и другие ситуации, когда уже существуют функции, требующие битовую маску.
//
// Округление
// Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления. Достаточно взять любую операцию, которая не меняет значение числа.
//
// Например, двойное НЕ (~):
//
// alert( ~~12.345 ); // 12
// Подойдёт и Исключающее ИЛИ (^) с нулём:
//
// alert( 12.345 ^ 0 ); // 12
// Последнее даже более удобно, поскольку отлично читается:
//
// alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"
// У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики:
//
// alert( 1.1 + 1.2 ^ 0 ); // 2, сложение выполнится раньше округления
// Проверка на −1
// Внутренний формат 32-битных чисел устроен так, что для смены знака нужно все биты заменить на противоположные («обратить») и прибавить 1.
//
// Обращение битов – это побитовое НЕ (~). То есть, при таком формате представления числа -n = ~n + 1. Или, если перенести единицу: ~n = -(n+1).
//
// Как видно из последнего равенства, ~n == 0 только если n == -1. Поэтому можно легко проверить равенство n == -1:
//
// let n = 5;
//
// if (~n) { // сработает, т.к. ~n = -(5+1) = -6
//   alert( "n не -1" ); // выведет!
// }
// let n = -1;
//
// if (~n) { // не сработает, т.к. ~n = -(-1+1) = 0
//   alert( "...ничего не выведет..." );
// }
// Проверка на -1 пригождается, например, при поиске символа в строке. Вызов str.indexOf("подстрока") возвращает позицию подстроки в str, или -1 если не нашёл.
//
// let str = "Проверка";
//
// if (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"
//   alert( 'найдено!' );
// }
// Умножение и деление на степени 2
// Оператор a << b, сдвигая биты, по сути умножает a на 2 в степени b.
//
// Например:
//
// alert( 1 << 2 ); // 1*(2*2) = 4
// alert( 1 << 3 ); // 1*(2*2*2) = 8
// alert( 3 << 3 ); // 3*(2*2*2) = 24
// При этом следует иметь в виду, что максимальный верхний порог такого умножения меньше, чем обычно, так как побитовый оператор манипулирует 32-битными целыми, в то время как обычные операторы работают с числами длиной 64 бита.
//
// Оператор сдвига в другую сторону a >> b, производит обратную операцию – целочисленное деление a на 2b.
//
// alert( 8 >> 2 ); // 2 = 8/4, убрали 2 нуля в двоичном представлении
// alert( 11 >> 2 ); // 2, целочисленное деление (менее значимые биты просто отброшены)
// Итого
// Бинарные побитовые операторы: & | ^ << >> >>>.
// Унарный побитовый оператор один: ~.
// Как правило, битовое представление числа используется для:
//
// Округления числа: (12.34^0) = 12.
// Проверки на равенство -1: if (~n) { n не -1 }.
// Упаковки нескольких битовых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором &.
// Других ситуаций, когда нужны битовые маски.













//BigInt
// Новая возможность
// Эта возможность была добавлена в язык недавно. Узнать, где есть поддержка, можно на https://caniuse.com/#feat=bigint.
// BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.
//
// Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала или вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др.
//
// const bigint = 1234567890123456789012345678901234567890n;
//
// const sameBigint = BigInt("1234567890123456789012345678901234567890");
//
// const bigintFromNumber = BigInt(10); // то же самое, что и 10n
// Математические операторы
// BigInt можно использовать как обычные числа, к примеру:
//
// alert(1n + 2n); // 3
//
// alert(5n / 2n); // 2
// Обратите внимание: операция деления 5/2 возвращает округлённый результат, без дробной части. Все операции с числами типа bigint возвращают bigint.
//
// В математических операциях мы не можем смешивать bigint и обычные числа:
//
// alert(1n + 2); // Error: Cannot mix BigInt and other types
// Мы должны явно их конвертировать: используя либо BigInt(), либо Number(), например:
//
// let bigint = 1n;
// let number = 2;
//
// // конвертируем number в bigint
// alert(bigint + BigInt(number)); // 3
//
// // конвертируем `bigint` в number
// alert(Number(bigint) + number); // 3
// Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.
//
// К BigInt числам нельзя применить унарный оператор +
// Унарный оператор +value является хорошо известным способом конвертировать произвольное значение value в число.
//
// Данный оператор не поддерживается при работе с BigInt числами:
//
// let bigint = 1n;
//
// alert( +bigint ); // Ошибка!
// Мы должны использовать Number() для преобразования bigint к number.
//
// Операции сравнения
// Операции сравнения, такие как <, >, работают с bigint и обычными числами как обычно:
//
// alert( 2n > 1n ); // true
//
// alert( 2n > 1 ); // true
// Пожалуйста, обратите внимание, что обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==:
//
// alert( 1 == 1n ); // true
//
// alert( 1 === 1n ); // false
// Логические операции
// В if или любом другом логическом операторе bigint число ведёт себя как обычное число.
//
// К примеру, в if bigint 0n преобразуется в false, другие значения преобразуются в true:
//
// if (0n) {
//   // никогда не выполнится
// }
// Логические операторы ||, && и другие также работают с bigint числами как с обычными числами:
//
// alert( 1n || 2 ); // 1
//
// alert( 0n || 2 ); // 2
// Полифилы
// Создание полифила для BigInt – достаточно непростая задача. Причина в том, что многие операторы в JavaScript, такие как +, - и др., ведут себя по-разному с bigint по сравнению с обычными числами.
//
// К примеру, деление bigint числа всегда возвращает bigint (округлённое при необходимости).
//
// Чтобы эмулировать такое поведение, полифил должен будет проанализировать код и заменить все такие операторы на свои вызовы. Такая реализация будет тяжеловесной, не очень хорошей с точки зрения производительности.
//
// Вот почему на данный момент нет хорошо реализованного полифила.
//
// Существует обратное решение, предложеное разработчиками библиотеки JSBI.
//
// Эта библиотека реализует большие числа, используя собственные методы. Мы можем использовать их вместо встроенных BigInt:
//
// Операция	Встроенный BigInt	JSBI
// Создание из number	a = BigInt(789)	a = JSBI.BigInt(789)
// Сложение	c = a + b	c = JSBI.add(a, b)
// Вычитание	c = a - b	c = JSBI.subtract(a, b)
// …	…	…
// …А затем использовать полифил (плагин Babel) для замены вызовов JSBI на встроенные Bigint для браузеров, которые их поддерживают.
//
// Другими словами, данный подход предлагает использовать JSBI вместо встроенных BigInt. JSBI внутри себя работает с числами как с BigInt, эмулирует их с соблюдением всех требований спецификации. Таким образом, мы можем выполнять JSBI-код в интерпретаторах, которые не поддерживают Bigint, а для тех, которые поддерживают – полифил преобразует вызовы в обычные Bigint.
//
// Ссылки
// MDN: BigInt.
// Спецификация: BigInt.








//Юникод, внутреннее устройство строк
// Глубокое погружение в тему
// Этот раздел более подробно описывает, как устроены строки. Такие знания пригодятся, если вы намерены работать с эмодзи, редкими математическими символами, иероглифами, и т.д.
//
// Как мы уже знаем, строки в JavaScript основаны на Юникоде: каждый символ представляет из себя последовательность байтов из 1-4 байтов.
//
// JavaScript позволяет нам вставить символ в строку, указав его шестнадцатеричный Юникод с помощью одной из этих трех нотаций:
//
// \xXX
//
// Вместо XX должны быть указаны две шестнадцатеричные цифры со значением от 00 до FF. В этом случае \xXX – это символ, Юникод которого равен XX.
//
// Поскольку нотация \xXX поддерживает только две шестнадцатеричные цифры, ее можно использовать только для первых 256 символов Юникода.
//
// Эти 256 символов включают в себя латинский алфавит, большинство основных синтаксических символов и некоторые другие. Например, "\x7A" – это то же самое, что "z" (Юникод U+007A).
//
// alert( "\x7A" ); // z
// alert( "\xA9" ); // ©, символ авторского права
// \uXXXX
//
// Вместо XXXX должны быть указаны ровно 4 шестнадцатеричные цифры со значением от 0000 до FFFF. В этом случае \uXXXX – это символ, Юникод которого равен XXXX.
//
// Символы со значениями Юникода, превышающими U+FFFF, также могут быть представлены с помощью этой нотации, но в таком случае нам придется использовать так называемую суррогатную пару (о ней мы поговорим позже в этой главе).
//
// alert( "\u00A9" ); // ©, то же самое, что \xA9, используя 4-значную шестнадцатеричную нотацию
// alert( "\u044F" ); // я, буква кириллического алфавита
// alert( "\u2191" ); // ↑, символ стрелки вверх
// \u{X…XXXXXX}
//
// Вместо X…XXXXXX должно быть шестнадцатеричное значение от 1 до 6 байт от 0 до 10FFFF (максимальная точка кода, определенная стандартом Юникод). Эта нотация позволяет нам легко представлять все существующие символы Юникода.
//
// alert( "\u{20331}" ); // 佫, редкий китайский иероглиф (длинный Юникод)
// alert( "\u{1F60D}" ); // 😍, символ улыбающегося лица (ещё один длинный Юникод)
// Суррогатные пары
// Все часто используемые символы имеют 2-байтовые коды (4 шестнадцатеричные цифры). В большинстве европейских языков буквы, цифры и основные унифицированные идеографические наборы CJK (CJK – от китайской, японской и корейской систем письма) имеют 2-байтовое представление.
//
// Изначально JavaScript был основан на кодировке UTF-16, которая предусматривала только 2 байта на один символ. Однако 2 байта допускают только 65536 комбинаций, и этого недостаточно для всех возможных символов Юникода.
//
// Поэтому редкие символы, требующие более 2 байт, кодируются парой 2-байтовых символов, которые называются «суррогатной парой».
//
// Побочным эффектом является то, что длина таких символов равна 2:
//
// alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
// alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
// alert( '𩷶'.length ); // 2, редкий китайский иероглиф
// Это происходит потому, что суррогатные пары не существовали в то время, когда был создан JavaScript, и поэтому они не обрабатываются языком корректно.
//
// На самом деле в каждой из приведенных строк у нас по одному символу, но свойство length показывает длину 2.
//
// Получить такой символ также может быть непросто, поскольку большинство языковых функций рассматривают суррогатные пары как два символа.
//
// Например, здесь мы видим два странных символа в выводе:
//
// alert( '𝒳'[0] ); // показывает странные символы...
// alert( '𝒳'[1] ); // ...части суррогатной пары
// Части суррогатной пары не имеют никакого значения друг без друга.
//
// Технически, суррогатные пары также можно определить по их кодам: если символ имеет код в интервале 0xd800...0xdbff, то он является первой частью суррогатной пары. Следующий символ (вторая часть) должен иметь код в интервале 0xdc00...0xdfff. Эти интервалы зарезервированы стандартом исключительно для суррогатных пар.
//
// Поэтому для работы с суррогатными парами в JavaScript были добавлены методы String.fromCodePoint и str.codePointAt.
//
// По сути, они аналогичны String.fromCharCode и str.charCodeAt, но они правильно обрабатывают суррогатные пары.
//
// Здесь можно увидеть разницу:
//
// // charCodeAt не учитывает суррогатные пары, поэтому он выдает коды для 1-й части 𝒳:
//
// alert( '𝒳'.charCodeAt(0).toString(16) ); // d835
//
// // codePointAt учитывает суррогатные пары
// alert( '𝒳'.codePointAt(0).toString(16) ); // 1d4b3, считывает обе части суррогатной пары
// При этом, если брать с позиции 1 (а это здесь скорее неверно), то они оба возвращают только 2-ю часть пары:
//
// alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3
// alert( '𝒳'.codePointAt(1).toString(16) ); // dcb3
// // бессмысленная 2-я половина пары
// Другие способы работы с суррогатными парами вы найдете в главе Перебираемые объекты. Возможно, для этого тоже существуют специальные библиотеки, но они не настолько известные, чтобы предлагать их в учебнике.
//
// Разделение строки в случайном месте может быть опасным!
// Разделив строку в случайном месте, например, с помощью str.slice(0, 4), мы не можем гарантировать валидность полученного значения. Например:
//
// alert( 'hi 😂'.slice(0, 4) ); //  hi [?]
// Здесь мы видим мусорный символ (первая половина суррогатной пары 😂) в выводе.
//
// Просто имейте это в виду, если вы намерены надежно работать с суррогатными парами. Может быть, это не очень большая проблема, но, по крайней мере, вы должны понимать, что происходит.
//
// Диакритические знаки и нормализация
// Во многих языках есть символы, состоящие из основного символа и знака над/под ним.
//
// Например, буква a может быть основой для этих символов: àáâäãåā.
//
// Большинство распространенных «составных» символов имеют свой собственный код в таблице Юникода. Но не все, потому что существует слишком большое количество возможных комбинаций.
//
// Для поддержки любых комбинаций стандарт Юникод позволяет нам использовать несколько Юникодных символов: основной символ, за которым следует один или много символов-«меток», которые «украшают» его.
//
// Например, если за S следует специальный символ «точка сверху» (код \u0307), то он отобразится как Ṡ.
//
// alert( 'S\u0307' ); // Ṡ
// Если нам нужен дополнительный знак над буквой (или под ней) – нет проблем, просто добавляем соответствующий символ.
//
// Например, если мы добавим символ «точка снизу» (код \u0323), то получим «S с точками сверху и снизу»: Ṩ.
//
// Вот, как это будет выглядеть:
//
// alert( 'S\u0307\u0323' ); // Ṩ
// Это обеспечивает большую гибкость, но при этом возникает определенная проблема: два символа могут визуально выглядеть одинаково, но при этом они будут представлены разными комбинациями Юникода.
//
// Например:
//
// let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
// let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху
//
// alert( `s1: ${s1}, s2: ${s2}` );
//
// alert( s1 == s2 ); // false, хотя символы выглядят одинаково (?!)
// Для решения этой проблемы предусмотрен алгоритм «Юникодной нормализации», приводящий каждую строку к единому «нормальному» виду.
//
// Его реализует метод str.normalize().
//
// alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true
// Забавно, но в нашем случае normalize() «схлопывает» последовательность из трёх символов в один: \u1e68 — S с двумя точками.
//
// alert( "S\u0307\u0323".normalize().length ); // 1
//
// alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
// В действительности это не всегда так. Причина в том, что символ Ṩ является «достаточно распространенным», поэтому создатели стандарта Юникод включили его в основную таблицу и присвоили ему код.
//
// Если вы хотите узнать больше о правилах и вариантах нормализации – они описаны в дополнении к стандарту Юникод: Unicode Normalization Forms, но для большинства практических целей достаточно информации из этого раздела.






//Intl: интернационализация в JavaScript
// Общая проблема строк, дат, чисел в JavaScript – они «не в курсе» языка и особенностей стран, где находится посетитель.
//
// В частности:
//
// Строки
// При сравнении сравниваются коды символов, а это неправильно, к примеру, в русском языке оказывается, что "ё" > "я" и "а" > "Я", хотя всем известно, что я – последняя буква алфавита и это она должна быть больше любой другой.
// Даты
// В разных странах принята разная запись дат. Где-то пишут 31.12.2014 (Россия), а где-то 12/31/2014 (США), где-то иначе.
// Числа
// В одних странах выводятся цифрами, в других – иероглифами, длинные числа разделяются где-то пробелом, где-то запятой.
// Все современные браузеры, кроме IE10 (но есть библиотеки и для него) поддерживают стандарт ECMA 402, предназначенный решить эти проблемы навсегда.
//
// Основные объекты
// Intl.Collator
// Умеет правильно сравнивать и сортировать строки.
// Intl.DateTimeFormat
// Умеет форматировать дату и время в соответствии с нужным языком.
// Intl.NumberFormat
// Умеет форматировать числа в соответствии с нужным языком.
// Локаль
// Локаль – первый и самый важный аргумент всех методов, связанных с интернационализацией.
//
// Локаль описывается строкой из трёх компонентов, которые разделяются дефисом:
//
// Код языка.
// Код способа записи.
// Код страны.
// На практике не всегда указаны три, обычно меньше:
//
// ru – русский язык, без уточнений.
// en-GB – английский язык, используемый в Англии (GB).
// en-US – английский язык, используемый в США (US).
// zh-Hans-CN – китайский язык (zh), записываемый упрощённой иероглифической письменностью (Hans), используемый в Китае.
// Также через суффикс -u-* можно указать расширения локалей, например "th-TH-u-nu-thai" – тайский язык (th), используемый в Таиланде (TH), с записью чисел тайскими буквами (๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙) .
//
// Стандарт, который описывает локали – RFC 5646, языки описаны в IANA language registry.
//
// Все методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения.
//
// Если локаль не указана или undefined – берётся локаль по умолчанию, установленная в окружении (браузере).
//
// Подбор локали localeMatcher
// localeMatcher – вспомогательная настройка, которую тоже можно везде указать, она определяет способ подбора локали, если желаемая недоступна.
//
// У него два значения:
//
// "lookup" – означает простейший порядок поиска путём обрезания суффикса, например zh-Hans-CN → zh-Hans → zh → локаль по умолчанию.
// "best fit" – использует встроенные алгоритмы и предпочтения браузера (или другого окружения) для выбора подходящей локали.
// По умолчанию стоит "best fit".
//
// Если локалей несколько, например ["zh-Hans-CN", "ru-RU"] то localeMatcher пытается подобрать наиболее подходящую локаль для первой из списка (китайская), если не получается – переходит ко второй (русской) и так далее. Если ни одной не нашёл, например на компьютере не совсем поддерживается ни китайский ни русский, то используется локаль по умолчанию.
//
// Как правило, "best fit" является здесь наилучшим выбором.
//
// Строки, Intl.Collator
// Синтаксис:
//
// // создание
// let collator = new Intl.Collator([locales, [options]])
// Параметры:
//
// locales
// Локаль, одна или массив в порядке предпочтения.
//
// options
// Объект с дополнительными настройками:
//
// localeMatcher – алгоритм выбора подходящей локали.
//
// usage – цель сравнения: сортировка "sort" или поиск "search", по умолчанию "sort".
//
// sensitivity – чувствительность: какие различия в символах учитывать, а какие – нет, варианты:
//
// base – учитывать только разные символы, без диакритических знаков и регистра, например: а ≠ б, е = ё, а = А.
// accent – учитывать символы и диакритические знаки, например: а ≠ б, е ≠ ё, а = А.
// case – учитывать символы и регистр, например: а ≠ б, е = ё, а ≠ А.
// variant – учитывать всё: символ, диакритические знаки, регистр, например: а ≠ б, е ≠ ё, а ≠ А, используется по умолчанию.
// ignorePunctuation – игнорировать знаки пунктуации: true/false, по умолчанию false.
//
// numeric – использовать ли численное сравнение: true/false, если true, то будет 12 > 2, иначе 12 < 2.
//
// caseFirst – в сортировке должны идти первыми прописные или строчные буквы, варианты: "upper" (прописные), "lower" (строчные) или "false" (стандартное для локали, также является значением по умолчанию). Не поддерживается IE11.
//
// В подавляющем большинстве случаев подходят стандартные параметры, то есть options указывать не нужно.
//
// Использование:
//
// let result = collator.compare(str1, str2);
// Результат compare имеет значение 1 (больше), 0 (равно) или -1 (меньше).
//
// Например:
//
// let collator = new Intl.Collator();
//
// alert( "ёжик" > "яблоко" ); // true (ёжик больше, что неверно)
// alert( collator.compare("ёжик", "яблоко") ); // -1 (ёжик меньше, верно)
// Выше были использованы полностью стандартные настройки. Они различают регистр символа, но это различие можно убрать, если настроить чувствительность sensitivity:
//
// let collator1 = new Intl.Collator();
// alert( collator1.compare("ЁжиК", "ёжик") ); // 1, разные
//
// let collator2 = new Intl.Collator(undefined, {
//   sensitivity: "accent"
// });
// alert( collator2.compare("ЁжиК", "ёжик") ); // 0, одинаковые
// Даты, Intl.DateTimeFormat
// Синтаксис:
//
// // создание
// let formatter = new Intl.DateTimeFormat([locales, [options]])
// Первый аргумент – такой же, как и в Collator, а в объекте options мы можем определить, какие именно части даты показывать (часы, месяц, год…) и в каком формате.
//
// Полный список свойств options:
//
// Свойство	Описание	Возможные значения	По умолчанию
// localeMatcher	Алгоритм подбора локали	lookup, best fit	best fit
// formatMatcher	Алгоритм подбора формата	basic, best fit	best fit
// hour12	Включать ли время в 12-часовом формате	true -- 12-часовой формат, false -- 24-часовой
// timeZone	Временная зона	Временная зона, например Europe/Moscow	UTC
// weekday	День недели	narrow, short, long
// era	Эра	narrow, short, long
// year	Год	2-digit, numeric	undefined или numeric
// month	Месяц	2-digit, numeric, narrow, short, long	undefined или numeric
// day	День	2-digit, numeric	undefined или numeric
// hour	Час	2-digit, numeric
// minute	Минуты	2-digit, numeric
// second	Секунды	2-digit, numeric
// timeZoneName	Название таймзоны (нет в IE11)	short, long
// Все локали обязаны поддерживать следующие наборы настроек:
//
// weekday, year, month, day, hour, minute, second
// weekday, year, month, day
// year, month, day
// year, month
// month, day
// hour, minute, second
// Если указанный формат не поддерживается, то настройка formatMatcher задаёт алгоритм подбора наиболее близкого формата: basic – по стандартным правилам и best fit – по умолчанию, на усмотрение окружения (браузера).
//
// Использование:
//
// let dateString = formatter.format(date);
// Например:
//
// let date = new Date(2014, 11, 31, 12, 30, 0);
//
// let formatter1 = new Intl.DateTimeFormat("ru");
// alert( formatter1.format(date) ); // 31.12.2014
//
// let formatter2 = new Intl.DateTimeFormat("en-US");
// alert( formatter2.format(date) ); // 12/31/2014
// Длинная дата, с настройками:
//
// let date = new Date(2014, 11, 31, 12, 30, 0);
//
// let formatter = new Intl.DateTimeFormat("ru", {
//   weekday: "long",
//   year: "numeric",
//   month: "long",
//   day: "numeric"
// });
//
// alert( formatter.format(date) ); // среда, 31 декабря 2014 г.
// Только время:
//
// let date = new Date(2014, 11, 31, 12, 30, 0);
//
// let formatter = new Intl.DateTimeFormat("ru", {
//   hour: "numeric",
//   minute: "numeric",
//   second: "numeric"
// });
//
// alert( formatter.format(date) ); // 12:30:00
// Числа, Intl.NumberFormat
// Форматтер Intl.NumberFormat умеет красиво форматировать не только числа, но и валюту, а также проценты.
//
// Синтаксис:
//
// let formatter = new Intl.NumberFormat([locales[, options]]);
//
// formatter.format(number); // форматирование
// Параметры, как и раньше – локаль и опции.
//
// Список опций:
//
// Свойство	Описание	Возможные значения	По умолчанию
// localeMatcher	Алгоритм подбора локали	lookup, best fit	best fit
// style	Стиль форматирования	decimal, percent, currency	decimal
// currency	Алфавитный код валюты	См. Список кодов валюты, например USD
// currencyDisplay	Показывать валюту в виде кода, локализованного символа или локализованного названия	code, symbol, name	symbol
// useGrouping	Разделять ли цифры на группы	true, false	true
// minimumIntegerDigits	Минимальное количество цифр целой части	от 1 до 21	21
// minimumFractionDigits	Минимальное количество десятичных цифр	от 0 до 20	для чисел и процентов 0, для валюты зависит от кода.
// maximumFractionDigits	Максимальное количество десятичных цифр	от minimumFractionDigits до 20.	для чисел max(minimumFractionDigits, 3), для процентов 0, для валюты зависит от кода.
// minimumSignificantDigits	Минимальное количество значимых цифр	от 1 до 21	1
// maximumSignificantDigits	Максимальное количество значимых цифр	от minimumSignificantDigits до 21	21
// Пример без опций:
//
// let formatter = new Intl.NumberFormat("ru");
// alert( formatter.format(1234567890.123) ); // 1 234 567 890,123
// С ограничением значимых цифр (важны только первые 3):
//
// let formatter = new Intl.NumberFormat("ru", {
//   maximumSignificantDigits: 3
// });
// alert( formatter.format(1234567890.123) ); // 1 230 000 000
// С опциями для валюты:
//
// let formatter = new Intl.NumberFormat("ru", {
//   style: "currency",
//   currency: "GBP"
// });
//
// alert( formatter.format(1234.5) ); // 1 234,5 £
// С двумя цифрами после запятой:
//
// let formatter = new Intl.NumberFormat("ru", {
//   style: "currency",
//   currency: "GBP",
//   minimumFractionDigits: 2
// });
//
// alert( formatter.format(1234.5) ); // 1 234,50 £
// Методы в Date, String, Number
// Методы форматирования также поддерживаются в обычных строках, датах, числах:
//
// String.prototype.localeCompare(that [, locales [, options]])
// Сравнивает строку с другой, с учётом локали, например:
//
// let str = "ёжик";
//
// alert( str.localeCompare("яблоко", "ru") ); // -1
// Date.prototype.toLocaleString([locales [, options]])
// Форматирует дату в соответствии с локалью, например:
//
// let date = new Date(2014, 11, 31, 12, 0);
//
// alert( date.toLocaleString("ru", { year: 'numeric', month: 'long' }) ); // Декабрь 2014
// Date.prototype.toLocaleDateString([locales [, options]])
// То же, что и выше, но опции по умолчанию включают в себя год, месяц, день
//
// Date.prototype.toLocaleTimeString([locales [, options]])
// То же, что и выше, но опции по умолчанию включают в себя часы, минуты, секунды
//
// Number.prototype.toLocaleString([locales [, options]])
// Форматирует число, используя опции Intl.NumberFormat.
//
// Все эти методы при запуске создают соответствующий объект Intl.* и передают ему опции, можно рассматривать их как укороченные варианты вызова.
//
// Старые IE
// В IE10 рекомендуется использовать полифил, например библиотеку https://github.com/andyearnshaw/Intl.js.














//WeakRef и FinalizationRegistry
// «Скрытые» возможности языка
// В этой статье рассматривается очень узконаправленная тема, с которой большинство разработчиков на практике сталкиваются чрезвычайно редко (а могут и вообще не знать о её существовании).
//
// Мы рекомендуем пропустить эту главу, если вы только начали изучение JavaScript.
//
// Вспоминая основную концепцию принципа достижимости из главы Сборка мусора, мы можем отметить, что движок JavaScript гарантированно хранит в памяти значения, которые доступны или используются.
//
// Например:
//
// //  в переменной user находится сильная ссылка на объект
// let user = { name: "John" };
//
// // перезапишем значение переменной user
// user = null;
//
// // ссылка теряется и объект будет удалён из памяти
// Или же похожий, но немного усложнённый код с двумя сильными ссылками:
//
// //  в переменной user находится сильная ссылка на объект
// let user = { name: "John" };
//
// // скопировали сильную ссылку на объект в переменную admin
// let admin = user;
//
// // перезапишем значение переменной user
// user = null;
//
// // объект всё ещё доступен через переменную admin
// Объект { name: "John" } удалился бы из памяти только в случае отсутствия сильных ссылок на него (если бы мы также перезаписали значение переменной admin).
//
// В JavaScript существует концепция под названием WeakRef, которая ведёт себя немного иначе в этом случае.
//
// Термины: «Сильная ссылка», «Слабая ссылка»
// Сильная ссылка – это ссылка на объект или значение, которая предотвращает их удаление сборщиком мусора. При этом, сохраняя объект или значение в памяти, на которые она указывает.
//
// Это означает, что объект или значение остаются в памяти и не удаляются сборщиком мусора до тех пор, пока на них есть активные сильные ссылки.
//
// В JavaScript стандартные ссылки на объекты являются сильными ссылками. Например:
//
// // переменная user содержит сильную ссылку на этот объект.
// let user = { name: "John" };
// Слабая ссылка – это ссылка на объект или значение, которая не предотвращает их удаление сборщиком мусора. Объект или значение могут быть удалены сборщиком мусора в случае, если на них существуют только слабые ссылки.
//
// WeakRef
// Предостережение
// Прежде чем мы перейдём к изучению, стоит отметить, что правильное применение структур, о которых пойдёт речь в этой статье, требует очень тщательного обдумывания, и по возможности их использования лучше избегать.
//
// WeakRef – это объект, содержащий слабую ссылку на другой объект, называемый target или referent.
//
// Особенность WeakRef заключается в том, что он не препятствует сборщику мусора удалять свой объект-референт. Другими словами, он просто не удерживает его «в живых».
//
// Теперь давайте возьмём переменную user в качестве «референта» и создадим слабую ссылку от неё к переменной admin. Чтобы создать слабую ссылку, необходимо использовать конструктор WeakRef, передав целевой объект (объект, на который вы хотите создать слабую ссылку).
//
// В нашем случае — это переменная user:
//
// //  в переменной user находится сильная ссылка на объект
// let user = { name: "John" };
//
// //  в переменной admin находится слабая ссылка на объект
// let admin = new WeakRef(user);
// На схеме ниже изображены два типа ссылок: сильная ссылка с использованием переменной user и слабая ссылка с использованием переменной admin:
//
//
// Затем, в какой-то момент, мы перестаём использовать переменную user – она перезаписывается, выходит из области видимости и т.д., при этом сохраняя экземпляр WeakRef в переменной admin:
//
// // перезапишем значение переменной user
// user = null;
// Слабой ссылки на объект недостаточно, чтобы сохранить его «в живых». Когда единственными оставшимися ссылками на объект-референт являются слабые ссылки, сборщик мусора вправе уничтожить этот объект и использовать его память для чего-то другого.
//
// Однако до тех пор, пока объект фактически не уничтожен, слабая ссылка может вернуть его, даже если на данный объект больше нет сильных ссылок. То есть наш объект становится своеобразным «котом Шрёдингера» – мы не можем знать точно, «жив» он или «мёртв»:
//
//
// На этом этапе, чтобы получить объект из экземпляра WeakRef, мы воспользуемся его методом deref().
//
// Метод deref() возвращает объект-референт, на который ссылается WeakRef, в случае, если объект всё ещё находится в памяти. Если объект был удалён сборщиком мусора, – метод deref() вернёт undefined:
//
// let ref = admin.deref();
//
// if (ref) {
//   // объект всё ещё доступен: можем произвести какие-либо манипуляции с ним
// } else {
//   // объект был удалён сборщиком мусора
// }
// Варианты использования WeakRef
// WeakRef обычно используется для создания кешей или ассоциативных массивов, в которых хранятся ресурсоёмкие объекты. Это позволяет избежать предотвращение удаления этих объектов сборщиком мусора только на основе их присутствия в кеше или ассоциативном массиве.
//
// Один из основных примеров – это ситуация, когда у нас есть большое количество объектов бинарных изображений (например, представленных в виде ArrayBuffer или Blob), и мы хотим связать имя или путь с каждым изображением. Существующие структуры данных не совсем подходят для этих целей:
//
// Использование Map для создания ассоциаций между именами и изображениями, или наоборот, сохранит объекты изображений в памяти, поскольку они фигурируют в Map в качестве ключей или значений.
// WeakMap также не подойдёт в этом случае: из-за того, что объекты, представленные в качестве ключей WeakMap используют слабые ссылки, и не защищены от удаления сборщиком мусора.
// Но, в данной ситуации нам нужна структура данных, которая бы использовала слабые ссылки в своих значениях.
//
// Для этого мы можем использовать коллекцию Map, значениями которой являются экземпляры WeakRef, ссылающиеся на нужные нам большие объекты. Следовательно, мы не будем хранить в памяти эти большие и ненужные объекты дольше, чем требуется.
//
// В противном случае это способ получить объект изображения из кеша, если он всё ещё доступен. Если же он был удалён сборщиком мусора, мы сгенерируем или скачаем его заново.
//
// Таким образом, в некоторых ситуациях используется меньше памяти.
//
// Пример №1: применение WeakRef для кеширования
// Ниже находится фрагмент кода, который демонстрирует технику использования WeakRef.
//
// Говоря кратко, мы используем Map со строковыми ключами и объектами WeakRef в качестве их значений. Если объект WeakRef не был удалён сборщиком мусора, мы берём его из кеша. В противном случае мы скачиваем его заново и помещаем в кеш для возможности повторного использования в будущем:
//
// function fetchImg() {
//   // абстрактная функция для загрузки изображений...
// }
//
// function weakRefCache(fetchImg) { // (1)
//   const imgCache = new Map(); // (2)
//
//   return (imgName) => { // (3)
//     const cachedImg = imgCache.get(imgName); // (4)
//
//     if (cachedImg?.deref()) { // (5)
//       return cachedImg?.deref();
//     }
//
//     const newImg = fetchImg(imgName); // (6)
//     imgCache.set(imgName, new WeakRef(newImg)); // (7)
//
//     return newImg;
//   };
// }
//
// const getCachedImg = weakRefCache(fetchImg);
// Давайте подробно разберём всё, что тут произошло:
//
// weakRefCache – функция высшего порядка, которая принимает другую функцию fetchImg в качестве аргумента. В данном примере мы можем пренебречь подробным описанием функции fetchImg, так как это может быть абсолютно любая логика скачивания изображений.
// imgCache – кеш изображений, который хранит кешированные результаты функции fetchImg, в виде строковых ключей (имя изображения) и объектов WeakRef в качестве их значений.
// Возвращаем анонимную функцию, которая принимает имя изображения в качестве аргумента. Данный аргумент будет использоваться в качестве ключа для кешированного изображения.
// Пытаемся получить кешированный результат из кеша, используя предоставленный ключ (имя изображения).
// Если кеш содержит значение по указанному ключу, и объект WeakRef не был удалён сборщиком мусора, возвращаем кешированный результат.
// Если в кеше нет записи с запрошенным ключом, либо метод deref() возвращает undefined (что означает, что объект WeakRef был удалён сборщиком мусора), функция fetchImg скачивает изображение заново.
// Помещаем скачанное изображение в кеш в виде WeakRef объекта.
// Теперь у нас есть коллекция Map, в которой ключи – это имена изображений в виде строк, а значения – это объекты WeakRef, содержащие сами изображения.
//
// Эта техника помогает избежать выделения большого объёма памяти на ресурсоёмкие объекты, которые больше никто не использует. Также она экономит память и время в случае повторного использования кешированных объектов.
//
// Вот визуальное представление того, как выглядит этот код:
//
//
// Но, у данной реализации есть свои недостатки: со временем Map будет заполняться строками в качестве ключей, которые указывают на WeakRef, чей объект-референт уже был удалён сборщиком мусора:
//
//
// Один из способов справиться с этой проблемой – это периодически проверять кеш и удалять «мёртвые» записи. Другой способ – использовать финализаторы, с которыми мы ознакомимся далее.
//
// Пример №2: применение WeakRef для отслеживания объектов DOM
// Ещё один вариант использования WeakRef – отслеживание объектов DOM.
//
// Давайте представим ситуацию, когда какой-либо сторонний код или библиотека работают с элементами на нашей странице до тех пор, пока они существуют в DOM. Например, это может быть сторонняя утилита для мониторинга и оповещений о состоянии системы (так называемый «логгер» – программа, которая присылает информационные сообщения, называемые «логами»).
//
// Интерактивный пример:
//
// Результатindex.jsindex.cssindex.html
//
// При нажатии на кнопку «Начать отправку сообщений», в так называемом «окне отображения логов» (элемент с классом .window__body) начинают появляться надписи (логи).
//
// Но, как только этот элемент удалится из DOM, логгер должен перестать присылать сообщения. Чтобы воспроизвести удаление данного элемента, достаточно лишь нажать на кнопку «Закрыть» в правом верхнем углу.
//
// Для того, чтобы нам не усложнять работу, и не уведомлять сторонний код каждый раз, когда наш DOM-элемент доступен, а когда – нет, достаточно будет создать на него слабую ссылку с помощью WeakRef.
//
// После того как элемент будет удалён из DOM, логгер это увидит и перестанет присылать сообщения.
//
// Теперь давайте рассмотрим исходный код детальнее (вкладка index.js):
//
// Получаем DOM-элемент кнопки «Начать отправку сообщений».
//
// Получаем DOM-элемент кнопки «Закрыть».
//
// Получаем DOM-элемент окна отображения логов с использованием конструктора new WeakRef(). Таким образом переменная windowElementRef хранит слабую ссылку на DOM-элемент.
//
// Добавляем обработчик событий на кнопку «Начать отправку сообщений», отвечающий за запуск логгера по нажатию.
//
// Добавляем обработчик событий на кнопку «Закрыть», отвечающий за закрытие окна отображения логов по нажатию.
//
// С помощью setInterval запускаем отображение нового сообщения каждую секунду.
//
// Если DOM-элемент окна отображения логов всё ещё доступен и находится в памяти, создаём и отправляем новое сообщение.
//
// Если метод deref() возвращает undefined, это значит, что DOM-элемент был удалён из памяти. В таком случае логгер прекращает показ сообщений и сбрасывает таймер.
//
// alert, который будет вызван после того, как DOM-элемент окна отображения логов удалится из памяти (т.е. после нажатия на кнопку «Закрыть»). Обратите внимание, что удаление из памяти может произойти не сразу, т.к оно зависит только от внутренних механизмов сборщика мусора.
//
// Мы не можем контролировать этот процесс напрямую из кода. Но, несмотря на это, у нас всё ещё есть возможность выполнить принудительную сборку мусора из бразуера.
//
// В Google Chrome, например, для этого нужно открыть инструменты разработчика (Ctrl + Shift + J на Windows/Linux или Option + ⌘ + J на macOS), перейти во вкладку «Производительность (Performance)» и нажать на кнопку с иконкой урны – «Собрать мусор (Collect garbage)»:
//
//
// Данный функционал поддерживается в большинстве современных браузеров. После проделанных действий alert сработает незамедлительно.
//
// FinalizationRegistry
// А теперь пришло время поговорить о финализаторах. Прежде чем мы перейдём дальше, давайте разберёмся с терминологией:
//
// Колбэк очистки (финализатор) – это функция, которая выполняется в случае, если объект, зарегистрированный в FinalizationRegistry, удаляется из памяти сборщиком мусора.
//
// Его цель – предоставить возможность выполнения дополнительных операций, связанных с объектом, после его окончательного удаления из памяти.
//
// Реестр (или FinalizationRegistry) – это специальный объект в JavaScript, который управляет регистрацией и отменой регистрации объектов и их колбэков очистки.
//
// Этот механизм позволяет зарегистрировать объект для отслеживания и связать с ним колбэк очистки. По сути, это структура, которая хранит информацию о зарегистрированных объектах и их колбэках очистки, а затем автоматически вызывает эти колбэки при удалении объектов из памяти.
//
// Для создания экземпляра реестра FinalizationRegistry, необходимо вызвать его конструктор, который принимает единственный аргумент – колбэк очистки (финализатор).
//
// Синтаксис:
//
// function cleanupCallback(heldValue) {
//   // код колбэка очистки
// }
//
// const registry = new FinalizationRegistry(cleanupCallback);
// Здесь:
//
// cleanupCallback – колбэк очистки, который будет автоматически вызван при удалении зарегистрированного объекта из памяти.
// heldValue – значение, которое передаётся в качестве аргумента для колбэка очистки. Если heldValue является объектом, реестр сохраняет на него сильную ссылку.
// registry – экземпляр FinalizationRegistry.
// Методы FinalizationRegistry:
//
// register(target, heldValue [, unregisterToken]) – используется для регистрации объектов в реестре.
//
// target – регистрируемый для отслеживания объект. Если target будет удалён сборщиком мусора, колбэк очистки будет вызван с heldValue в качестве аргумента.
//
// Опциональный unregisterToken – токен отмены регистрации. Может быть передан для отмены регистрации до удаления объекта сборщиком мусора. Обычно в качестве unregisterToken используется объект target, что является стандартной практикой.
//
// unregister(unregisterToken) – метод unregister используется для отмены регистрации объекта в реестре. Он принимает один аргумент – unregisterToken (токен отмены регистрации, который был получен при регистрации объекта).
//
// Теперь перейдём к простому примеру. Воспользуемся уже известным нам объектом user и создадим экземпляр FinalizationRegistry:
//
// let user = { name: "John" };
//
// const registry = new FinalizationRegistry((heldValue) => {
//   console.log(`${heldValue} был собран сборщиком мусора.`);
// });
// Затем зарегистрируем объект, для которого требуется колбэк очистки, вызвав метод register:
//
// registry.register(user, user.name);
// Реестр не хранит сильную ссылку на регистрируемый объект, так как это бы противоречило его предназначению. Если бы реестр сохранял сильную ссылку, то объект никогда бы не был очищен сборщиком мусора.
//
// Если же объект удаляется сборщиком мусора, наш колбэк очистки может быть вызван в какой-то момент в будущем, с переданным ему heldValue:
//
// // Когда объект user удалится сборщиком мусора, в консоль будет выведено сообщение:
// "John был собран сборщиком мусора."
// Также существуют ситуации, когда даже в реализациях, где используется колбэк очистки, есть вероятность, что он не будет вызван.
//
// Например:
//
// Когда программа полностью завершает свою работу (например, при закрытии вкладки в браузере).
// Когда сам экземпляр FinalizationRegistry больше не доступен для JavaScript кода. Если объект, создающий экземпляр FinalizationRegistry, выходит из области видимости или удаляется, то колбэки очистки, зарегистрированные в этом реестре, также могут быть не вызваны.
// Кеширование с FinalizationRegistry
// Возвращаясь к нашему примеру слабого кеша, мы можем заметить следующее:
//
// Несмотря на то, что значения, обёрнутые в WeakRef, были собраны сборщиком мусора, всё ещё актуальна проблема «утечки памяти» в виде оставшихся ключей, значения которых были собраны сборщиком мусора.
// Вот улучшенный пример кеширования, в котором используется FinalizationRegistry:
//
// function fetchImg() {
//   // абстрактная функция для загрузки изображений...
// }
//
// function weakRefCache(fetchImg) {
//   const imgCache = new Map();
//
//   const registry = new FinalizationRegistry((imgName) => { // (1)
//     const cachedImg = imgCache.get(imgName);
//     if (cachedImg && !cachedImg.deref()) imgCache.delete(imgName);
//   });
//
//   return (imgName) => {
//     const cachedImg = imgCache.get(imgName);
//
//     if (cachedImg?.deref()) {
//       return cachedImg?.deref();
//     }
//
//     const newImg = fetchImg(imgName);
//     imgCache.set(imgName, new WeakRef(newImg));
//     registry.register(newImg, imgName); // (2)
//
//     return newImg;
//   };
// }
//
// const getCachedImg = weakRefCache(fetchImg);
// Для управления очисткой «мёртвых» записей в кеше, когда связанные с ними объекты WeakRef собираются сборщиком мусора, создаём реестр очистки FinalizationRegistry.
//
// Важным моментом здесь является то, что в колбэке очистки должно проверяться, была ли запись удалена сборщиком мусора и не была ли добавлена заново, чтобы не удалить «живую» запись.
//
// После загрузки и установки нового значения (изображения) в кеш, регистрируем его в реестре финализатора для отслеживания объекта WeakRef.
//
// Данная реализация содержит только актуальные или «живые» пары ключ/значение. В этом случае каждый объект WeakRef зарегистрирован в FinalizationRegistry. А после того, как объекты будут очищены сборщиком мусора, колбэк очистки удалит все значения undefined.
//
// Вот визуальное представление обновлённого кода:
//
//
// Ключевым аспектом в обновлённой реализации является то, что финализаторы позволяют создавать параллельные процессы между «основной» программой и колбэками очистки. В контексте JavaScript, «основная» программа – это наш JavaScript-код, который запускается и выполняется в нашем приложении или на веб-странице.
//
// Следовательно, с момента, когда объект помечается для удаления сборщиком мусора, до фактического выполнения колбэка очистки, может возникнуть определённый промежуток времени. Важно понимать, что в этом временном интервале основная программа может внести любые изменения в объект или даже вернуть его обратно в память.
//
// Поэтому, в колбэке очистки мы должны проверить, не была ли запись добавлена обратно в кеш основной программой, чтобы избежать удаления «живых» записей. Аналогично, при поиске ключа в кеше существует вероятность того, что значение было удалено сборщиком мусора, но колбэк очистки ещё не был выполнен.
//
// Такие ситуации требуют особого внимания, если вы работаете с FinalizationRegistry.
//
// Использование WeakRef и FinalizationRegistry на практике
// Переходя от теории к практике, представьте себе реальный сценарий, когда пользователь синхронизирует свои фотографии на мобильном устройстве с каким-либо облачным сервисом (таким как iCloud или Google Photos), и хочет просматривать их с других устройств. Подобные сервисы помимо основного функционала просмотра фотографий, предлагают массу дополнительных возможностей, например:
//
// Редактирование фотографий и видео эффекты.
// Создание «воспоминаний» и альбомов.
// Монтаж видео из серии фотографий.
// …и многое другое.
// В качестве примера здесь мы будем использовать достаточно примитивную реализацию подобного сервиса. Основная суть — показать возможный сценарий совместного использования WeakRef и FinalizationRegistry в реальной жизни.
//
// Вот как это выглядит:
//
//
// В левой части находится облачная библиотека фотографий (они отображаются в виде миниатюр). Мы можем выбрать нужные нам изображения и создать коллаж, нажав на кнопку «Create collage» в правой части страницы. Затем, получившийся результат можно будет скачать в виде изображения.
//
// Для увеличения скорости загрузки страницы разумно будет загружать и показывать миниатюры фотографий именно в сжатом качестве. Но, для создания коллажа из выбранных фотографий, загружать и использовать их в полноразмерном качестве.
//
// Ниже мы видим, что внутренний размер миниатюр составляет 240×240 пикселей. Размер был выбран специально для увеличения скорости загрузки. Кроме того, нам не нужны полноразмерные фотографии в режиме предпросмотра.
//
//
// Предположим, что нам нужно создать коллаж из 4 фотографий: мы выбираем их, после чего нажимаем кнопку «Create collage». На этом этапе уже известная нам функция weakRefCache проверяет, есть ли нужное изображение в кеше. Если нет, то скачивает его из облака и помещает в кеш для возможности дальнейшего использования. И так происходит для каждого выбранного изображения:
//
//
// Обратив внимание на вывод в консоли можно увидеть, какие из фотографий были загружены из облака – на это указывает FETCHED_IMAGE. Так как это первая попытка создания коллажа, это означает, что на данном этапе «слабый кеш» ещё был пуст, а все фотографии были скачаны из облака и помещены в него.
//
// Но, наряду с процессом загрузки изображений, происходит ещё и процесс очистки памяти сборщиком мусора. Это означает, что хранящийся в кеше объект, на который мы ссылаемся используя слабую ссылку, удаляется сборщиком мусора. И наш финализатор выполняется успешно, тем самым удаляя ключ, по которому изображение хранилось в кеше. Об этом нас уведомляет CLEANED_IMAGE:
//
//
// Далее мы понимаем, что нам не нравится получившийся коллаж, и решаем изменить одно из изображений и создать новый. Для этого достаточно снять выделение с ненужного изображения, выбрать другое, и ещё раз нажать на кнопку «Create collage»:
//
//
// Но, на этот раз не все изображения были скачаны из сети, и одно из них было взято из слабого кеша: об этом нам говорит сообщение CACHED_IMAGE. Это означает, что на момент создания коллажа сборщик мусора ещё не удалил наше изображение, и мы смело взяли его из кеша, тем самым сократив количество сетевых запросов и ускорив общее время процесса создания коллажа:
//
//
// Давайте ещё немного «поиграем», заменив одно из изображений ещё раз и создав новый коллаж:
//
//
// На этот раз результат ещё более внушительный. Из 4 выбранных изображений, 3 из них были взяты из слабого кеша, и только одно пришлось скачать из сети. Снижение нагрузки на сеть составило около 75%. Впечатляет, не правда ли?
//
//
// Конечно, не следует забывать, что такое поведение не является гарантированным, и зависит от конкретной реализации и работы сборщика мусора.
//
// Исходя из этого, сразу же возникает вполне логичный вопрос: почему бы нам не использовать обычный кеш, где мы можем сами управлять его сущностями, а не полагаться на сборщик мусора? Всё верно, в большинстве случаев нет необходимости использовать WeakRef и FinalizationRegistry.
//
// Здесь мы просто продемонстрировали альтернативную реализацию подобного функционала, используя нетривиальный подход с интересными особенностями языка. Всё же, мы не можем полагаться на этот пример, если нам необходим постоянный и предсказуемый результат.
//
// Вы можете открыть данный пример в песочнице.
//
// Итого
// WeakRef – предназначен для создания слабых ссылок на объекты, что позволяет им быть удалёнными из памяти сборщиком мусора, если на них больше нет сильных ссылок. Это полезно для решения проблемы чрезмерного использования памяти и оптимизации использования системных ресурсов в приложениях.
//
// FinalizationRegistry – это средство регистрации колбэков, которые выполняются при уничтожении объектов, на которые больше нет сильных ссылок. Это позволяет освобождать связанные с объектом ресурсы или выполнять другие необходимые операции перед удалением объекта из памяти.



































































