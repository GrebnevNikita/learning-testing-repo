alert('Привет, мир!');

// <script src="/path/to/script.js"></script>
[1, 2].forEach(alert);

"use strict";
// этот код работает в современном режиме

let message;
message = 'Hello!';
// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
const COLOR_RED = "#F00";

alert(1 / 0); // Infinity

alert(Infinity); // Infinity
// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:

alert("не число" / 2); // NaN, такое деление является ошибкой
// Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

alert(NaN + 1); // NaN
alert(3 * NaN); // NaN
alert("не число" / 2 - 1); // NaN

let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
let age;

alert(age); // выведет "undefined"
let age = 123;
// изменяем значение на undefined
age = undefined;

let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!
// Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

let isBoss = confirm("Ты здесь главный?");
alert(isBoss); // true, если нажата OK


let value = true;
alert(typeof value); // boolean
value = String(value); // теперь value это строка "true"
alert(typeof value); // string


alert("6" / "2"); // 3, строки преобразуются в числа


alert(Number("   123   ")); // 123
alert(Number("123z"));      // NaN (ошибка чтения числа на месте символа "z")
alert(Number(true));        // 1
alert(Number(false));       // 0

alert(Boolean(1)); // true
alert(Boolean(0)); // false

alert(Boolean("Привет!")); // true
alert(Boolean("")); // false

// Заметим, что строка с нулём "0" — это true
// Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.


// Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1;
x = -x;
alert(x); // -1, применили унарный минус
// Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
let x = 1, y = 3;
alert(y - x); // 2, бинарный минус вычитает значения

let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert(+apples + +oranges); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

if (1 && 0) { // вычисляется как true && false
    alert("не сработает, так как результат ложный");
}


// Оператор нулевого слияния (??)
let result = a ?? b
let result = (a !== null && a !== undefined) ? a : b;
let user;
alert(user ?? "Аноним"); // Аноним (user не существует)
let user = "Иван";
alert(user ?? "Аноним"); // Иван (user существует)


function sayHi() {   // (1) создаём
    alert("Привет");
}

let func = sayHi;    // (2) копируем

func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)

function sayHi() {
    // ...
}

let sayHi = function () {
    // ...
};


function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
}

function showOk() {
    alert("Вы согласны.");
}

function showCancel() {
    alert("Вы отменили выполнение.");
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
}

// Мы можем переписать этот пример значительно короче, используя Function Expression:
ask(
    "Вы согласны?",
    function () {
        alert("Вы согласились.");
    },
    function () {
        alert("Вы отменили выполнение.");
    })


// Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.

// Function Declaration
function sum(a, b) {
    return a + b;
}

// Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:

// Function Expression
let sum = function (a, b) {
    return a + b;
};


let age = 16; // возьмём для примера 16

if (age < 18) {
    welcome();               // \   (выполнится)
                             //  |
    function welcome() {     //  |
        alert("Привет!");      //  |  Function Declaration доступно
    }                        //  |  во всём блоке кода, в котором объявлено
                             //  |
    welcome();               // /   (выполнится)

} else {

    function welcome() {
        alert("Здравствуйте!");
    }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined


// Стрелочные функции, основы

let func = (arg1, arg2, ...argN) => expression;

// Другими словами, это сокращённая версия:
let func = function (arg1, arg2, ...argN) {
    return expression;
};


let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3




typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

// В JavaScript есть 8 основных типов данных.
//
//     Семь из них называют «примитивными» типами данных:
//     number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
//     bigint для целых чисел произвольной длины.
//     string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
//     boolean для true/false.
//     null для неизвестных значений – отдельный тип, имеющий одно значение null.
//     undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
//     symbol для уникальных идентификаторов.
//     И один не является «примитивным» и стоит особняком:
//     object для более сложных структур данных.

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"

let user = {     // объект
    name: "John",  // под ключом "name" хранится значение "John"
    age: 30        // под ключом "age" хранится значение 30
};


// получаем свойства объекта:
alert(user.name); // John
alert(user.age); // 30


// Для удаления свойства мы можем использовать оператор delete:

delete user.age;


let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];

let fruit = 'apple';
let bag = {
    [fruit + 'Computers']: 5 // bag.appleComputers = 5
};


// Вместо name:name мы можем написать просто name:

function makeUser(name, age) {
    return {
        name, // то же самое, что и name: name
        age   // то же самое, что и age: age
        // ...
    };
}

// Мы можем использовать как обычные свойства, так и короткие в одном и том же объекте:

let user = {
    name,  // тоже самое, что и name:name
    age: 30
};


let user = {};

alert(user.noSuchProperty === undefined); // true означает "свойства нет"


// Это когда свойство существует, но содержит значение undefined:

let obj = {
    test: undefined
};

alert(obj.test); //  выведет undefined, значит свойство не существует?
alert("test" in obj); // true, свойство существует!


let user = {
    name: "John",
    age: 30,
    isAdmin: true
};

for (let key in user) {
    // ключи
    alert(key);  // name, age, isAdmin
    // значения ключей
    alert(user[key]); // John, 30, true
}


let codes = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США"
};

for (let code in codes) {
    alert(code); // 1, 41, 44, 49
}
// Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить, сделав коды не целочисленными свойствами. Добавления знака "+" перед каждым кодом будет достаточно.
let codes = {
    "+49": "Германия",
    "+41": "Швейцария",
    "+44": "Великобритания",
    // ..,
    "+1": "США"
};

for (let code in codes) {
    alert(+code); // 49, 41, 44, 1
}


// Здесь мы помещаем копию message во phrase:

let message = "Привет!";
let phrase = message;
// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".

// Объекты ведут себя иначе.
let user = {name: "John"};
let admin = user; // копируется ссылка


// Сравнение по ссылке
// Два объекта равны только в том случае, если это один и тот же объект.

// Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:

let a = {};
let b = a; // копирование по ссылке

alert(a == b); // true, обе переменные ссылаются на один и тот же объект
alert(a === b); // true
// И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):

let a = {};
let b = {}; // два независимых объекта

alert(a == b); // false


// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
//     Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
//     Возвращает объект dest.
//     Например, мы можем использовать его для объединения нескольких объектов в один:

let user = {name: "John"};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }
// Если скопированное имя свойства уже существует, оно будет перезаписано:

let user1 = {canView: true}


let objects = [{'a': 1}, {'b': 2}];

// Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.
let deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false


let user = {
    name: "John",
    age: 30
};
user.sayHi = function (rrr) {
    alert("Привет!" + rrr);
};
user.sayHi(123); // Привет!
// Конечно, мы могли бы использовать заранее объявленную функцию в качестве метода, вот так:

let user = {
    // ...
};

// сначала, объявляем
function sayHi() {
    alert("Привет!");
}

// затем добавляем в качестве метода
user.sayHi = sayHi;

user.sayHi(); // Привет!


// Существует более короткий синтаксис для методов в литерале объекта:

// эти объекты делают одно и то же

user = {
    sayHi: function () {
        alert("Привет");
    }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
        alert("Привет");
    }
};
// Как было показано, мы можем пропустить ключевое слово "function" и просто написать sayHi().


let user = {
    name: "John",
    age: 30,

    sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
    }

};

user.sayHi(); // John


// Значение this вычисляется во время выполнения кода, в зависимости от контекста.

// Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:

let user = {name: "John"};
let admin = {name: "Admin"};

function sayHi() {
    alert(this.name);
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

// Значение this определяется во время исполнения кода.


// Функция-конструктор
// Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
//
//     Имя функции-конструктора должно начинаться с большой буквы.
//     Функция-конструктор должна выполняться только с помощью оператора "new".

// Другими словами, new User(...) делает что-то вроде:

function User(name) {
    // this = {};  (неявно)

    // добавляет свойства к this
    this.name = name;
    this.isAdmin = false;

    // return this;  (неявно)
}

// Таким образом, let user = new User("Jack") возвращает тот же результат, что и:

let user = {
    name: "Jack",
    isAdmin: false
};

// Если в нашем коде присутствует большое количество строк, создающих один сложный объект,
// то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:

// создаём функцию и сразу же вызываем её с помощью new
let user = new function () {
    this.name = "John";
    this.isAdmin = false;

    // ...другой код для создания пользователя
    // возможна любая сложная логика и инструкции
    // локальные переменные и так далее
};
// Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся
// и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.


// Возврат значения из конструктора, return
// Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.
//
//     Но если return всё же есть, то применяется простое правило:
//
//     При вызове return с объектом, вместо this вернётся объект.
//     При вызове return с примитивным значением, оно проигнорируется.
//     Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.
//
//     К примеру, здесь return замещает this, возвращая объект:

function BigUser() {

    this.name = "John";

    return {name: "Godzilla"};  // <-- возвращает этот объект
}

alert(new BigUser().name);  // Godzilla, получили этот объект
// А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно):

function SmallUser() {

    this.name = "John";

    return; // <-- возвращает this
}

alert(new SmallUser().name);  // John

//
// Создание методов в конструкторе
// Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.
//
//     Конечно, мы можем добавить к this не только свойства, но и методы.
//
//     Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:

function User(name) {
    this.name = name;

    this.sayHi = function () {
        alert("Меня зовут: " + this.name);
    };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
//







// Опциональная цепочка '?.'
// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил. !!!!!


// Очевидным решением было бы проверить значение с помощью if или условного оператора ?, прежде чем обращаться к его свойству, вот так:

let user = {};

alert(user.address ? user.address.street : undefined);


// Опциональная цепочка
// Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
//
//     Далее в этой статье, для краткости, мы будем говорить, что что-то «существует», если оно не является null и не undefined.
//
//     Другими словами, value?.prop:
//
// работает как value.prop, если значение value существует,
//     в противном случае (когда value равно undefined/null) он возвращает undefined.
//     Вот безопасный способ получить доступ к user.address.street, используя ?.:

let user = {}; // пользователь без адреса

alert(user?.address?.street); // undefined (без ошибки)


// Сокращённое вычисление
// Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть не существует.
//
//     Так что если после ?. есть какие-то вызовы функций или операции, то они не произойдут.
//
//     Например:

let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось


// Другие варианты применения: ?.(), ?.[]
// Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.
//
//     Например, ?.() используется для вызова функции, которая может не существовать.
//
//     В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:

let userAdmin = {
    admin() {
        alert("Я админ");
    }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)


// Тип данных Symbol


//
// Тип данных Symbol
// По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
//
//     До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.
//
//     Символы
// «Символ» представляет собой уникальный идентификатор.
//
//     Создаются новые символы с помощью функции Symbol():

// Создаём новый символ - id
let id = Symbol();
// При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
// Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

// Например, вот два символа с одинаковым описанием – но они не равны:

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false



// Символы в литеральном объекте
// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.

// Вот так:

let id = Symbol("id");

let user = {
    name: "Вася",
    [id]: 123 // просто "id: 123" не сработает
};
// Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
//
// Символы игнорируются циклом for…in

// Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут
// работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.

// Глобальные символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true


// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id




// Хинты
// Как JavaScript решает, какое преобразование применить?
//

"string"
// Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// вывод
alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;



// "number"
// Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

// Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
//
//     Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
//     Иначе, если хинт равен "string"
// попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
//     Иначе, если хинт равен "number" или "default"
// попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

// Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
//
//     Например, здесь объект user реализует его:

let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
        alert(`hint: ${hint}`);
        return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

// Для примера, используем их в реализации всё того же объекта user. Но уже используя комбинацию toString и valueOf вместо Symbol.toPrimitive:

let user = {
    name: "John",
    money: 1000,

    // для хинта равного "string"
    toString() {
        return `{name: "${this.name}"}`;
    },

    // для хинта равного "number" или "default"
    valueOf() {
        return this.money;
    }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500











// Примитив как объект
//
//  Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.


let str = "Привет";
alert(str.toUpperCase()); // ПРИВЕТ

// null/undefined не имеют методов
let billion = 1000000000;

let billion = 1_000_000_000
// Символ нижнего подчёркивания _ – это «синтаксический сахар», он делает число более читабельным.

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

// toString(base)
let num = 255;
alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111


// Внимание! Две точки в 123456..toString(36) это не опечатка.
// Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.


// Округление
// Одна из часто используемых операций при работе с числами – это округление.
//
//     В JavaScript есть несколько встроенных функций для работы с округлением:
//
//     Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
// Math.trunc (не поддерживается в Internet Explorer)
// Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.


// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// alert( 0.1 + 0.2 == 0.3 ); // false
// Да-да, сумма 0.1 и 0.2 не равна 0.3.
//
//     Странно! Что тогда, если не 0.3?
//
//     alert( 0.1 + 0.2 ); // 0.30000000000000004

let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30


('b' + 'a' + +'a' + 'a').toLowerCase()
// banana


// Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:

alert(NaN === NaN); // false


// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num));

// parseInt и parseFloat
// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

alert(+"100px"); // NaN

alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке

Math.random()


let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк


alert( `The backslash: \\` ); // The backslash: \


let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) ); // o


// Также можно перебрать строку посимвольно, используя for..of:
for (let char of "Hello") {
    alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}


//
// Строки неизменяемы
// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.
//
//
//     let str = 'Hi';
//
// str[0] = 'h'; // ошибка
// alert( str[0] ); // не работает
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface


let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

// Необязательный второй аргумент позволяет начать поиск с определённой позиции.
alert( str.indexOf('id', 2) ) // 12

// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
    let foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;

    alert( `Найдено тут: ${foundPos}` );
    pos = foundPos + 1; // продолжаем со следующей позиции
}



str.lastIndexOf(substr, position)
// Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
// Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.


let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}


alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"


let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
// Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)


// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );


// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его.

// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
alert( String.fromCodePoint(90) ); // Z


// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
    str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ






let arr = new Array();
let arr = [];

let fruits = ["Яблоко", "Апельсин", "Слива"];

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert(fruits[0]); // Яблоко
alert(fruits[1]); // Апельсин
alert(fruits[2]); // Слива


fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]


alert(fruits.length); // 3


// В массиве могут храниться элементы любого типа.
// разные типы значений
let arr = ['Яблоко', {name: 'Джон'}, true, function () {
    alert('привет');
}];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert(arr[1].name); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет


// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

let fruits = [
    "Яблоко",
    "Апельсин",
    "Слива",
];
// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.


let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[fruits.length - 1]); // Plum
alert(fruits.at(-1)); // Plum !!! НОВИНКА МОЖЕТ НЕ ВЕЗДЕ РАБОТАТЬ


// Очередь
// first in, first out

// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
// push добавляет элемент в конец.

// стек
// push добавляет элемент в конец.
// pop удаляет последний элемент.


// Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.pop()); // удаляем "Груша" и выводим его
alert(fruits); // Яблоко, Апельсин


// Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert(fruits); // Яблоко, Апельсин, Груша

// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....


// Методы, работающие с началом массива:

// shift
// Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert(fruits.shift()); // удаляем Яблоко и выводим его

alert(fruits); // Апельсин, Груша
// unshift
// Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert(fruits); // Яблоко, Апельсин, Груша
// Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert(fruits);


let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert(arr === fruits); // true

arr.push("Груша"); // массив меняется по ссылке

alert(fruits); // Банан, Груша - теперь два элемента


// Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
// Операция shift должна выполнить 3 действия:

// Удалить элемент с индексом 0.
// Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
//     Обновить свойство length .
// То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.
//


// Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
    alert(arr[i]);
}
// Но для массивов возможен и другой вариант цикла, for..of:

let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
    alert(fruit);
}


// Технически, так как массив является объектом, можно использовать и вариант for..in:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
    alert(arr[key]); // Яблоко, Апельсин, Груша
}
// Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

// В общем, не следует использовать цикл for..in для массивов.


// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fruits = [];
fruits[123] = "Яблоко";

alert(fruits.length); // 124
// Обратите внимание, что обычно мы не используем массивы таким образом.
//
//     Ещё один интересный факт о свойстве length – его можно перезаписать.
//
//     Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:

let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert(arr); // [1, 2]

arr.length = 5; // возвращаем length как было
alert(arr[3]); // undefined: значения не восстановились
// Таким образом, самый простой способ очистить массив – это arr.length = 0;.


// Многомерные массивы
// Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

alert(matrix[1][1]); // 5, центральный элемент


//
// toString
// Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.


let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true


// В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи оператора ==.


// Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
// Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив, как описано в главе Преобразование объектов в примитивы.
// …За исключением null и undefined, которые равны == друг другу и ничему больше.


// Как удалить элемент из массива?

// Так как массивы – это объекты, то можно попробовать delete:

let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert(arr[1]); // undefined

// теперь arr = ["I",  , "home"];
alert(arr.length); // 3


let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert(arr); // осталось ["Я", "JavaScript"]


let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert(arr) // теперь ["Давай", "танцевать", "прямо", "сейчас"]


// Здесь видно, что splice возвращает массив из удалённых элементов:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert(removed); // "Я", "изучаю" <-- массив из удалённых элементов


// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"


let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert(arr); // 1,2,3,4,5


// slice
// Метод arr.slice намного проще, чем похожий на него arr.splice.

arr.slice([start], [end])
// Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

let arr = ["t", "e", "s", "t"];

alert(arr.slice(1, 3)); // e,s (копирует с 1 до 3)

alert(arr.slice(-2)); // s,t (копирует с -2 до конца)
// Можно вызвать slice без аргументов: arr.slice() создаёт копию arr.
// Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.


// concat
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.


let arr = [1, 2];

// создать массив из: arr и [3,4]
alert(arr.concat([3, 4])); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6


// Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:

let arr = [1, 2];

let arrayLike = {
    0: "что-то",
    length: 1
};

alert(arr.concat(arrayLike)); // 1,2,[object Object]
// …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:
let arr = [1, 2];
let arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
};

alert(arr.concat(arrayLike)); // 1,2,что-то,ещё


// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

arr.forEach(function (item, index, array) {
    // ... делать что-то с item
});
// Например, этот код выведет на экран каждый элемент массива:

// Вызов alert для каждого элемента
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
// А этот вдобавок расскажет и о позиции элемента в целевом массиве:

["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
    alert(`У ${item} индекс ${index} в ${array}`);
});


let arr = [1, 0, false];

alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2
alert(arr.indexOf(null)); // -1

alert(arr.includes(1)); // true

// Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.


let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert(fruits.indexOf('Яблоко')); // 0 (первый 'Яблоко')
alert(fruits.lastIndexOf('Яблоко')); // 2 (последний 'Яблоко')


// Метод includes правильно обрабатывает NaN
// Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от indexOf:

const arr = [NaN];
alert(arr.indexOf(NaN)); // -1 (неверно, должен быть 0)
alert(arr.includes(NaN));// true (верно)
// Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный алгоритм сравнения.


// find и findIndex/findLastIndex

function isPrime(element, index, array) {
    var start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {
            return false;
        }
    }
    return element > 1;
}

console.log([4, 6, 8, 12].find(isPrime)); // undefined, не найдено
console.log([4, 5, 8, 12].find(isPrime)); // 5

let result = arr.find(function (item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"},
    {id: 4, name: "Вася"}
];

// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0

// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3


// filter
// Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
//
//     Если найденных элементов может быть много, можно использовать arr.filter(fn).
//
//     Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

let results = arr.filter(function (item, index, array) {
    // если `true` -- элемент добавляется к results и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});
// Например:

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2


// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.


let result = arr.map(function (item, index, array) {
    // возвращается новое значение вместо элемента
});
// Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6


// sort(fn)
// По умолчанию элементы сортируются как строки.
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}

let arr = [1, 2, 15];
arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
[1, -2, 15, 2, 0, 8].sort(function (a, b) {
    alert(a + " <> " + b);
    return a - b;
});

let arr = [1, 2, 15];
arr.sort(function (a, b) {
    return a - b;
});
alert(arr);  // 1, 2, 15

// стрелочные функции

arr.sort((a, b) => a - b);


// Используйте localeCompare для строк
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert(countries.sort((a, b) => a > b ? 1 : -1)); // Andorra, Vietnam, Österreich (неправильно)
alert(countries.sort((a, b) => a.localeCompare(b))); // Andorra,Österreich,Vietnam (правильно!)


// reverse
// Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert(arr); // 5,4,3,2,1


// split и join

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
    alert(`Сообщение получат: ${name}.`); // Сообщение получат: Вася (и другие имена)
}
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert(str.split('')); // т,е,с,т


let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert(str); // Вася;Петя;Маша


// let value = arr.reduce(function(accumulator, item, index, array) {
//     // ...
// }, [initial]);
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

// Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.


// Массивы не образуют отдельный тип данных. Они основаны на объектах.
alert(typeof {}); // object
alert(typeof []); // тоже object

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true


for (let char of "test") {
    // срабатывает 4 раза: по одному для каждого символа
    alert(char); // t, затем e, затем s, затем t
}


// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
//     map.size – возвращает текущее количество элементов.

let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3


// в обычном обьекте нельзя нормально сделать поле обьектом, а в map можно
let john = {name: "John"};
let ben = {name: "Ben"};

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет замещён

// Вот что там было записано!
alert(visitsCountObj["[object Object]"]); // 123


//map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.


let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук", 50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
    alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
    alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
    alert(entry); // огурец,500 (и так далее)
}


// Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
    alert(`${key}: ${value}`); // огурец: 500 и так далее
});


// Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
    name: "John",
    age: 30
};

let map = new Map(Object.entries(obj));

alert(map.get('name')); // John


// Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2


//Set
// Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
//
// Его основные методы это:
//
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.
// Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

let set = new Set();

let john = {name: "John"};
let pete = {name: "Pete"};
let mary = {name: "Mary"};

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
    alert(user.name); // John (потом Pete и Mary)
}

// Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:
let set = new Set(["апельсин", "яблоко", "банан"]);
for (let value of set) alert(value);
// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
    alert(value);
});


//set.values() – возвращает перебираемый объект для значений,
// set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
// set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


let john = {name: "John"};

let array = [john];
john.name = 123;
console.log(john)// 123!!!
console.log(array)// 123!!!


// Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект


Object.keys(obj), Object.values(obj), Object.entries(obj).map.keys(), map.values(), map.entries()
//     Методы поддерживаются для структур:
// Map
// Set
// Array

let user = {
    name: "John",
    age: 30
};
// Object.keys(user) = ["name", "age"]
// Object.values(user) = ["John", 30]
// Object.entries(user) = [ ["name","John"], ["age",30] ]

let user = {
    name: "John",
    age: 30
};

// перебор значений
for (let value of Object.values(user)) {
    alert(value); // John, затем 30
}


//Object.keys/values/entries игнорируют символьные свойства
// Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.


//Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:
//
// Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:
//
let prices = {
    banana: 1,
    orange: 2,
    meat: 4,
};

let doublePrices = Object.fromEntries(
    // преобразовать в массив, затем map, затем fromEntries обратно объект
    Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8


// Деструктуризация массива
// Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
alert(firstName); // Ilya
alert(surname);  // Kantor


// «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2


//Деструктуризация объекта

let options = {
    title: "Menu",
    width: 100,
    height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200


let now = new Date();
alert(now); // показывает текущие дату и время

// Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert(Jan01_1970);

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert(Jan02_1970);


// Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

// Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert(Dec31_1969);


let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)


new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
// Максимальная точность – 1 мс (до 1/1000 секунды):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(date); // 1.01.2011, 02:03:04.567

// getFullYear()
// Получить год (4 цифры)
// getMonth()
// Получить месяц, от 0 до 11.
// getDate()
// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getDay()
// getTime()


// getTimezoneOffset()
// Возвращает разницу в минутах между UTC и местным часовым поясом:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert(new Date().getTimezoneOffset());

// Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0:
// getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить

//Установка компонентов даты
// Следующие методы позволяют установить компоненты даты и времени:
//
// setFullYear(year, [month], [date])
// setMonth(month, [date])
// setDate(date)
// setHours(hour, [min], [sec], [ms])
// setMinutes(min, [sec], [ms])
// setSeconds(sec, [ms])
// setMilliseconds(ms)
// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().


// Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!

let date = new Date();
alert(+date); // количество миллисекунд, то же самое, что date.getTime()


let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
    let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert(`Цикл отработал за ${end - start} миллисекунд`); // вычитаются числа, а не даты


// Но какая функция быстрее?
//
//     Для начала можно запустить их много раз подряд и засечь разницу. В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.
//
//     Проведём измерения:

function diffSubtract(date1, date2) {
    return date2 - date1;
}

function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime();
}

function bench(f) {
    let date1 = new Date(0);
    let date2 = new Date();

    let start = Date.now();
    for (let i = 0; i < 100000; i++) f(date1, date2);
    return Date.now() - start;
}

alert('Время diffSubtract: ' + bench(diffSubtract) + 'мс');
alert('Время diffGetTime: ' + bench(diffGetTime) + 'мс');
// Вот это да! Метод getTime() работает ощутимо быстрее! Всё потому, что не производится преобразование типов, и интерпретаторам такое намного легче оптимизировать.

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)


// JSON.stringify для преобразования объектов в JSON.
// JSON.parse для преобразования JSON обратно в объект.

let student = {
    name: 'John',
    age: 30,
    isAdmin: false,
    courses: ['html', 'css', 'js'],
    wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // мы получили строку!

alert(json);
/* выведет объект в формате JSON:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
// число в JSON остаётся числом
alert( JSON.stringify(1) ) // 1

// строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]


//JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.
//
// Свойства-функции (методы).
// Символьные ключи и значения.
// Свойства, содержащие undefined.
let user = {
    sayHi() { // будет пропущено
        alert("Hello");
    },
    [Symbol("id")]: 123, // также будет пропущено
    something: undefined // как и это - пропущено
};

alert( JSON.stringify(user) ); // {} (пустой объект)

// Вот типичные ошибки в написанном от руки JSON (иногда приходится писать его для отладки):
JSON.parse(json);
let json = `{
  name: "John",                     // Ошибка: имя свойства без кавычек
  "surname": 'Smith',               // Ошибка: одинарные кавычки в значении (должны быть двойными)
  'isAdmin': false,                 // Ошибка: одинарные кавычки в ключе (должны быть двойными)
  "birthday": new Date(2000, 2, 3), // Ошибка: не допускается конструктор "new", только значения
  "gender": "male"                  // Ошибка: отсутствует запятая после непоследнего свойства
  "friends": [0,1,2,3],             // Ошибка: не должно быть запятой после последнего свойства
}`;

let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
    if (key == 'date') return new Date(value);
    return value;
});

alert( schedule.meetups[1].date.getDate() ); // 18 - отлично!






























































































































