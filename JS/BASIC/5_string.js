// Примитив как объект
//
//  Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.


let str = "Привет";
alert(str.toUpperCase()); // ПРИВЕТ

// null/undefined не имеют методов
let billion = 1000000000;

let billion = 1_000_000_000
// Символ нижнего подчёркивания _ – это «синтаксический сахар», он делает число более читабельным.

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

// toString(base)
let num = 255;
alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111


// Внимание! Две точки в 123456..toString(36) это не опечатка.
// Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.


// Округление
// Одна из часто используемых операций при работе с числами – это округление.
//
//     В JavaScript есть несколько встроенных функций для работы с округлением:
//
//     Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
// Math.trunc (не поддерживается в Internet Explorer)
// Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.


// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// alert( 0.1 + 0.2 == 0.3 ); // false
// Да-да, сумма 0.1 и 0.2 не равна 0.3.
//
//     Странно! Что тогда, если не 0.3?
//
//     alert( 0.1 + 0.2 ); // 0.30000000000000004

let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30


('b' + 'a' + +'a' + 'a').toLowerCase()
// banana


// Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:

alert(NaN === NaN); // false


// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num));

// parseInt и parseFloat
// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

alert(+"100px"); // NaN

alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке

Math.random()


let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

    function sum(a, b) {
        return a + b;
    }

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

    let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк


alert( `The backslash: \\` ); // The backslash: \


let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) ); // o


// Также можно перебрать строку посимвольно, используя for..of:
    for (let char of "Hello") {
        alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
    }


//
// Строки неизменяемы
// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.
//
//
//     let str = 'Hi';
//
// str[0] = 'h'; // ошибка
// alert( str[0] ); // не работает
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface


let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

// Необязательный второй аргумент позволяет начать поиск с определённой позиции.
alert( str.indexOf('id', 2) ) // 12

// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

    let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
    let foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;

    alert( `Найдено тут: ${foundPos}` );
    pos = foundPos + 1; // продолжаем со следующей позиции
}



str.lastIndexOf(substr, position)
// Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
// Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.


let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}


alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

    alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

    alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"


let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
// Если аргумент end отсутствует, slice возвращает символы до конца строки:

    let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

 let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)


// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

    let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

    let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );


// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его.

// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
alert( String.fromCodePoint(90) ); // Z


// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

    let str = '';

for (let i = 65; i <= 220; i++) {
    str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ















































