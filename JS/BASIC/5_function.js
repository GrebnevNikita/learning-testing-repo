


// Стрелочные функции, основы
let sum = (a, b) => a + b;
// let sum = (a, b) => {
// return a + b;
// };
// let sum = function(a, b) {
// return a + b;
// };
alert(sum(1, 2)); // 3





function sayHi() {   // (1) создаём
    alert("Привет");
}

let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    // эта тоже все ещё работает (почему бы и нет)
let sayHi = function () {
};



// Функция называется «вложенной», когда она создаётся внутри другой функции.
function sayHiBye(firstName, lastName) {
    // функция-помощник, которую мы используем ниже
    function getFullName() {
        return firstName + " " + lastName;
    }

    alert("Hello, " + getFullName());
    alert("Bye, " + getFullName());
}

// Ниже, makeCounter создает функцию «счётчик», которая при каждом вызове возвращает следующее число:
function makeCounter() {
    let count = 0;
    return function () {
        return count++; // есть доступ к внешней переменной "count"
    };
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2




// Замыкания
// В программировании есть общий термин: «замыкание», – который должен знать каждый разработчик.
// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// В некоторых языках это невозможно, или функция должна быть написана специальным образом,
// чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются
// замыканиями (есть только одно исключение, про которое будет рассказано

// Для «var» не существует блочной области видимости


// Глобальный объект
// Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.
// По умолчанию это те, что встроены в язык или среду исполнения.
// В браузере он называется window


// Объект функции, NFE
// Как мы уже знаем, в JavaScript функция – это значение.
// Каждое значение в JavaScript имеет свой тип. А функция – это какой тип?
// В JavaScript функции – это объекты.
function sayHi() {
    alert("Hi");
}

alert(sayHi.name); // sayHi // имя функции
let sayHi = function () {
    alert("Hi");
};
alert(sayHi.name); // sayHi (есть имя!)
let user = {
    sayHi() {
        // ...
    },
    sayBye: function () {
        // ...
    }
}
alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
// функция объявлена внутри массива
let arr = [function () {
}];
alert(arr[0].name); // <пустая строка>
// здесь отсутствует возможность определить имя, поэтому его нет


// Свойство «length»
// Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. Например:
function f1(a) {
}

function f2(a, b) {
}

function many(a, b, ...more) {
}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2


// Пользовательские свойства
// Мы также можем добавить свои собственные свойства.
// Давайте добавим свойство counter для отслеживания общего количества вызовов:
function sayHi() {
    alert("Hi");
    // давайте посчитаем, сколько вызовов мы сделали
    sayHi.counter++;
}

sayHi.counter = 0; // начальное значение
sayHi(); // Hi
sayHi(); // Hi
alert(`Вызвана ${sayHi.counter} раза`); // Вызвана 2 раза


// Синтаксис "new Function"
// Существует ещё один вариант объявления функции. Он используется крайне редко, но иногда другого решения не найти.
let func = new Function([arg1, arg2, ...argN], functionBody);
// Функция создаётся с заданными аргументами arg1...argN и телом functionBody.
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
// А вот функция без аргументов, в этом случае достаточно указать только тело:
let sayHi = new Function('alert("Hello")');
sayHi(); // Hello
// let str = ... код, полученный с сервера динамически ...
let func = new Function(str);
func();












