// Опциональная цепочка '?.'
// Новая возможность
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил. !!!!!


// Очевидным решением было бы проверить значение с помощью if или условного оператора ?, прежде чем обращаться к его свойству, вот так:

let user = {};

alert(user.address ? user.address.street : undefined);


// Опциональная цепочка
// Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
//
//     Далее в этой статье, для краткости, мы будем говорить, что что-то «существует», если оно не является null и не undefined.
//
//     Другими словами, value?.prop:
//
// работает как value.prop, если значение value существует,
//     в противном случае (когда value равно undefined/null) он возвращает undefined.
//     Вот безопасный способ получить доступ к user.address.street, используя ?.:

let user = {}; // пользователь без адреса

alert(user?.address?.street); // undefined (без ошибки)


// Сокращённое вычисление
// Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть не существует.
//
//     Так что если после ?. есть какие-то вызовы функций или операции, то они не произойдут.
//
//     Например:

let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось


// Другие варианты применения: ?.(), ?.[]
// Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.
//
//     Например, ?.() используется для вызова функции, которая может не существовать.
//
//     В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:

let userAdmin = {
    admin() {
        alert("Я админ");
    }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)


// Тип данных Symbol


//
// Тип данных Symbol
// По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
//
//     До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.
//
//     Символы
// «Символ» представляет собой уникальный идентификатор.
//
//     Создаются новые символы с помощью функции Symbol():

// Создаём новый символ - id
let id = Symbol();
// При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
// Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

// Например, вот два символа с одинаковым описанием – но они не равны:

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false



// Символы в литеральном объекте
// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.

    // Вот так:

    let id = Symbol("id");

let user = {
    name: "Вася",
    [id]: 123 // просто "id: 123" не сработает
};
// Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
//
// Символы игнорируются циклом for…in

// Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут
// работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.

// Глобальные символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true


// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id




// Хинты
// Как JavaScript решает, какое преобразование применить?
//

"string"
// Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// вывод
    alert(obj);

// используем объект в качестве ключа
anotherObj[obj] = 123;



// "number"
// Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
    let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

// Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
//
//     Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
//     Иначе, если хинт равен "string"
// попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
//     Иначе, если хинт равен "number" или "default"
// попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

// Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
//
//     Например, здесь объект user реализует его:

    let user = {
        name: "John",
        money: 1000,

        [Symbol.toPrimitive](hint) {
            alert(`hint: ${hint}`);
            return hint == "string" ? `{name: "${this.name}"}` : this.money;
        }
    };

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

// Для примера, используем их в реализации всё того же объекта user. Но уже используя комбинацию toString и valueOf вместо Symbol.toPrimitive:

let user = {
    name: "John",
    money: 1000,

    // для хинта равного "string"
    toString() {
        return `{name: "${this.name}"}`;
    },

    // для хинта равного "number" или "default"
    valueOf() {
        return this.money;
    }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500











































