


// Примитив как объект
// Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
let str = "Привет";
alert(str.toUpperCase()); // ПРИВЕТ
// null/undefined не имеют методов
let billion = 1000000000;
let billion = 1_000_000_000 // Символ нижнего подчёркивания _ – это «синтаксический сахар», он делает число более читабельным.
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

let num = 255;
alert(num.toString(16));  // ff // toString(base)
alert(num.toString(2));   // 11111111 // toString(base)
// Внимание! Две точки в 123456..toString(36) это не опечатка.
// Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.


// Округление
// Одна из часто используемых операций при работе с числами – это округление.
// В JavaScript есть несколько встроенных функций для работы с округлением:
// Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
let num = 12.34;
alert(num.toFixed(1)); // "12.3"
alert(0.1 + 0.2 == 0.3); // false
// Да-да, сумма 0.1 и 0.2 не равна 0.3.
// Странно! Что тогда, если не 0.3?
// alert( 0.1 + 0.2 ); // 0.30000000000000004
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
('b' + 'a' + +'a' + 'a').toLowerCase()
// banana
// Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:
alert(NaN === NaN); // false
// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num));

// parseInt и parseFloat
// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
alert(+"100px"); // NaN
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5
alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке
Math.random()



// Итеративный способ: цикл for:
function pow(x, n) {
    let result = 1;
    // умножаем result на x n раз в цикле
    for (let i = 0; i < n; i++) {
        result *= x;
    }
    return result;
}

alert(pow(2, 3)); // 8
// Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
}

alert(pow(2, 3)); // 8




