
//Генераторы
//Обычные функции возвращают только одно-единственное значение (или ничего).
//
//Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости.
// Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.


// Функция-генератор
// Для объявления генератора используется специальная синтаксическая конструкция: function*, которая называется «функция-генератор».

function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
}

// "функция-генератор" создаёт объект "генератор"
let generator = generateSequence();
alert(generator); // [object Generator]

//Основным методом генератора является next(). При вызове он запускает выполнение кода до ближайшей
// инструкции yield <значение> (значение может отсутствовать, в этом случае оно предполагается равным undefined).
// По достижении yield выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:
let one = generator.next();
alert(JSON.stringify(one)); // {value: 1, done: false}

// Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield:
let two = generator.next();
alert(JSON.stringify(two)); // {value: 2, done: false}

// И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
let three = generator.next();
alert(JSON.stringify(three)); // {value: 3, done: true}

// Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true}.


// function* f(…) или function *f(…)?
// Нет разницы, оба синтаксиса корректны.


// Перебор генераторов
function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
}

let generator = generateSequence();

for (let value of generator) {
    alert(value); // 1, затем 2
}
// …Но обратите внимание: пример выше выводит значение 1, затем 2. Значение 3 выведено не будет!
//Это из-за того, что перебор через for..of игнорирует последнее значение, при котором done: true.



function* generateSequence() {
    yield 1;
    yield 2;
    yield 3;
}
let sequence = [0, ...generateSequence()];

alert(sequence); // 0, 1, 2, 3
// В коде выше ...generateSequence() превращает перебираемый объект-генератор в массив элементов





// Композиция генераторов
// сначала цифры 0..9 (с кодами символов 48…57)
// за которыми следуют буквы в верхнем регистре A..Z (коды символов 65…90)
// за которыми следуют буквы алфавита a..z (коды символов 97…122)
//Для генераторов есть особый синтаксис yield*, который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).
function* generateSequence(start, end) {
    for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {

    // 0..9
    yield* generateSequence(48, 57);

    // A..Z
    yield* generateSequence(65, 90);

    // a..z
    yield* generateSequence(97, 122);

}

let str = '';

for(let code of generatePasswordCodes()) {
    str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z

//Итого
// Генераторы создаются при помощи функций-генераторов function* f(…) {…}.
// Внутри генераторов и только внутри них существует оператор yield.
// Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.


