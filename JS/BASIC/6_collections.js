let arr = new Array();
let arr = [];

let fruits = ["Яблоко", "Апельсин", "Слива"];

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert(fruits[0]); // Яблоко
alert(fruits[1]); // Апельсин
alert(fruits[2]); // Слива


fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]


alert(fruits.length); // 3


// В массиве могут храниться элементы любого типа.
// разные типы значений
let arr = ['Яблоко', {name: 'Джон'}, true, function () {
    alert('привет');
}];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert(arr[1].name); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет


// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

let fruits = [
    "Яблоко",
    "Апельсин",
    "Слива",
];
// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.


let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[fruits.length - 1]); // Plum
alert(fruits.at(-1)); // Plum !!! НОВИНКА МОЖЕТ НЕ ВЕЗДЕ РАБОТАТЬ


// Очередь
// first in, first out

// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.
// push добавляет элемент в конец.

// стек
// push добавляет элемент в конец.
// pop удаляет последний элемент.


// Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.pop()); // удаляем "Груша" и выводим его
alert(fruits); // Яблоко, Апельсин


// Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert(fruits); // Яблоко, Апельсин, Груша

// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....


// Методы, работающие с началом массива:

// shift
// Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert(fruits.shift()); // удаляем Яблоко и выводим его

alert(fruits); // Апельсин, Груша
// unshift
// Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert(fruits); // Яблоко, Апельсин, Груша
// Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert(fruits);


let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert(arr === fruits); // true

arr.push("Груша"); // массив меняется по ссылке

alert(fruits); // Банан, Груша - теперь два элемента


// Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
// Операция shift должна выполнить 3 действия:

// Удалить элемент с индексом 0.
// Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
//     Обновить свойство length .
// То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.
//


// Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
    alert(arr[i]);
}
// Но для массивов возможен и другой вариант цикла, for..of:

let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям
for (let fruit of fruits) {
    alert(fruit);
}


// Технически, так как массив является объектом, можно использовать и вариант for..in:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
    alert(arr[key]); // Яблоко, Апельсин, Груша
}
// Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

// В общем, не следует использовать цикл for..in для массивов.


// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fruits = [];
fruits[123] = "Яблоко";

alert(fruits.length); // 124
// Обратите внимание, что обычно мы не используем массивы таким образом.
//
//     Ещё один интересный факт о свойстве length – его можно перезаписать.
//
//     Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. Этот процесс необратим, как мы можем понять из примера:

let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert(arr); // [1, 2]

arr.length = 5; // возвращаем length как было
alert(arr[3]); // undefined: значения не восстановились
// Таким образом, самый простой способ очистить массив – это arr.length = 0;.


// Многомерные массивы
// Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

alert(matrix[1][1]); // 5, центральный элемент


//
// toString
// Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.


let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true


// В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи оператора ==.


// Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
// Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив, как описано в главе Преобразование объектов в примитивы.
// …За исключением null и undefined, которые равны == друг другу и ничему больше.


// Как удалить элемент из массива?

// Так как массивы – это объекты, то можно попробовать delete:

let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert(arr[1]); // undefined

// теперь arr = ["I",  , "home"];
alert(arr.length); // 3


let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert(arr); // осталось ["Я", "JavaScript"]


let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert(arr) // теперь ["Давай", "танцевать", "прямо", "сейчас"]


// Здесь видно, что splice возвращает массив из удалённых элементов:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert(removed); // "Я", "изучаю" <-- массив из удалённых элементов


// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"


let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert(arr); // 1,2,3,4,5


// slice
// Метод arr.slice намного проще, чем похожий на него arr.splice.

arr.slice([start], [end])
// Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

let arr = ["t", "e", "s", "t"];

alert(arr.slice(1, 3)); // e,s (копирует с 1 до 3)

alert(arr.slice(-2)); // s,t (копирует с -2 до конца)
// Можно вызвать slice без аргументов: arr.slice() создаёт копию arr.
// Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.


// concat
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.


let arr = [1, 2];

// создать массив из: arr и [3,4]
alert(arr.concat([3, 4])); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6


// Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:

let arr = [1, 2];

let arrayLike = {
    0: "что-то",
    length: 1
};

alert(arr.concat(arrayLike)); // 1,2,[object Object]
// …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:
let arr = [1, 2];
let arrayLike = {
    0: "что-то",
    1: "ещё",
    [Symbol.isConcatSpreadable]: true,
    length: 2
};

alert(arr.concat(arrayLike)); // 1,2,что-то,ещё


// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

arr.forEach(function (item, index, array) {
    // ... делать что-то с item
});
// Например, этот код выведет на экран каждый элемент массива:

// Вызов alert для каждого элемента
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
// А этот вдобавок расскажет и о позиции элемента в целевом массиве:

["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
    alert(`У ${item} индекс ${index} в ${array}`);
});


let arr = [1, 0, false];

alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2
alert(arr.indexOf(null)); // -1

alert(arr.includes(1)); // true

// Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.


let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert(fruits.indexOf('Яблоко')); // 0 (первый 'Яблоко')
alert(fruits.lastIndexOf('Яблоко')); // 2 (последний 'Яблоко')


// Метод includes правильно обрабатывает NaN
// Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от indexOf:

const arr = [NaN];
alert(arr.indexOf(NaN)); // -1 (неверно, должен быть 0)
alert(arr.includes(NaN));// true (верно)
// Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный алгоритм сравнения.


// find и findIndex/findLastIndex

function isPrime(element, index, array) {
    var start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {
            return false;
        }
    }
    return element > 1;
}

console.log([4, 6, 8, 12].find(isPrime)); // undefined, не найдено
console.log([4, 5, 8, 12].find(isPrime)); // 5

let result = arr.find(function (item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася


let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"},
    {id: 4, name: "Вася"}
];

// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0

// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3


// filter
// Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
//
//     Если найденных элементов может быть много, можно использовать arr.filter(fn).
//
//     Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

let results = arr.filter(function (item, index, array) {
    // если `true` -- элемент добавляется к results и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});
// Например:

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2


// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.


let result = arr.map(function (item, index, array) {
    // возвращается новое значение вместо элемента
});
// Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6


// sort(fn)
// По умолчанию элементы сортируются как строки.
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}

let arr = [1, 2, 15];
arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
[1, -2, 15, 2, 0, 8].sort(function (a, b) {
    alert(a + " <> " + b);
    return a - b;
});

let arr = [1, 2, 15];
arr.sort(function (a, b) {
    return a - b;
});
alert(arr);  // 1, 2, 15

// стрелочные функции

arr.sort((a, b) => a - b);


// Используйте localeCompare для строк
let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert(countries.sort((a, b) => a > b ? 1 : -1)); // Andorra, Vietnam, Österreich (неправильно)
alert(countries.sort((a, b) => a.localeCompare(b))); // Andorra,Österreich,Vietnam (правильно!)


// reverse
// Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert(arr); // 5,4,3,2,1


// split и join

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
    alert(`Сообщение получат: ${name}.`); // Сообщение получат: Вася (и другие имена)
}
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert(str.split('')); // т,е,с,т


let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert(str); // Вася;Петя;Маша


// let value = arr.reduce(function(accumulator, item, index, array) {
//     // ...
// }, [initial]);
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

// Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.


// Массивы не образуют отдельный тип данных. Они основаны на объектах.
alert(typeof {}); // object
alert(typeof []); // тоже object

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true


for (let char of "test") {
    // срабатывает 4 раза: по одному для каждого символа
    alert(char); // t, затем e, затем s, затем t
}


// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
//     map.size – возвращает текущее количество элементов.

let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3


// в обычном обьекте нельзя нормально сделать поле обьектом, а в map можно
let john = {name: "John"};
let ben = {name: "Ben"};

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет замещён

// Вот что там было записано!
alert(visitsCountObj["[object Object]"]); // 123


//map.keys() – возвращает итерируемый объект по ключам,
// map.values() – возвращает итерируемый объект по значениям,
// map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.


let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук", 50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
    alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
    alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
    alert(entry); // огурец,500 (и так далее)
}


// Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
    alert(`${key}: ${value}`); // огурец: 500 и так далее
});


// Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
    name: "John",
    age: 30
};

let map = new Map(Object.entries(obj));

alert(map.get('name')); // John


// Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2


//Set
// Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
//
// Его основные методы это:
//
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.
// Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

let set = new Set();

let john = {name: "John"};
let pete = {name: "Pete"};
let mary = {name: "Mary"};

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
    alert(user.name); // John (потом Pete и Mary)
}

// Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:
let set = new Set(["апельсин", "яблоко", "банан"]);
for (let value of set) alert(value);
// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
    alert(value);
});


//set.values() – возвращает перебираемый объект для значений,
// set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
// set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


let john = {name: "John"};

let array = [john];
john.name = 123;
console.log(john)// 123!!!
console.log(array)// 123!!!


// Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект


Object.keys(obj), Object.values(obj), Object.entries(obj).map.keys(), map.values(), map.entries()
//     Методы поддерживаются для структур:
// Map
// Set
// Array

let user = {
    name: "John",
    age: 30
};
// Object.keys(user) = ["name", "age"]
// Object.values(user) = ["John", 30]
// Object.entries(user) = [ ["name","John"], ["age",30] ]

let user = {
    name: "John",
    age: 30
};

// перебор значений
for (let value of Object.values(user)) {
    alert(value); // John, затем 30
}


//Object.keys/values/entries игнорируют символьные свойства
// Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.


//Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:
//
// Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:
//
let prices = {
    banana: 1,
    orange: 2,
    meat: 4,
};

let doublePrices = Object.fromEntries(
    // преобразовать в массив, затем map, затем fromEntries обратно объект
    Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8


// Деструктуризация массива
// Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
alert(firstName); // Ilya
alert(surname);  // Kantor


// «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2


//Деструктуризация объекта

let options = {
    title: "Menu",
    width: 100,
    height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200


let now = new Date();
alert(now); // показывает текущие дату и время

// Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert(Jan01_1970);

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert(Jan02_1970);


// Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

// Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert(Dec31_1969);


let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)


new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
// Максимальная точность – 1 мс (до 1/1000 секунды):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(date); // 1.01.2011, 02:03:04.567

// getFullYear()
// Получить год (4 цифры)
// getMonth()
// Получить месяц, от 0 до 11.
// getDate()
// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getDay()
// getTime()


// getTimezoneOffset()
// Возвращает разницу в минутах между UTC и местным часовым поясом:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert(new Date().getTimezoneOffset());









































































